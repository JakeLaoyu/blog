[{"title":"注册ChatGPT详细指南","url":"/2022/12/09/注册ChatGPT详细指南/","content":"\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/cbsn-fusion-promise-fear-of-artificial-intelligence-bot-chatgpt-thumbnail-1528537-640x360.jpeg)\n\n<!--more-->\n\n最近ChatGPT真受欢迎，但是有些人注册时会经常面临不服务它们的地区问题，现在我们给你详细问题解决。\n\n作者 [twitter](https://twitter.com/BoxMrChen)\n\n# 准备\n\n1. 代理。要求是韩国，日本，印度，新加坡，美国这些国家的地址都合适。对其他的我们还不太清楚，反正香港或中国的代理肯定不行。[推荐机场](https://join.v2club.cc/#/register?code=C5EnE7vC)\n2. 找一个国外手机号码，如果你没有用过接码平台也行，有些接码平台是无法接的，所以我们推荐一个就是 [sms-activate.org](https://sms-activate.org/?ref=2862835)\n3. 准备一个浏览器\n\n# 开始一步一步注册\n## 第一步是接验证码\n\n打开接码平台 [sms-activate.org](https://sms-activate.org/?ref=2862835)，注册一个账号\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/pasted%20image%200.png)\n\n然后要充值余额\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/image.png)\n\n一次接码OpenAi的验证码费用是大概11卢布，人民币来看差不多是1块钱，不过只能充美金，就先充直个1美金钱。可以选择对你任何方便方式。支付宝也有\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/image%20(1).png)\n\n充值完成可能需要等一会，就先放着，直接进行下一步。\n\n## 第二部是注册一个OpenAI账号\n\n首先打开[ChatGPT的账户注册页面](https://beta.openai.com/signup)。谷歌注册或者邮箱注册都可以，无所谓，我们这里用邮箱注册作为例子。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/Untitled.png)\n\n用邮箱注册后你要验证邮件。进去邮箱，查看email里的链接。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/image-2.png)\n\n这里你需要输入需要的信息。\n\n当然，有一些人会在这里遇到一个问题，会出现说不能在当前国家服务的提示。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/image-3.png)\n\n不用怕，这个这文章就帮助你解决这个问题。\n\n这方面那，给你一招。一般你出现这种问题，就是因为你的代理没有全局，或者位置不对。香港或中国的的代理是100%无法通过的。\n\n这个问题是非常神奇的，只要你出现了这个提示，那么你接下来怎么切换代理，都是没用的。现在提供给你你一招解决。\n\n## 解决地区问题\n\n先，你要把你的代理切换到任何合适的地区，我们这里选择了韩国。\n\n然后，先复制下面这段代码\n\n```js\nwindow.localStorage.removeItem(Object.keys(window.localStorage).find(i=>i.startsWith('@@auth0spajs')))\n```\n\n接着在地址栏里输入\n\n```js\njavascript:\n```\n\n请注意，这里一定要输入，因为你复制的话是粘贴不了的。\n\n然后再粘贴我们第一段复制的内容：\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/Untitled-1.png)\n\n然后按下回车键，刷新页面。如果你的代理没问题，就可以看到正常工作的注册页面了。\n\n## 输入手机号码\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/Untitled-2.png)\n\n这里选的是韩国，这是因为我们使用韩国的代理，但是我们最好选择印度。然后到我们的接码网站上去。在左侧搜索OpenAi，然后点击印度。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/sdfdskfjdls.png)\n\n点击”小黄车”。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/pasted%20image%200-2.png)\n\n然后我们复制这个号码，粘贴过去。然后我们点击发送验证码就完成了。\n\n等一会网站会提示验证码，我们复制粘贴。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/image-4.png)\n\n这里你要选择你打算如何使用OpenAI。随便选择吧。\n\n## 使用ChatGPT\n\n注册完后，打开[ChatGPT网站](https://chat.openai.com/auth/login)去登陆。\n\n![](//blogimg.jakeyu.top/%E6%B3%A8%E5%86%8CChatGPT%E8%AF%A6%E7%BB%86%E6%8C%87%E5%8D%97/Untitled-5.png)\n\n在下面这个地方就可以开始写你的任何巧妙的句子了。取乐吧！","tags":["工具"],"categories":["工具"]},{"title":"vscode 插件之代码补全提示","url":"/2021/12/04/vscode-插件之代码补全提示/","content":"\n![](//blogimg.jakeyu.top/vscode-%E6%8F%92%E4%BB%B6%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E6%8F%90%E7%A4%BA/v2-30670b252d59bcc15c040f783d79f5e9_720w.png)\n\n<!--more-->\n\n# 前言\n\nvscode 插件提供了很强大个能力，借助插件可以帮助我们提升开发效率。\n\n在写 node 项目时经常需要相对路径寻找引用 Service 文件等，写一个插件帮我们自动补全。\n\n借助 [`vscode.languages.registerCompletionItemProvider`](https://code.visualstudio.com/api/references/vscode-api) 方法，我们可以注册相关补全提示。\n\n# 注册服务\n\n```ts\nexport function activate(context: vscode.ExtensionContext) {\n  context.subscriptions.push(\n    vscode.languages.registerCompletionItemProvider(\"typescript\", {\n      provideCompletionItems,\n    })\n  );\n}\n```\n\n# provideCompletionItems\n\n```ts\nconst provideCompletionItems = async (\n  document: vscode.TextDocument,\n  position: vscode.Position\n) => {\n  const serviceFiles = await vscode.workspace.findFiles(\"app/services/**/*.ts\");\n\n  if (!serviceFiles.length) {\n    return;\n  }\n\n  return serviceFiles.map((file) => {\n    // 生成相对当前编辑文件的相对路径\n    const relativePath = path.relative(\n      path.dirname(document.uri.path),\n      path.dirname(file.path)\n    );\n\n    const basename = path.basename(file.path);\n    const extname = path.extname(file.path);\n    const filename = basename.replace(extname, \"\");\n    const insertText = `import ${filename} from '${relativePath}/${filename}';\\n${filename}`;\n\n    const completionItem = new vscode.CompletionItem(\n      filename,\n      vscode.CompletionItemKind.Class\n    );\n\n    completionItem.detail = basename;\n    completionItem.insertText = insertText;\n    completionItem.documentation = `${insertText}`;\n\n    return completionItem;\n  });\n};\n```\n\n# 配置\n\n同时我们需要在 package.json 中添加相应配置\n\n```json\n{\n  \"activationEvents\": [\n    \"onLanguage:typescript\"\n  ],\n}\n```\n\n# 参考\n\n- [VS Code API](https://code.visualstudio.com/api/references/vscode-api)\n- [VS-Code-Extension-Doc-ZH](https://github.com/Liiked/VS-Code-Extension-Doc-ZH)","tags":["前端","vscode"],"categories":["vscode"]},{"title":"centos 使用 Clash 梯子","url":"/2021/11/27/centos-使用-Clash-梯子/","content":"\n服务器访问 npm、github 等真让人捉急，折腾一下配个 clash。\n\n![](//blogimg.jakeyu.top/centos-使用-Clash-梯子/logo.png)\n\n<!--more-->\n\n# 下载 clash\n\n去 [github](https://github.com/Dreamacro/clash/releases) 下载最新 linux 版本，一般使用 `linux-amd64`。\n\n```shell\ngunzip clash-linux-amd64-v1.8.0.gz\nmv clash-linux-amd64-v1.8.0 ~/clash\nchmod +x ~/clash\n./clash\n```\n\n一套执行完后会生成默认配置文件 `~/.config/clash`\n\n```shell\nl ~/.config/clash\n-rw-r--r-- 1 root root 190K 11月 24 16:38 config.yaml\n-rw-r--r-- 1 root root 5.7M 11月 24 16:02 Country.mmdb\n```\n\n# 配置\n\n我是用的是 [V2Club](https://join.v2fly.club/#/register?code=C5EnE7vC)。\n\n## 复制订阅地址\n\n![](http://blogimg.jakeyu.top/centos-%E4%BD%BF%E7%94%A8-Clash-%E6%A2%AF%E5%AD%90/iShot2021-11-27%2023.29.16.png)\n\n这个配置我们不能直接使用，需要使用 [https://acl4ssr-sub.github.io/](https://acl4ssr-sub.github.io/) 服务生成订阅地址，然后打开订阅地址就可以看到明文配置。\n\n使用这份配置覆盖 `~/.config/clash/config.yaml`。\n\n## 启动代理\n\n然后启动 clash\n\n```shell\n./clash\n```\n\n设置终端使用 clash 代理\n\n```shell\nexport ALL_PROXY=socks5://127.0.0.1:7891\n```\n\n可以使用 `curl` 测试是否连接成功。\n\n```shell\ncurl https://www.google.com\n```\n\n# 远程管理\n\n修改配置文件\n\n```shell\nvim ~/.config/clash/config.yaml\n```\n\n```yaml\nexternal-controller: 0.0.0.0:9090\n# 一定要配置 secret，用来远程访问安全\nsecret: xxxx\n```\n\n重启 clash 服务。\n\n打开官方 [http://clash.razord.top/](http://clash.razord.top/)，在设置中填写相应的端口，secret 配置。配置完成就即可远程管理\n\n![](http://blogimg.jakeyu.top/centos-%E4%BD%BF%E7%94%A8-Clash-%E6%A2%AF%E5%AD%90/iShot2021-11-27%2023.50.06.png)","tags":["服务器"],"categories":["服务器"]},{"title":"跨域名存取localStorage","url":"/2020/09/20/跨域名存取localStorage/","content":"\n![](//blogimg.jakeyu.top/跨域名读取localStorage/de1cd54ffb.png)\n\n<!--more-->\n\n> 无论数据存储在 localStorage 还是 sessionStorage ，**它们都特定于页面的协议。**\n\n由于`localStorage`是基于当前访问源(origin)的本地存储空间，所以当我们在 `a.jakeyu.top` 中存储一段数据，并想要在 `b.jakeyu.top` 中读取数据的时候是无法取到的。\n\n最近遇到这样的需求，考虑过 cookie 方案，但是可能存储大量的数据，cookie 不可行。最终我们使用`iframe`来实现，我觉得这是一个很有趣的方法。\n\n# 思路\n\n`a.jakeyu.top` 和 `b.jakeyu.top` 通过 `iframe` 加载同一个域名的页面，并使用 [postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage) 和 `iframe` 中的页面进行通信，这样就可以实现跨域名存取 localStorage。\n\n缺点是 `postMessage`  是基于回调的，所以所有 api 都是异步的。不过我们有 `promise`，可以让使用方式优雅一些。\n\n![](//blogimg.jakeyu.top/跨域名读取localStorage/图像2020-10-5.jpeg)\n\n# 实现\n## 父级页面\n\n### 创建 iframe\n\n```ts\nfunction createIframe() {\n  const iframeInBody = document.querySelector('#iframe') as HTMLIFrameElement;\n\n  if (iframeInBody) {\n    return iframeInBody;\n  }\n\n  const iframe = document.createElement('iframe');\n  iframe.setAttribute('id', '#iframe');\n  iframe.src = 'https://jakeyu.top/localstorage';\n  iframe.style.display = 'none';\n\n  document.body.insertAdjacentElement('beforeend', iframe);\n\n  return iframe;\n}\n```\n\n### 核心 Class\n\n```typescript\nclass localStorage {\n  iframe: HTMLIFrameElement;\n\n  // iframe 是否加载完成\n  isReady: Boolean;\n\n  // 同时调用方法时，需要在 iframe 回调之后执行 reslove\n  waitMap: Map<string, Function>;\n\n  // 在 iframe ready之前调用方法，需要保存一下，ready后执行\n  beforeReady: [Function?];\n\n  constructor() {\n    this.listenMessage();\n\n    this.isReady = false;\n\n    this.beforeReady = [];\n\n    this.iframe = createIframe();\n\n    this.waitMap = new Map();\n  }\n\n  /**\n   * 设置数据\n   * @param key\n   * @param value\n   */\n  setItem(key: string, value: any) {\n    const eventType = 'set';\n    const randomKey = this.getRandomString(eventType);\n\n    return new Promise((resolve) => {\n      this.waitMap.set(randomKey, resolve);\n\n      this.postMessage({\n        eventType,\n        key,\n        value,\n        randomKey\n      });\n    });\n  }\n\n  /**\n   * 监听消息\n   */\n  listenMessage() {\n    // 接收 iframe 消息\n    window.addEventListener('message', this.receiveMessage.bind(this), false);\n  }\n\n  /**\n   * 处理接收消息\n   * @param event\n   */\n  receiveMessage(event: MessageEvent) {\n    const { data = {} } = event;\n    if (typeof data === 'string') return;\n\n    const { eventType, randomKey, value } = data;\n\n    if (eventType === 'return') {\n      const handler = this.waitMap.get(randomKey);\n\n      if (handler) {\n        handler(value);\n        this.waitMap.delete(randomKey);\n      }\n    } else if (eventType === 'ready') {\n      this.isReady = true;\n\n      while (this.beforeReady.length) {\n        const fun = this.beforeReady.shift() as Function;\n        fun();\n      }\n    }\n  }\n\n  /**\n   * 获取随机字符串\n   * @param eventKey\n   */\n  getRandomString(eventKey: string) {\n    let randomString = '';\n    let eventKeyRandom = '';\n\n    do {\n      randomString = makeRandomString(5);\n      eventKeyRandom = `${eventKey}_${randomString}`;\n    } while (this.waitMap.has(eventKeyRandom));\n\n    return eventKeyRandom;\n  }\n\n  /**\n   * 向iframe中发送消息\n   * @param params\n   */\n  postMessage(params: Record<string, string>) {\n    if (this.isReady) {\n      (this.iframe.contentWindow as Window).postMessage(params, '*');\n    } else {\n      this.beforeReady.push(() => {\n        (this.iframe.contentWindow as Window).postMessage(params, '*');\n      });\n    }\n  }\n}\n```\n\n## iframe 页面\n\niframe 页面只需要通过 postMessage 和父级页面进行通信，所以并不需要 ui。\n\n### ready\n\n页面加载完成时，需要通知父页面，并执行 before 栈中的函数。\n```js\nwindow.parent.postMessage(\n  {\n    eventType: 'ready',\n  },\n  '*'\n);\n```\n\n### 监听消息\n\n```js\nfunction receiveMessage(event) {\n  // 用来标记当前事件是 读/取 或者其他\n  const eventType = get(event, 'data.eventType', '');\n  // 数据 key\n  const key = get(event, 'data.key', '');\n  // 数据\n  const value = get(event, 'data.value', '');\n  // 当前事件标识，用于父级页面区分当前消息来自哪次调用\n  const randomKey = get(event, 'data.randomKey', '');\n\n  // 只以存数据为例\n  if(eventType === 'set') {\n    localStorage.setItem(key, value);\n\n    // 通知父级页面存储成功\n    window.parent.postMessage(\n      {\n        eventType: 'return',\n        value,\n        randomKey,\n        error,\n      },\n      '*'\n    );\n  }\n}\n\nwindow.addEventListener('message', receiveMessage, false);\n```\n\n# 使用\n\n在 `a.jekeyu.top` 中存储数据\n\n```js\nnew localStorage().setItem('name', 'jake')\n```\n\n在 `b.jekeyu.top` 中存储数据\n\n```js\nconst name = await new localStorage().getItem('name')\n```","tags":["JS"],"categories":["前端"]},{"title":"使用docker部署Hexo博客","url":"/2020/03/18/使用docker部署Hexo博客/","content":"\n经常迁移博客是件头疼的事，每次都要折腾一堆文件，所以折腾了一下，使用docker部署博客。\n\n![](//blogimg.jakeyu.top/使用docker部署Hexo博客/vertical-logo-monochromatic-1.png)\n\n<!--more-->\n\n# 介绍\n\nDocker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\n\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\n# 文件\n\n## DockerFile\n\n创建 `DockerFile`\n\n> 配置中的路径根据自己实际路径调整\n\n```dokerfile\nFROM centos:6\nENV container docker\n\n# 添加环境\nRUN yum -y update &&\\\n    yum -y install epel-release &&\\\n    yum -y install nginx &&\\\n    yum -y install vim &&\\\n    yum install passwd openssl openssh-server openssh-clients -y &&\\\n    yum install initscripts -y\n\n# 更新源，用于安装 git 2.x，修复 --work-tree 不能和 --git-dir 同名问题\nRUN yum -y install wget &&\\\n    wget http://opensource.wandisco.com/centos/6/git/x86_64/wandisco-git-release-6-1.noarch.rpm &&\\\n    rpm -ivh wandisco-git-release-6-1.noarch.rpm &&\\\n    yum -y install git\n\n# 安装zsh\nRUN yum install -y zsh &&\\\n    wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n\n# 创建目录\nRUN mkdir -p /home/blog\nWORKDIR /home\n\n# 添加 blog git钩子\nRUN git init --bare blog.git\nRUN echo -e '#!/bin/bash\\ngit --work-tree=/home/blog --git-dir=/home/blog.git checkout -f' >> blog.git/hooks/post-receive\nRUN chmod +x blog.git/hooks/post-receive\n\n# 创建日志文件\nRUN mkdir -p /home/log\nWORKDIR /home/log\nRUN touch blog.log\n\n# 配置 nginx\nWORKDIR /etc/nginx\nCOPY ./nginx ./conf.d\n# 解决执行 nginx 报错\nRUN nginx -c /etc/nginx/nginx.conf\n\n# 导入自动执行脚本\nCOPY ./start.sh /root/start.sh\nRUN chmod +x /root/start.sh\n\n# 切换工作目录\nWORKDIR /home\n\n# 启动服务\nCMD /root/start.sh\n\n# 端口，使用81 端口避免和 nginx默认端口冲突\n# 22 端口为 ssh 所用\nEXPOSE 9022:22 9081:81\n```\n\n## nginx\n\n```conf\nserver {\n    listen 81;\n    server_name i.jakeyu.top;\n    # 处理 nginx 自动 301 加斜杠以及端口问题\n    server_name_in_redirect on;\n    port_in_redirect off;\n\n    location / {\n        root /home/blog;\n        error_page   404 https://i.jakeyu.top/404.html;\n    }\n\n    access_log  /home/log/blog.log;\n}\n```\n\n## start.sh\n\n```sh\n#!/bin/sh\n\n# 启动 sshd 服务\nservice sshd start\n\n# 启动nginx\nnginx\n\n# 防止容器退出\n/bin/sh\n```\n\n# 构建\n\n在 `DockerFile` 所在目录执行\n\n```sh\ndocker build -t blog:v1 .\n```\n\n# 启动容器\n\n```sh\ndocker run -ti -d -p 9081:81 -p 9022:22 blog:v1\n```\n\n# ssh配置\n\n查看所有容器，找到想要配置的 `container id`\n\n```sh\ndocker ps -a\n```\n\n进入容器\n\n```sh\ndocker exec -ti [container id] /bin/zsh\n```\n\n把宿主机的 `~/.ssh/id_rsa.pub` 文件 copy 到容器 `~/.ssh/authorized_keys` 中\n\n重启ssh服务：\n\n```zsh\nservice sshd restart\n```\n\n# 部署博客\n## 配置\n\n修改 Hexo 博客的配置文件 `_config.yml`\n\n```\ndeploy:\n  type: git\n  repo:\n    ssh: ssh://root@ip:port/home/blog.git\n  branch: master\n```\n\n把 `ip` 和 `port` 换成和自己相对应的，比如在这里 `port` 就是 `9022`。\n\n## 部署\n\n```sh\nhexo d\n```\n\n## 访问\n\n使用 `curl` 测试\n\n```sh\ncurl 127.0.0.1:81\n```\n\n# 删除\n\n## 批量删除容器\n\n```sh\ndocker container rm $(docker container ls -a -q)\n```\n\n## 批量删除镜像\n\n```sh\ndocker image rm $(docker  image  ls   -a  -q)\n```\n\n# 参考\n\n* [Hexo博客部署到服务器](https://i.jakeyu.top/2016/12/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/)\n* [Docker学习之SSH连接docker容器](https://blog.52itstyle.vip/archives/2402/)\n* [Docker 入门教程](https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html)","tags":["JS"],"categories":["前端"]},{"title":"拖拽文件夹上传文件","url":"/2019/02/25/拖拽文件夹上传文件/","content":"\n![](//blogimg.jakeyu.top/javascript-illustration.png)\n\n<!-- more -->\n\n# 代码\n\n```js\nfunction traverseFileTree(item, path) {\n  path = path || \"\";\n  if (item.isFile) {\n    // Get file\n    item.file(function(file) {\n      console.log(\"File:\", path + file.name);\n    });\n  } else if (item.isDirectory) {\n    // Get folder contents\n    var dirReader = item.createReader();\n    readerEntries(dirReader, path, item)\n  }\n}\n\n// readEntries 每次最多返回100个，需要重复调用\n// https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryReader/readEntries\nfunctoin readerEntries (dirReader, path, item) {\n  dirReader.readEntries(entries => {\n    for (var i = 0; i < entries.length; i++) {\n      traverseFileTree(entries[i], path + item.name + '/')\n    }\n    if (entries.length) readerEntries(dirReader, path, item)\n  })\n},\n\ndropArea.addEventListener(\"drop\", function(event) {\n  event.preventDefault();\n\n  var items = event.dataTransfer.items;\n  for (var i=0; i<items.length; i++) {\n    // webkitGetAsEntry is where the magic happens\n    var item = items[i].webkitGetAsEntry();\n    if (item) {\n      traverseFileTree(item);\n    }\n  }\n}, false);\n```\n\n# 兼容性\n\n实测，最新版 Chrome, Firefox, Edge支持，IE不支持\n\n# 参考\n\n* [FileSystemDirectoryReader - MDN](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryReader/readEntries)","tags":["JS"],"categories":["前端"]},{"title":"Semver(npm 语义化版本号)","url":"/2019/01/10/Semver-npm-语义化版本号/","content":"\n![](//blogimg.jakeyu.top/semver/3649824190-5ad41542bc553_articlex.png)\n\n<!--more-->\n\n# 简介\n\n在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。\n\n在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你专案的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。\n\n因此，Github 起草了一个具有指导意义的，统一的版本号表示规则，称为 Semantic Versioning(语义化版本表示)。该规则规定了版本号如何表示，如何增加，如何进行比较，不同的版本号意味着什么。\n\n# 版本格式\n\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n\n1. 主版本号：当你做了不兼容的 API 修改，\n2. 次版本号：当你做了向下兼容的功能性新增，\n3. 修订号：当你做了向下兼容的问题修正。\n\n先行版本号及版本编译元数据可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n# 先行版本\n\n当要发布**大版本**或者**核心的Feature**时，但是又不能保证这个版本的功能 100% 正常。这个时候就需要通过发布先行版本。比较常见的先行版本包括：内测版、灰度版本了和RC版本。Semver规范中使用alpha、beta、rc(以前叫做gama)来修饰即将要发布的版本。它们的含义是：\n\n* alpha: 内部版本\n* beta: 公测版本\n* rc: 即Release candiate，正式版本的候选版本\n\n比如：1.0.0-alpha.0, 1.0.0-alpha.1, 1.0.0-beta.0, 1.0.0-rc.0, 1.0.p-rc.1 等版本。alpha, beta, rc后需要带上次数信息。\n\n# 版本发布准则\n\n列举出比较实用的一些规则：\n\n* 标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零，版本发布需要严格递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n* 某个软件版本发行后，任何修改都必须以新版本发行。\n* 1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的API时，就可以发布1.0.0版本了。\n* 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。\n\n# npm包依赖\n\n```json\n{\n  \"dependencies\": {\n    \"react\": \"^15.6.1\",\n  }\n}\n```\n\n项目对包的依赖可以使用下面的 3 种方法来表示(假设当前版本号是 16.2.0):\n\n* 兼容模块新发布的补丁版本：~16.2.0、16.2.x、16.2\n* 兼容模块新发布的小版本、补丁版本：^16.2.0、16.x、16\n* 兼容模块新发布的大版本、小版本、补丁版本：*、x\n\n## ^\n\n> 允许在不修改[major, minor, patch]中最左非零数字的更改（匹配大于X、Y、Z的更新Y、Z的版本号）\n\n在X.Y.Z结构的版本号中，X、Y、Z都是非负的整数，上面定义的意思就是说从左向右，遇到第一个非零数字是不可修改的，下一个数字可以更改，比如:\n\n* X、Y、Z都不为0，`^15.6.1`,最左的非零数字是15，所以X是不允许更新的，也就是说主版本号不会超过15，表示的就是版本号`>=15.6.1 && <16.0.0`\n* 如果X为0，那么第一个非零数字就是Y，就只能对z做出修改，`^0.1.2`表示版本号`>=0.1.2 && < 0.2.0`\n* 如果X、Y的数字都是0的话，第一个非零数字就是Z，表示的就是版本号不允许更新；`^0.0.2`，主版本号和次版本号都是0，修订号为非零，表示的就是版本号`>=0.0.2 && < 0.0.3`\n\n## ~\n\n> 匹配大于`X.Y.Z`的更新`Z`的版本号\n\n* X、Y、Z都不为0，`~1.2.3`表示版本号`>=1.2.3 && < 1.3.0`\n* X为0，`~0.2.3`表示版本号`>=0.2.3 && < 0.3.0`，这种情况下，~等价于^\n* X、Y为0，`0.0.3`表示版本号`>=0.0.3 && < 0.1.0`\n\n## x\n\n> 可以替代X、Y、Z中任意一个，表示该位置可更新\n\n* **1.2.x**: `>=1.2.0 && < 1.3.0`\n* **1.x**: `>=1.0.0 && < 2.0.0`\n* **\\***: 任意版本都可以\n\n上面的`x`可以用`*`代替，其实，用`x`或`*`的地方可以省略不写，比如`1.2.x`和`1.2`表示的意思是一样的\n\n# npm包发布\n\n通常我们发布一个包到npm仓库时，我们的做法是先修改 `package.json` 为某个版本，然后执行 `npm publish` 命令。手动修改版本号的做法建立在你对Semver规范特别熟悉的基础之上，否则可能会造成版本混乱。npm 考虑到了这点，它提供了相关的命令来让我们更好的遵从Semver规范：\n\n* 升级补丁版本号：npm version patch\n* 升级小版本号：npm version minor\n* 升级大版本号：npm version major\n\n当执行 `npm publish` 时，会首先将当前版本发布到 `npm registry`，然后更新 `dist-tags.latest` 的值为新版本。\n当执行 `npm publish --tag=next` 时，会首先将当前版本发布到 `npm registry`，并且更新 `dist-tags.next` 的值为新版本。这里的 next 可以是任意有意义的命名（比如：v1.x、v2.x 等等）\n\n# 参考\n\n* [https://semver.org/lang/zh-CN/](https://semver.org/lang/zh-CN/)\n* [Semver(语义化版本号)扫盲 - 腾讯IVWEB团队](https://juejin.im/post/5ad413ba6fb9a028b5485866)\n* [语义化版本控制模块-Semver](https://juejin.im/post/5a1ad2166fb9a044fd117874)","tags":["JS"],"categories":["前端"]},{"title":"antd upload组件不能显示参数图片缩略图","url":"/2018/12/13/antd-upload组件不能显示参数图片缩略图/","content":"\n在使用[ant-design-vue](https://vuecomponent.github.io/ant-design-vue/docs/vue/introduce-cn/)的upload组件时，无法显示加密图片，经过测试，凡是带参数的图片地址都无法显示缩略图。\n\n<!--more-->\n\n# base64\n\n这个组件是基于[ant-design](https://github.com/ant-design/ant-design)改写的，在issues中发现了解决办法 [#10102](https://github.com/ant-design/ant-design/issues/10102#issuecomment-382748024)\n\n```js\n/**\n *  将图片转换成base64\n * @param {String} url 图片地址\n */\nexport const base64Url = function (url) {\n  let xhr = new XMLHttpRequest()\n  xhr.onload = function () {\n    let reader = new FileReader()\n    reader.onloadend = function () {\n      self.postMessage(reader.result) //web worker 通信\n    }\n    reader.readAsDataURL(xhr.response)\n  }\n  xhr.open('GET', url)\n  xhr.responseType = 'blob'\n  xhr.send()\n}\n```\n\n通过`ajax`获取图片，并将图片转为`base64`。\n\n# Web Worker\n\n但是由于我开发的业务页面中有大量图片，如果每个图片都这样操作，页面会有些卡顿。所以需要进行优化。\n\n我选择使用`Web Worker`，关于`Web Worker`可以查看阮一峰老师的文章： \n\n* [Web Worker 使用教程](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)\n\n创建一个生成`Web Worker`的函数：\n\n```js\n/**\n * 创建web worker\n * @param {Function} f 要在worker中执行的函数\n * @param {Strint} args 函数参数\n */\nexport const createWorker = (f, args) => {\n  var blob = new Blob(['(' + f.toString() + ')(\"' + args + '\")'])\n  var url = window.URL.createObjectURL(blob)\n  var worker = new Worker(url)\n  return worker\n}\n```\n\n调用\n\n```js\nlet myWorker = createWorker(base64Url, url)\n// 监听message事件\nmyWorker.onmessage = (data) => {\n  console.log(data.data)  //打印转换后的base64\n  myWorker.terminate()  //销毁 web worker\n}\n```","tags":["JS"],"categories":["前端"]},{"title":"Object 方法","url":"/2018/12/10/Object-preventExtensions-Object-seal-Object-freeze/","content":"\n| 方法                       | 描述                                                                                                                                                                           | 详情                                                                                                             |\n| :------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |\n| Object.preventExtensions() | 让一个对象变的不可扩展，也就是永远不能再添加新的属性。                                                                                                                         | [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions) |\n| Object.isExtensible()      | 判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。                                                                                                                   | [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)      |\n| Object.seal()              | 封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。                                                                                   | [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)              |\n| Object.isSealed()          | 判断一个对象是否被密封。                                                                                                                                                       | [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed)          |\n| Object.freeze()            | 冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。 | [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)            |\n| Object.isFrozen()          | 判断一个对象是否被冻结。                                                                                                                                                       | [MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen)          |\n","tags":["JS"],"categories":["前端"]},{"title":"flex的各种值","url":"/2018/12/08/flex的各种值/","content":"\n![](//blogimg.jakeyu.top/flex的各种值/bg2015071002.png)\n\n<!--more-->\n\n# 介绍\n\n> 2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。\n\n关于详细`flex`使用，可以查看[阮一峰](http://www.ruanyifeng.com)的两篇文章:\n\n* [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)\n* [Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)\n\n# 正文\n\n首先明确一点是， `flex` 是 `flex-grow`、`flex-shrink`、`flex-basis`的缩写。故其取值可以考虑以下情况：\n\n`flex` 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 `flex` 的默认值是 `0 1 auto`。同理，如下是等同的：\n\n```css\n.item {flex: 2333 3222 234px;}\n.item {\n    flex-grow: 2333;\n    flex-shrink: 3222;\n    flex-basis: 234px;\n}\n```\n\n当 `flex` 取值为 `none`，则计算值为 `0 0 auto`，如下是等同的：\n\n```css\n.item {flex: none;}\n.item {\n    flex-grow: 0;\n    flex-shrink: 0;\n    flex-basis: auto;\n}\n```\n\n当 `flex` 取值为 `auto`，则计算值为 `1 1 auto`，如下是等同的：\n\n```css\n.item {flex: auto;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: auto;\n}\n```\n\n当 `flex` 取值为一个非负数字，则该数字为 `flex-grow` 值，`flex-shrink` 取 1，`flex-basis` 取 0%，如下是等同的：\n\n```css\n.item {flex: 1;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n```\n\n当 `flex` 取值为一个长度或百分比，则视为 `flex-basis` 值，`flex-grow` 取 1，`flex-shrink` 取 1，有如下等同情况（注意 `0%` 是一个百分比而不是一个非负数字）：\n\n```css\n.item-1 {flex: 0%;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n.item-2 {flex: 24px;}\n.item-2 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 24px;\n}\n```\n\n当 `flex` 取值为两个非负数字，则分别视为 `flex-grow` 和 `flex-shrink` 的值，`flex-basis` 取 0%，如下是等同的：\n\n```css\n.item {flex: 2 3;}\n.item {\n    flex-grow: 2;\n    flex-shrink: 3;\n    flex-basis: 0%;\n}\n```\n\n当 `flex` 取值为一个非负数字和一个长度或百分比，则分别视为 `flex-grow` 和 `flex-basis` 的值，`flex-shrink` 取 1，如下是等同的：\n\n```css\n.item {flex: 2333 3222px;}\n.item {\n    flex-grow: 2333;\n    flex-shrink: 1;\n    flex-basis: 3222px;\n}\n```\n\n`flex-basis` 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。`flex-basis` 规定的范围取决于 `box-sizing`。这里主要讨论以下 `flex-basis` 的取值情况：\n\n* **auto**：首先检索该子元素的主尺寸，如果主尺寸不为 `auto`，则使用值采取主尺寸之值；如果也是 `auto`，则使用值为 `content`。\n* **content**：指根据该子元素的内容自动布局。有的用户代理没有实现取 `content` 值，等效的替代方案是 `flex-basis` 和主尺寸都取 `auto`。\n* **百分比**：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 `auto` 一样。\n\n举一个不同的值之间的区别：\n\n```html\n<div class=\"parent\">\n    <div class=\"item-1\"></div>\n    <div class=\"item-2\"></div>\n    <div class=\"item-3\"></div>\n</div>\n```\n\n```css\n.parent {\n    display: flex;\n    width: 600px;\n}\n.parent > div {\n    height: 100px;\n}\n.item-1 {\n    width: 140px;\n    flex: 2 1 0%;\n    background: blue;\n}\n.item-2 {\n    width: 100px;\n    flex: 2 1 auto;\n    background: darkblue;\n}\n.item-3 {\n    flex: 1 1 200px;\n    background: lightblue;\n}\n```\n\n<iframe height='265' scrolling='no' title='flex 不同的值' src='//codepen.io/JakeLaoyu/embed/OrLrZP/?height=265&theme-id=light&default-tab=css,result' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/JakeLaoyu/pen/OrLrZP/'>flex 不同的值</a> by Jake (<a href='https://codepen.io/JakeLaoyu'>@JakeLaoyu</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n\n* 主轴上父容器总尺寸为 600px\n* 子元素的总基准值是：0% + auto + 200px = 300px，其中\n  - 0% 即 0 宽度\n  - auto 对应取主尺寸即 100px\n* 故剩余空间为 600px - 300px = 300px\n* 伸缩放大系数之和为： 2 + 2 + 1 = 5\n* 剩余空间分配如下：\n  - item-1 和 item-2 各分配 2/5，各得 120px\n  - item-3 分配 1/5，得 60px\n* 各项目最终宽度为：\n  - item-1 = 0% + 120px = 120px\n  - item-2 = auto + 120px = 220px\n  - item-3 = 200px + 60px = 260px\n* 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设\n* 而 item-2 基准值取 `auto` 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间\n\n# 参考\n\n* [https://segmentfault.com/q/1010000004080910/a-1020000004121373](https://segmentfault.com/q/1010000004080910/a-1020000004121373)\n","tags":["JS"],"categories":["前端"]},{"title":"层叠顺序（stacking level）与堆栈上下文（stacking context）","url":"/2018/12/01/层叠顺序（stacking-level）与堆栈上下文（stacking-context）/","content":"\n`z-index` 看上去其实很简单，根据 `z-index` 的高低决定层叠的优先级，实则深入进去，会发现内有乾坤。\n\n<!--more-->\n\n# 正文\n\n看看下面这题，定义两个 `div` A 和 B，被包括在同一个父 `div` 标签下。HTML结构如下：\n\n```html\n<div class=\"container\">\n    <div class=\"inline-block\">#divA display:inline-block</div>\n    <div class=\"float\"> #divB float:left</div>\n</div>\n```\n\n```css\n.container{\n    position:relative;\n    background:#ddd;\n}\n.container > div{\n    width:200px;\n    height:200px;\n}\n.float{\n    float:left;\n    background-color:deeppink;\n}\n.inline-block{\n    display:inline-block;\n    background-color:yellowgreen;\n    margin-left:-100px;\n}\n```\n\n大概描述起来，意思就是拥有共同父容器的两个 `DIV` 重叠在一起，是 `display:inline-block` 叠在上面，还是 `float:left` 叠在上面？\n\n注意这里 DOM 的顺序，是先生成 display:inline-block ，再生成 float:left 。当然也可以把两个的 DOM 顺序调转如下：\n\n```HTML\n<div class=\"container\">\n    <div class=\"float\"> #divB float:left</div>\n    <div class=\"inline-block\">#divA display:inline-block</div>\n</div>\n```\n\n会发现，无论顺序如何，始终是 display:inline-block 的 div 叠在上方。\n\n[DEMO戳我](https://codepen.io/Chokcoco/pen/gwLYNy)\n\n这里其实是涉及了所谓的层叠水平（stacking level)，有一张图可以很好的诠释：\n\n![](//blogimg.jakeyu.top/层叠顺序（stacking-level）与堆栈上下文（stacking-context）/687474703a2f2f696d616765732e636e626c6f67732e636f6d2f636e626c6f67735f636f6d2f636f636f31732f3838313631342f6f5f737461636b696e676c6576656c2e706e67.png)\n\n运用上图的逻辑，上面的题目就迎刃而解，`inline-blcok` 的 `stacking level` 比之 `float` 要高，所以无论 DOM 的先后顺序都堆叠在上面。\n\n不过上面图示的说法有一些不准确，按照 [W3官方](https://www.w3.org/TR/CSS2/visuren.html#propdef-z-index) 的说法，准确的 7 层为：\n\n1. the background and borders of the element forming the stacking context.\n2. the child stacking contexts with negative stack levels (most negative first).\n3. the in-flow, non-inline-level, non-positioned descendants.\n4. the non-positioned floats.\n5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.\n6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.\n7. the child stacking contexts with positive stack levels (least positive first).\n\n稍微翻译一下：\n\n1. 形成堆叠上下文环境的元素的背景与边框\n2. 拥有负 `z-index` 的子堆叠上下文元素 （负的越高越堆叠层级越低）\n3. 正常流式布局，非 `inline-block`，无 `position` 定位（static除外）的子元素\n4. 无 `position` 定位（static除外）的 float 浮动元素\n5. 正常流式布局， `inline-block`元素，无 `position` 定位（static除外）的子元素（包括 display:table 和 display:inline ）\n6. 拥有 `z-index:0` 的子堆叠上下文元素\n7. 拥有正 `z-index:` 的子堆叠上下文元素（正的越低越堆叠层级越低）\n\n所以我们的两个 `div` 的比较是基于上面所列出来的 4 和 5 。5 的 `stacking level` 更高，所以叠得更高。\n\n不过！不过！不过！重点来了，请注意，上面的比较是基于两个 div 都没有形成 堆叠上下文 这个为基础的。下面我们修改一下题目，给两个 `div` ，增加一个 `opacity`:\n\n```css\n.container{\n    position:relative;\n    background:#ddd;\n}\n.container > div{\n    width:200px;\n    height:200px;\n    opacity:0.9; // 注意这里，增加一个 opacity\n}\n.float{\n    float:left;\n    background-color:deeppink;\n}\n.inline-block{\n    display:inline-block;\n    background-color:yellowgreen;\n    margin-left:-100px;\n}\n```\n\n[DEMO戳我](http://codepen.io/Chokcoco/pen/qaqdqA)\n\n会看到，`inline-block` 的 `div` 不再一定叠在 `float` 的 `div` 之上，而是和 `HTML` 代码中 `DOM` 的堆放顺序有关，后添加的 `div` 会 叠在先添加的 `div` 之上。\n\n这里的关键点在于，添加的 `opacity:0.9` 这个让两个 `div` 都生成了 `stacking context（堆叠上下文）` 的概念。此时，要对两者进行层叠排列，就需要 `z-index` ，`z-index` 越高的层叠层级越高。\n\n\n堆叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的 `z` 轴上延伸，`HTML` 元素依据其自身属性按照优先级顺序占用层叠上下文的空间。\n\n那么，如何触发一个元素形成 `堆叠上下文` ？方法如下，摘自 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)：\n\n* 根元素 (HTML),\n* z-index 值不为 \"auto\"的 绝对/相对定位，\n* 一个 z-index 值不为 \"auto\"的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，\n* opacity 属性值小于 1 的元素（参考 the specification for opacity），\n* transform 属性值不为 \"none\"的元素，\n* mix-blend-mode 属性值不为 \"normal\"的元素，\n* filter值不为“none”的元素，\n* perspective值不为“none”的元素，\n* isolation 属性被设置为 \"isolate\"的元素，\n* position: fixed\n* 在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值\n* -webkit-overflow-scrolling 属性被设置 \"touch\"的元素\n\n所以，上面我们给两个 `div` 添加 `opacity` 属性的目的就是为了形成 `stacking context`。也就是说添加 `opacity` 替换成上面列出来这些属性都是可以达到同样的效果。\n\n在层叠上下文中，其子元素同样也按照上面解释的规则进行层叠。 特别值得一提的是，其子元素的 `z-index` 值只在父级层叠上下文中有意义。意思就是父元素的 `z-index` 低于父元素另一个同级元素，子元素 `z-index` 再高也没用。\n\n理解上面的 `stacking-level` 与 `stacking-context` 是理解 `CSS` 的层叠顺序的关键。\n\n# 参见\n\n* [谈谈一些有趣的CSS题目（1~5） · Issue #1 · chokcoco/iCSS](https://github.com/chokcoco/iCSS/issues/1)\n","tags":["CSS"],"categories":["前端"]},{"title":"getComputedStyle","url":"/2018/11/29/getComputedStyle/","content":"\n引用[MND](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle)的说明：\n\n> Window.getComputedStyle()方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。 私有的CSS属性值可以通过对象提供的API或通过简单地使用CSS属性名称进行索引来访问。\n\n<!--more-->\n\n# 语法\n\n```js\nlet style = window.getComputedStyle(element, [pseudoElt]);\n```\n\n* **element**: 用语获取计算样式的Element\n* **pseudoElt**: 指定一个要匹配的伪元素的字符串。必须对普通元素省略（或null）。\n\n例如:\n\n```js\nvar dom = document.getElementById(\"test\")\nvar style = window.getComputedStyle(dom , \":after\")\nvar style = window.getComputedStyle(dom , \":after\").content\n```\n\n# getComputedStyle与style的区别\n\n我们使用`element.style`也可以获取元素的CSS样式声明对象，但是其与`getComputedStyle`方法还有有一些差异的。\n\n1. 只读与可写\n  * 正如上面提到的`getComputedStyle`方法是只读的，只能获取样式，不能设置；而`element.style`能读能写，能屈能伸。\n2. 获取的对象范围\n  * `getComputedStyle`方法获取的是最终应用在元素上的所有CSS属性对象（即使没有CSS代码，也会把默认的祖宗八代都显示出来）；而`element.style`只能获取元素`style`属性中的CSS样式。因此对于一个光秃秃的元素`<p>`，`getComputedStyle`方法返回对象中`length`属性值（如果有）就是190+(据我测试FF:192, IE9:195, Chrome:253, 不同环境结果可能有差异), 而`element.style`就是`0`。\n\n# getComputedStyle与defaultView\n\n许多在线的演示代码中，`getComputedStyle`是通过 `document.defaultView` 对象来调用的。大部分情况下，这是不需要的，因为可以直接通过`window`对象调用。但有一种情况，你必需要使用 `defaultView`,  那是在firefox3.6上访问子框架内的样式 。\n\n# getPropertyValue\n\n`getPropertyValue`方法可以获取CSS样式申明对象上的属性值（直接属性名称），例如：\n\n```js\nwindow.getComputedStyle(element, null).getPropertyValue(\"float\");\n```\n\n如果我们不使用`getPropertyValue`方法，直接使用键值访问，其实也是可以的。但是，比如这里的的`float`，如果使用键值访问，则不能直接使用`getComputedStyle(element, null).float`，而应该是`cssFloat`与`styleFloat`，自然需要浏览器判断了，比较折腾！\n\n使用`getPropertyValue`方法不必可以驼峰书写形式（不支持驼峰写法），例如：`style.getPropertyValue(\"border-top-left-radius\")`\n\n# 获取变量\n\n例子：\n\n```css\n:root{\n  --testMargin:75px;\n}\n```\n\n```js\n//  读取\nvar root = getComputedStyle(document.documentElement);\nvar cssVariable = root.getPropertyValue('--testMargin').trim();\n\nconsole.log(cssVariable); // '75px'\n\n// 写入\ndocument.documentElement.style.setProperty('--testMargin', '100px');\n```\n\n# CSSStyleDeclaration\n\n## 概要\n\n`CSSStyleDeclaration` 表示一个CSS属性键值对的集合。它被用于一些API中：\n\n* `HTMLElement.style` - 用于操作单个元素的样式(<elem style=\"...\">)；\n* (TODO: reword) 作为 [declaration block](https://www.w3.org/TR/1998/REC-CSS2-19980512/syndata.html#block) 的接口，当规则为 [CSSStyleRule](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSRule) 时，由stylesheet中的 style  属性返回 。\n* `CSSStyleDeclaration`也是由`window.getComputedStyle()`返回的只读接口.\n\n## 方法\n\n* `CSSStyleDeclaration.getPropertyPriority()`: 返回可选的优先级，”Important\", 例如：\n```js\npriString= styleObj.getPropertyPriority('color')\n```\n* `CSSStyleDeclaration.getPropertyValue()`: 返回属性值。例如:\n```js\nvalString= styleObj.getPropertyValue('color')\n```\n* `CSSStyleDeclaration.item()`: 返回属性名。 例如:\n```js\nnameString= styleObj.item(0) Alternative: nameString= styleObj[0]\n```\n* `CSSStyleDeclaration.removeProperty()`: 返回被删除的属性。例如:\n```js\nvalString= styleObj.removeProperty('color')\n```\n* `CSSStyleDeclaration.setProperty()`: 没有返回值。例如:\n```js\nstyleObj.setProperty('color', 'red', 'important')\n```\n* `CSSStyleDeclaration.getPropertyCSSValue()`: 仅支持通过getComputedStyle的方式。 在Firefox (CSSPrimitiveValue中返回  ROCSSPrimitiveValue, 在其他实现 CSSValue，或为null 速记属性。\n\n# 兼容性\n\n[CANIUSE](https://caniuse.com/#search=getComputedStyle)\n\n# 参考\n\n* [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle)\n* [获取元素CSS值之getComputedStyle方法熟悉--张鑫旭](https://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/)\n* [CSSStyleDeclaration--MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration)\n","tags":["CSS"],"categories":["前端"]},{"title":"格式化上下文","url":"/2018/11/28/格式化上下文/","content":"\nBFC 是 `W3C CSS 2.1` 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。\n\n<!--more-->\n\n# BFC\n\nBFC 也叫**块格式化上下文**\n\n## BFC是什么\n\n在解释 BFC 是什么之前，需要先介绍 `Box`、`Formatting Context` 的概念。\n\n### Box: CSS布局的基本单位\n\nBox 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 `Box` 组成的。元素的类型和 `display` 属性，决定了这个 `Box` 的类型。 不同类型的 `Box`， 会参与不同的 `Formatting Context`（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：\n\n* **block-level** box:display 属性为 `block`, `list-item`, `table` 的元素，会生成 `block-level box`。并且参与 `block fomatting context`；\n* **inline-level** box:display 属性为 `inline`, `inline-block`, `inline-table` 的元素，会生成 `inline-level box`。并且参与 `inline formatting context`；\n* **run-in** box: CSS3 中才有， 这儿先不讲了。\n\n### Formatting context\n\n**Formatting context** 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 **Formatting context** 有 `Block fomatting context` (简称BFC)和` Inline formatting context` (简称IFC)。\n\nCSS2.1 中只有 `BFC` 和 `IFC`, CSS3 中还增加了 `GFC` 和 `FFC`。\n\n### BFC 定义\n\n**BFC(Block formatting context)** 直译为\"块级格式化上下文\"。它是一个独立的渲染区域，只有 **Block-level Box** 参与， 它规定了内部的 **Block-level Box** 如何布局，并且与这个区域外部毫不相干。\n\n### BFC布局规则：\n\n* 内部的 **Box** 会在垂直方向，一个接一个地放置。\n* Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n* 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n* BFC 的区域不会与 float box 重叠。\n* BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n* 计算 BFC 的高度时，浮动元素也参与计算\n\n## 哪些元素会生成BFC?\n\n* 根元素\n* `float` 属性不为 `none`\n* `position` 为 `absolute` 或 `fixed`\n* `display` 为 `inline-block`, `table-cell`, `table-caption`, `flex`, `inline-flex`\n* `overflow` 不为 `visible`\n\n## BFC的作用及原理\n\n### 自适应两栏布局\n\n```css\nbody {\n    width: 300px;\n    position: relative;\n}\n\n.aside {\n    width: 100px;\n    height: 150px;\n    float: left;\n    background: #f66;\n}\n\n.main {\n    height: 200px;\n    background: #fcc;\n}\n```\n\n```html\n<body>\n  <div class=\"aside\"></div>\n  <div class=\"main\"></div>\n</body>\n```\n\n页面：\n\n![](//blogimg.jakeyu.top/BFC/4dca44a927d4c1ffc30e3ae5f53a0b79.png)\n\n根据BFC布局规则第3条：\n\n> 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。\n\n因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。\n\n根据BFC布局规则第四条：\n\n> BFC 的区域不会与 float box 重叠。\n\n我们可以通过通过触发 main 生成 BFC， 来实现自适应两栏布局。\n\n```css\n.main {\n  overflow: hidden;\n}\n```\n\n当触发 main 生成 BFC 后，这个新的 BFC 不会与浮动的 aside 重叠。因此会根据包含块的宽度，和 aside 的宽度，自动变窄。效果如下：\n\n![](//blogimg.jakeyu.top/BFC/t01077886a9706cb26b.png)\n\n### 清除内部浮动\n\n```css\n.par {\n    border: 5px solid #fcc;\n    width: 300px;\n}\n\n.child {\n    border: 5px solid #f66;\n    width:100px;\n    height: 100px;\n    float: left;\n}\n```\n\n```html\n<body>\n    <div class=\"par\">\n        <div class=\"child\"></div>\n        <div class=\"child\"></div>\n    </div>\n</body>\n```\n\n页面：\n\n![](//blogimg.jakeyu.top/BFC/t016035b58195e7909a.png)\n\n根据 BFC 布局规则第六条：\n\n> 计算 BFC 的高度时，浮动元素也参与计算\n\n为达到清除内部浮动，我们可以触发 par 生成 BFC，那么 par 在计算高度时，par 内部的浮动元素 child 也会参与计算。\n\n代码：\n\n```css\n.par {\n    overflow: hidden;\n}\n```\n\n效果如下:\n\n![](//blogimg.jakeyu.top/BFC/t016bbbe5236ef1ffd5.png)\n\n### 防止垂直 margin 重叠\n\n```css\np {\n    color: #f55;\n    background: #fcc;\n    width: 200px;\n    line-height: 100px;\n    text-align:center;\n    margin: 100px;\n}\n```\n\n```html\n<body>\n    <p>Haha</p>\n    <p>Hehe</p>\n</body>\n```\n\n页面：\n\n![](//blogimg.jakeyu.top/BFC/t01b47b8b7d153c07cc.png)\n\n两个p之间的距离为100px，发送了margin重叠。\n根据BFC布局规则第二条：\n\n> Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n\n我们可以在 p 外面包裹一层容器，并触发该容器生成一个 BFC。那么两个 P 便不属于同一个 BFC，就不会发生 margin 重叠了。\n代码：\n\n```css\n.wrap {\n    overflow: hidden;\n}\np {\n    color: #f55;\n    background: #fcc;\n    width: 200px;\n    line-height: 100px;\n    text-align:center;\n    margin: 100px;\n}\n```\n\n```html\n<body>\n    <p>Haha</p>\n    <div class=\"wrap\">\n        <p>Hehe</p>\n    </div>\n</body>\n```\n\n效果如下：\n\n![](//blogimg.jakeyu.top/BFC/t0118d1d2badbb00521.png)\n\n## 总结\n\n其实以上的几个例子都体现了BFC布局规则第五条：\n\n> BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。\n\n因为 BFC 内部的元素和外部的元素绝对不会互相影响，因此， 当 BFC 外部存在浮动时，它不应该影响 BFC 内部 Box 的布局，BFC 会通过变窄，而不与浮动有重叠。同样的，当 BFC 内部有浮动时，为了不影响外部元素的布局，BFC 计算高度时会包括浮动的高度。避免 margin 重叠也是这样的一个道理。\n\n# IFC\n\nIFC(Inline Formatting Contexts)即 **内联排版上下文**，也可称为 **内联格式化上下文**。用来规定内联级盒子的格式化规则。\n\n## 布局规则\n\n1. 内部的`Box`会在水平方向，一个接一个地放置。\n2. 这些`Box`垂直方向的起点从包含块盒子的顶部开始。\n3. 摆放这些`Box`的时候，它们在水平方向上的外边距、边框、内边距所占用的空间都会被考虑在内。\n4. 在垂直方向上，这些框可能会以不同形式来对齐（`vertical-align`）：它们可能会使用底部或顶部对齐，也可能通过其内部的文本基线（`baseline`）对齐。\n5. 能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（`line box`）。行框的宽度是由包含块（`containing box`）和存在的浮动来决定。\n6. IFC中的`line box`一般左右边都贴紧其包含块，但是会因为`float`元素的存在发生变化。`float`元素会位于IFC与`line box`之间，使得`line box`宽度缩短。\n7. IFC中的`line box`高度由CSS行高计算规则来确定，同个IFC下的多个`line box`高度可能会不同（比如一行包含了较高的图片，而另一行只有文本）。\n8. 当`inline-level box`的总宽度少于包含它们的`line box`时，其水平渲染规则由`text-align`属性来确定，如果取值为`justify`，那么浏览器会对`inline-box`（注意不是inline-table 和 inline-block box）中的文字和空格做 出拉伸。\n9. 当一个`inline box`超过`line box`的宽度时，它会被分割成多个box，这些box被分布在多个`line box`里。如果一个`inline box`不能被分割（比如只包含单个字符，或`word-breaking`机制被禁用，或该行内框受`white-space`属性值 为`nowrap`或`pre`的影响），那么这个`inline box`将溢出这个`line box`。\n\n> 上面的术语可能会看得有点迷糊，一会儿inline box，一会儿line box。line box是 **行框**，inline box是 **行内框**（或称为 **内联框**），我们可简单按字面意思来理解：行内框是包含在行框内（或多个行框内，当出现换行时）的。\n\n## 行框和行内框\n\n### 行框\n\n![](//blogimg.jakeyu.top/BFC/o_text_021.gif)\n\n行框（line box），同行内框类似的概念，行框是指本行的一个虚拟的矩形框，也是浏览器渲染模式中的一个概念。行框高度等于本行内所有元素中行内框最大的值（以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度）。\n\n### 行内框\n\n![](//blogimg.jakeyu.top/BFC/o_text_020.gif)\n\n行内框是一个浏览器渲染模型中的一个概念，无法显示出来，但是它又确实存在，它的高度就是行高指定的高度。\n\n## 何时会生成IFC\n\n和BFC可以被元素属性触发而被创建（triggered）不同，IFC只有在一个块元素中仅包含内联级别元素时才会生成。\n\n下面我们通过一个实例来看看行内框的构造：\n\n```html\n<p>Several <em>emphasized words</em> appear <strong>in this</strong> sentence, dear.</p>\n```\n\n```css\np {\n    color: whitesmoke;\n    background: orange;\n    width: 200px;\n    line-height: 40px;\n    text-align: center;\n    margin: 30px;\n    font-size: 18px;\n}\nem {\n    padding: 2px;\n    margin: 12px;\n    border-width: medium;\n    border-style: dashed;\n    line-height: 24px;\n}\n```\n\n效果：\n\n![](//blogimg.jakeyu.top/BFC/Jietu20181128-225810.png)\n\np 元素产生一个块框，它包含了五个行内框，其中的三个是匿名的：\n\n* 匿名：”Several”\n* EM: “emphasized words”\n* 匿名：”appear”\n* STRONG: “in this”\n* 匿名：”sentence, dear.”\n\n为了格式化这个段落，用户代理将这五个框排入行框内。本例中，为 p 元素生成的框生成了行内框的包含块。如果该包含块足够宽，则所有的行内框将放在一个行框内。\n\n否则inline box将产生分割，来放置在多个行框内。如上例中所示，这个段落被分布在3个行框中。您可以在上例中修改p元素的width来查看不同的格式化效果。\n\n上例中，em元素被分割成2块（我们把它们称为“split1”和“split2”），margin、padding、border和text-decoration属性将不在分割处产生视觉效果，也就是在split1之后和split2之前无效。\n\n回过来看上面的例子中这些属性的影响：\n\n* margin 会被插入到 \"emphasized\" 之前和 \"words\" 之后。\n* padding 会被插入到 \"emphasized\" 的前面和上下，以及 \"words\" 的后面和上下。\n* border 将绘制在 \"emphasized\" 的前面和上下，以及 \"words\" 的后面和上下。\n\n## IFC有什么用途\n\n```html\n<div class=\"wrap\">\n  <p>使用IFC布局，display:inline-block、text-align:center和vertical-align:middle方法来实现文本垂直居中 inline-block元素以单个封闭块来参与外部的IFC，其内部会生成一个BFC，不在本例讨论范围之内。</p>\n</div>\n```\n\n```css\nbody {\n    margin: 0;\n}\n.wrap {\n    text-align: center;\n    line-height: 300px;\n    width: 100%;\n    height: 300px;\n    background-color: #ccc;\n    font-size: 0;\n}\np {\n    line-height: normal;\n    display: inline-block;\n    vertical-align: middle;\n    background-color: #333;\n    font-size: 18px;\n    padding: 10px;\n    width: 360px;\n    color: #fff;\n}\n```\n\n效果：\n\n![](//blogimg.jakeyu.top/BFC/Jietu20181128-230214.png)\n\n* 我们使用一个块元素来包含一个内联元素，这样会生成一个IFC来规定如何渲染行内元素。按照IFC行内框的布局规则，其水平位置将由text-align属性来确定，所以设置text-align:center将把行内框居中。\n* 外部块元素的行高为内部行框设定了最小高度，好比在渲染时以一个隐藏的0宽度字符开始，具备该块元素所设置的行高（本例中为300px）和字体属性，我们称之为是一个支架（strut），作用是把外部块元素撑起来。参考阅读W3规范：[Strut](https://www.w3.org/TR/CSS2/visudet.html#strut)。\n* 然后我们设置内联（或内联块）元素的垂直对齐属性为中间，它将参照前述的隐藏支架的baseline来对齐。如果我们把块元素的字体设置为0，实际效果就是内联元素被垂直居中放置在块元素中。\n\n\n## 行高计算\n\n用户代理（user agent）将行内级框排入垂直堆叠的行框内。行框的高度由下面步骤决定：\n\n1. 计算行框里的各行内级框的高度。对于置换元素、行内块元素、行内表格元素来说，这是边界框的高度，对于行内框来说，这是其‘line-height’。\n2. 行内级元素根据其`vertical-align`属性垂直对齐。如果这些框使用`top`或`bottom`对齐，用户代理必须以最小化行框的高为目标对齐这些框。这可能存在多种对齐方案，CSS 2.1并不定义行框基线的位置（也就是前述strut的位置）。\n3. 行框的高是最顶端框的顶边到最底端框的底边的距离。\n\n> 空的行内元素产生空的行内框，但是这些框仍然拥有margins, padding, borders 和一个line height, 所以在上述行高计算中和有内容的行内元素一样。\n\n### 行距（Leading）和半行距（half-leading）\n\nCSS 假设所有字体的度量都有基线以上的height和基线以下的depth，我们使用A（ascender）来表示这个height（字母高出基线部分），而用D（descender）来表示depth（字母低出基线部分）。\n\n同时我们定义 AD = A + D，也就是整个字母的高度。\n\nUser agent 必须在一个非替换行内框中按照字符（glyphs）的基线对它们进行对齐。也就是确定A 和 D。 某元素中的字符可能存在多个字体，A 和 D则不尽相同。如果这个行内框不包含任何字符，它被认为包含一个strut（一个0宽度的隐藏字符），这个隐藏字符的A 和 D遵循该元素的第一个有效字体。\n\n除了前面所介绍的BFC和IFC之外，CSS3还引入了新的布局方式及其所生成的格式化上下文，包括grid layout所对应的GFC（grid formatting context）和flex layout所对应的FFC（flex formatting context）。\n\n# 参考\n\n* [前端精选文摘：BFC 神奇背后的原理](http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html)\n* [CSS 内联排版上下文（Inline Formatting Context）](http://techbrood.com/h5b2a?p=css-ifc)\n* [css中的baseline](https://blog.csdn.net/zp1996323/article/details/51457836)\n* [深入理解 CSS 中的行高与基线](https://blog.csdn.net/q121516340/article/details/51483439)\n* [img的间隙](https://segmentfault.com/a/1190000006808606)\n* [inline-block元素vertical-align的问题分析](https://www.cnblogs.com/zxjwlh/p/6219896.html)\n* [谈谈一些有趣的CSS题目](https://github.com/chokcoco/iCSS/issues/5)\n","tags":["CSS"],"categories":["前端"]},{"title":"css响应式正方形居中","url":"/2018/11/27/css响应式正方形居中/","content":"\n`body -> div#box`，body铺满屏幕，box是一个宽度为body一半的正方形，用css使box垂直水平居中。\n\n<!-- more -->\n\n`padding`百分比继承自父元素宽度，然后通过绝对定位和`translate`来实现。\n\n```HTML\n<body>\n  <div class=\"box\"></div>\n</body>\n```\n\n```css\nbody {\n  width: 100vw;\n  height: 100vh;\n}\n.box {\n  position: absolute;\n  padding: 25%;\n  background: red;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%,-50%);\n}\n```\n","tags":["JS"],"categories":["前端"]},{"title":"经典排序算法","url":"/2018/11/26/经典排序算法/","content":"\n![](//blogimg.jakeyu.top/排序算法/sort.png)\n\n<!--more-->\n\n# 排序算法说明\n\n## 定义\n\n对一序列对象根据某个关键字进行排序。\n\n## 术语说明\n\n* **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\n* **不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n* **内排序**：所有排序操作都在内存中完成；\n* **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n* **时间复杂度**：一个算法执行所耗费的时间。\n* **空间复杂度**：运行完一个程序所需内存的大小。\n\n# 冒泡排序\n## 描述\n\n> 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n## 实现\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\n3. 针对所有的元素重复以上的步骤，除了最后一个；\n4. 重复步骤1~3，直到排序完成。\n\n```js\nfunction bubbleSort (arr) {\n  console.time('耗时：')\n\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = 0; j < arr.length - i; j++) {\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]  //交换元素\n      }\n    }\n  }\n  console.timeEnd('耗时：')\n\n  return arr\n}\n```\n\n## 优化\n> 改进冒泡排序： 设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\n\n```js\nfunction bubbleSort (arr) {\n  console.time('耗时：')\n\n  var len = arr.length\n  while (len > 0) {\n    let pos = 0\n    for (let i = 0; i < len; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]] // 交换元素\n        pos = i\n      }\n    }\n    len = pos\n  }\n  console.timeEnd('耗时：')\n\n  return arr\n}\n```\n\n## 动图\n\n![](//blogimg.jakeyu.top/排序算法/sort05.gif)\n\n## 算法分析\n\n* 最佳情况：T(n) = O(n)\n\n当输入的数据已经是正序时\n\n* 最差情况：T(n) = O(n<sup>2</sup>)\n\n当输入的数据是反序时\n\n* 平均情况：T(n) = O(n<sup>2</sup>)\n\n# 选择排序\n\n> 表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度.....所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。\n\n## 描述\n\n> 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n## 实现\n\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n1. 初始状态：无序区为R[1..n]，有序区为空；\n2. 第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n3. n-1趟结束，数组有序化了。\n\n```js\nfunction selectionSort (arr) {\n  console.time('耗时：')\n  let len = arr.length\n  let minIndex\n  for (let i = 0; i < len; i++) {\n    minIndex = i\n    for (let j = i + 1; j < len; j++) {\n      if (arr[j] < arr[minIndex]) {\n        minIndex = j\n      }\n    }\n    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]\n  }\n  console.timeEnd('耗时：')\n  return arr\n}\n```\n\n## 动图\n\n![](//blogimg.jakeyu.top/排序算法/sort06.gif)\n\n## 分析\n\n* 最佳情况：T(n) = O(n<sup>2</sup>)\n* 最差情况：T(n) = O(n<sup>2</sup>)\n* 平均情况：T(n) = O(n<sup>2</sup>)\n\n# 插入排序\n\n> 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了.....\n\n## 描述\n\n> 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n## 实现\n\n一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\n\n1. 从第一个元素开始，该元素可以认为已经被排序；\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n5. 将新元素插入到该位置后；\n6. 重复步骤2~5。\n\n```js\nfunction insertionSort (arr) {\n  console.time('插入排序耗时');\n\n  for (let i = 1; i < arr.length; i++) {\n    let key = arr[i]\n    let j = i - 1\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j]\n      j--\n    }\n    arr[j + 1] = key\n  }\n  console.timeEnd('插入排序耗时');\n  return arr\n}\n```\n\n## 优化\n\n> 改进插入排序： 查找插入位置时使用二分查找的方式\n\n```js\nfunction insertionSort (array) {\n  console.time('二分插入排序耗时：');\n\n  for (var i = 1; i < array.length; i++) {\n    var key = array[i]; var left = 0; var right = i - 1\n    while (left <= right) {\n      var middle = parseInt((left + right) / 2)\n      if (key < array[middle]) {\n        right = middle - 1\n      } else {\n        left = middle + 1\n      }\n    }\n    for (var j = i - 1; j >= left; j--) {\n      array[j + 1] = array[j]\n    }\n    array[left] = key\n  }\n  console.timeEnd('二分插入排序耗时：');\n\n  return array\n}\n```\n\n## 动图\n\n![](//blogimg.jakeyu.top/排序算法/sort07.gif)\n\n## 分析\n\n* 最佳情况：输入数组按升序排列。T(n) = O(n)\n* 最坏情况：输入数组按降序排列。T(n) = O(n<sup>2</sup>)\n* 平均情况：T(n) = O(n<sup>2</sup>)\n\n# 希尔排序\n\n> 1959年Shell发明； 第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序\n\n## 描述\n\n> 希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。\n\n希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；\n* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；\n\n希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录`基本有序`时，再对全体记录进行依次直接插入排序。\n\n## 实现\n\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n\n1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n2. 按增量序列个数k，对序列进行k 趟排序；\n3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n```js\nfunction shellSort (arr) {\n  var len = arr.length\n\n  var temp\n\n  var gap = 1\n  console.time('希尔排序耗时:')\n  while (gap < len / 5) { // 动态定义间隔序列\n    gap = gap * 5 + 1\n  }\n  for (gap; gap > 0; gap = Math.floor(gap / 5)) {\n    for (var i = gap; i < len; i++) {\n      temp = arr[i]\n      for (var j = i - gap; j >= 0 && arr[j] > temp; j -= gap) {\n        arr[j + gap] = arr[j]\n      }\n      arr[j + gap] = temp\n    }\n  }\n  console.timeEnd('希尔排序耗时:')\n  return arr\n}\nvar arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48]\nconsole.log(shellSort(arr))// [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n```\n\n## 分析\n\n* 最佳情况：T(n) = O(nlog<sup>2</sup> n)\n* 最坏情况：T(n) = O(nlog<sup>2</sup> n)\n* 平均情况：T(n) =O(nlog n)\n\n# 快速排序\n\n> 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。\n\n## 描述\n\n> 快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n## 实现\n\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n1. 从数列中挑出一个元素，称为 \"基准\"（pivot）；\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n```js\nfunction quickSort (arr) {\n  if (arr.length <= 1) return arr\n  let left = []\n  let right = []\n  let center = arr.splice(Math.floor(arr / 2), 1)[0]\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] < center) {\n      left.push(arr[i])\n    } else {\n      right.push(arr[i])\n    }\n  }\n  return quickSort(left).concat([center], quickSort(right))\n}\n```\n\n## 动图\n\n![](//blogimg.jakeyu.top/排序算法/dd9dc195a7331351671fe9ac4f7d5aa4.gif)\n\n## 分析\n\n* 最佳情况：T(n) = O(nlog n)\n* 最差情况：T(n) = O(n<sup>2</sup>)\n* 平均情况：T(n) = O(nlog n)\n","tags":["JS"],"categories":["前端"]},{"title":"浅谈 instanceof 和 typeof 的实现原理","url":"/2018/11/13/浅谈-instanceof-和-typeof-的实现原理/","content":"\n![](//blogimg.jakeyu.top/浅谈-instanceof-和-typeof-的实现原理/images.png)\n\n<!--more-->\n\n## typeof 实现原理\n\n`typeof` 一般被用于判断一个变量的类型，我们可以利用 `typeof` 来判断`number`, `string`, `object`,`boolean`, `function`, `undefined`, `symbol` 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 `object` 类型的数据的时候，`typeof`能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，`typeof` 在判断一个` object`的数据的时候只能告诉我们这个数据是 `object`, 而不能细致的具体到是哪一种 `object`, 比如👉\n\n```js\nlet s = new String('abc');\ntypeof s === 'object'// true\ns instanceof String // true\n```\n\n要想判断一个数据具体是哪一种 `object` 的时候，我们需要利用 `instanceof` 这个操作符来判断，这个我们后面会说到。\n\n来谈谈关于 `typeof` 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？\n\n其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉\n\n* 000：对象\n* 010：浮点数\n* 100：字符串\n* 110：布尔\n* 1：整数\n\nbut, 对于 `undefined` 和 `null` 来说，这两个值的信息存储是有点特殊的:\n\n* `null`：所有机器码均为0\n* `undefined`：用 −2^30 整数来表示\n\n所以，`typeof` 在判断 `null` 的时候就出现问题了，由于 `null` 的所有机器码均为0，因此直接被当做了对象来看待。\n\n然而用 `instanceof` 来判断的话👉\n\n```js\nnull instanceof null // TypeError: Right-hand side of 'instanceof' is not an object\n```\n\n`null` 直接被判断为不是 `object`，这也是 `JavaScript` 的历史遗留bug，可以参考[typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)。\n\n因此在用 `typeof` 来判断变量类型的时候，我们需要注意，最好是用 `typeof` 来判断基本数据类型（包括`symbol`），避免对 `null` 的判断。\n\n还有一个不错的判断类型的方法，就是`Object.prototype.toString`，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断\n\n```js\nObject.prototype.toString.call(1) // \"[object Number]\"\n\nObject.prototype.toString.call('hi') // \"[object String]\"\n\nObject.prototype.toString.call({a:'hi'}) // \"[object Object]\"\n\nObject.prototype.toString.call([1,'a']) // \"[object Array]\"\n\nObject.prototype.toString.call(true) // \"[object Boolean]\"\n\nObject.prototype.toString.call(() => {}) // \"[object Function]\"\n\nObject.prototype.toString.call(null) // \"[object Null]\"\n\nObject.prototype.toString.call(undefined) // \"[object Undefined]\"\n\nObject.prototype.toString.call(Symbol(1)) // \"[object Symbol]\"\n```\n\n## instanceof 操作符的实现原理\n\n之前我们提到了 `instanceof` 来判断对象的具体类型，其实 `instanceof` 主要的作用就是判断一个实例是否属于某种类型\n\n```js\nlet person = function () {\n}\nlet nicole = new person()\nnicole instanceof person // true\n```\n\n当然，`instanceof` 也可以判断一个实例是否是其父类型或者祖先类型的实例。\n\n```js\nlet person = function () {\n}\nlet programmer = function () {\n}\nprogrammer.prototype = new person()\nlet nicole = new programmer()\nnicole instanceof person // true\nnicole instanceof programmer // true\n```\n\n这是 `instanceof` 的用法，但是 `instanceof` 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下\n\n```js\nfunction new_instance_of (leftVaule, rightVaule) {\n  let rightProto = rightVaule.prototype // 取右表达式的 prototype 值\n  leftVaule = leftVaule.__proto__ // 取左表达式的__proto__值\n  while (true) {\n  \tif (leftVaule === null) {\n      return false\n    }\n    if (leftVaule === rightProto) {\n      return true\n    }\n    leftVaule = leftVaule.__proto__\n  }\n}\n```\n\n其实 `instanceof` 主要的实现原理就是只要右边变量的 `prototype` 在左边变量的原型链上即可。因此，`instanceof` 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 `prototype`，如果查找失败，则会返回 `false`，告诉我们左边变量并非是右边变量的实例。\n\n看几个很有趣的例子\n\n```js\nfunction Foo() {}\n\nObject instanceof Object // true\nObject instanceof Function //true\nFunction instanceof Function // true\nFunction instanceof Object // true\nFoo instanceof Foo // false\nFoo instanceof Object // true\nFoo instanceof Function // true\n```\n\n要想全部理解 `instanceof` 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。\n\n关于原型继承的原理，我简单用一张图来表示\n\n![](//blogimg.jakeyu.top/浅谈-instanceof-和-typeof-的实现原理/e46508fbcd140db304232aba89f41c83_articlex.jpeg)\n\n我们知道每个 JavaScript 对象均有一个隐式的 `__proto__` 原型属性，而显式的原型属性是 `prototype`，只有 `Object.prototype.__proto__` 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 `instanceof` 使用的例子。\n\n### Object instanceof Object\n\n由图可知，Object 的 `prototype` 属性是 `Object.prototype`, 而由于 Object 本身是一个函数，由 Function 所创建，所以 `Object.__proto__` 的值是 `Function.prototype`，而 `Function.prototype` 的 `__proto__` 属性是 `Object.prototype`，所以我们可以判断出，`Object instanceof Object` 的结果是 true 。用代码简单的表示一下\n\n```js\nleftValue = Object.__proto__ = Function.prototype;\nrightValue = Object.prototype;\n// 第一次判断\nleftValue != rightValue\nleftValue = Function.prototype.__proto__ = Object.prototype\n// 第二次判断\nleftValue === rightValue\n// 返回 true\n```\n\n`Function instanceof Function` 和 `Function instanceof Object` 的运行过程与 `Object instanceof Object` 类似，故不再详说。\n\n### Foo instanceof Foo\n\nFoo 函数的 `prototype` 属性是 `Foo.prototype`，而 Foo 的 `__proto__` 属性是 `Function.prototype`，由图可知，Foo 的原型链上并没有 `Foo.prototype` ，因此 `Foo instanceof Foo` 也就返回 false 。\n\n我们用代码简单的表示一下\n\n```js\nleftValue = Foo, rightValue = Foo\nleftValue = Foo.__proto = Function.prototype\nrightValue = Foo.prototype\n// 第一次判断\nleftValue != rightValue\nleftValue = Function.prototype.__proto__ = Object.prototype\n// 第二次判断\nleftValue != rightValue\nleftValue = Object.prototype = null\n// 第三次判断\nleftValue === null\n// 返回 false\n```\n\n### Foo instanceof Object\n\n```js\nleftValue = Foo, rightValue = Object\nleftValue = Foo.__proto__ = Function.prototype\nrightValue = Object.prototype\n// 第一次判断\nleftValue != rightValue\nleftValue = Function.prototype.__proto__ = Object.prototype\n// 第二次判断\nleftValue === rightValue\n// 返回 true\n```\n\n### Foo instanceof Function\n\n```js\nleftValue = Foo, rightValue = Function\nleftValue = Foo.__proto__ = Function.prototype\nrightValue = Function.prototype\n// 第一次判断\nleftValue === rightValue\n// 返回 true\n```\n\n## 总结\n\n简单来说，我们使用 `typeof` 来判断基本数据类型是 ok 的，不过需要注意当用 `typeof` 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 `instanceof`，但是 `instanceof` 也可能判断不准确，比如一个数组，他可以被 `instanceof` 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 `Object.prototype.toString.call` 方法。\n\n## 参考\n\n* [https://juejin.im/post/5b0b9b9051882515773ae714](https://juejin.im/post/5b0b9b9051882515773ae714)\n","tags":["JS"],"categories":["前端"]},{"title":"nodejs调用小程序生成二维码接口，并保存成图片","url":"/2018/10/25/nodejs调用小程序生成二维码接口，并保存成图片/","content":"\n小程序生成二维码接口返回的是二进制，所以我们要把二进制流保存成图片，再返回给前端。\n\n这里我分别用`axios`和`request`实现请求\n\n<!--more-->\n\n## 获取token\n\n```js\nconst {data: { access_token }} = await axios.get('https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=APPID&secret=APPSECRET')\n```\n\n## axios\n\n```js\naxios({\n  method: 'post',\n  url: `https://api.weixin.qq.com/wxa/getwxacode?access_token=${access_token}`,\n  data: {\n    path: ''\n  },\n  responseType: 'stream'\n})\n  .then(function (response) {\n    response.data.pipe(fs.createWriteStream('path.jpg'))\n  })\n```\n\n## request\n\n```js\nrequest.post({\n  url: `https://api.weixin.qq.com/wxa/getwxacode?access_token=${access_token}`,\n  json: true,\n  headers: { 'content-type': 'application/json' },\n  body: {\n    path: ''\n  }\n}, function (error, response, body) {\n  res.send(imgUrl)\n}).pipe(fs.createWriteStream('path.png'))\n```\n","tags":["小程序"],"categories":["小程序"]},{"title":"现实","url":"/2018/10/22/现实/","content":"\n本不打算在这个博客里面写一些矫情的文字，我有另一个不公开的博客。但是这篇，我想写在这里。\n\n<!--more-->\n\n跟她分手了，原因也很简单————现实。\n\n她在美国读书，家境殷实，而我只是一个出身农村普通家庭，从小与水稻、大地为伴。\n\n我一直在努力赚钱，喜欢杭州，想要留在这里。本来异国恋已经很难了，而且我早有心理准备，没想到这一天到来的时候还是会无法释怀。\n\n20多岁的女孩子总归要考虑结婚，未来的问题，买房紧一紧首付还是有的，可是以后呢，跟着我一起吃苦，还房贷。如果再有一个宝宝，她的生活质量会明显下降，她也说过如果在一起会让生活质量下降，那就没必要在一起了。\n\n在一起的这段时间我很开心，她脾气也很好，没有公主脾气，我也全心全意去爱她。开始的时候就清楚的知道想到走到最后很难，即便是她这关过了，她父母呢？哪个女孩子的家长愿意让自己的女儿吃苦。家庭条件我无法选择，我也知道什么都不能靠家里，可是我刚毕业，几乎没有存款。二十多岁的男生，如果不靠家里，又有谁有钱呢，可是哪个女孩子愿意用青春去赌一个未知的未来？她想要的生活我短时间给不了，所以只能放弃，即便很痛苦。\n\n年轻的时候我想不明白为什么会因为外在因素而导致两个相爱的人分道扬镳，想不通为什么一方家长的不同意导致本来都谈婚乱嫁的新人分开……小时候告诉自己谈恋爱一定不分手，可现在洋洋洒洒已经七段感情，但是真正算是好好谈恋爱的也就那么两段。\n\n我们再也不是十八岁，现在看到还在上学，无忧无虑的孩子们只能感叹一句“年轻真好”，那时候我们可以天马行空，做着很多梦，哥几个在一起聊得都是毕业赚多少多少钱，各种游戏开黑，女人等，一旦毕业工作，那些幻想都闭口不谈，慢慢的被现实磨灭。我们几个兄弟有一个群，大学的时候经常闲聊，隔三差五讨论去哪玩、去哪喝酒，晚上喊着楼下来抽一根，无忧无虑，而现在更多的是车子、房子、工资，互相吹捧，用着一些我很讨厌的语气，气氛甚是诡异。而且大家基本都很少说话，一部分是因为大家都忙，一部分是因为感情变了。大家都为各自的生活忙碌奔波，王小波说过：“生活就是个缓慢受锤的过程”。\n\n愿那些跟我一样，在大城市挣扎的人们都不会被这魔幻的地方所抛弃。\n","categories":["随心"]},{"title":"vue webpack模板开启局域网访问","url":"/2018/09/20/vue-webpack模板开启局域网访问/","content":"\n修改`config/index.js`文件：\n\n```js\nconst { networkInterfaces } = require('os')\nconst getIpAddress = () => (networkInterfaces().en0 || networkInterfaces().en4).filter(({ family }) => family === 'IPv4')[0].address\n\ndev: {\n    ...\n    host: getIpAddress()\n    ...\n}\n\n```\n","tags":["VUE"],"categories":["前端"]},{"title":"css3自定义滚动条","url":"/2018/09/04/css3自定义滚动条/","content":"\n\n# 前言\n\n`webkit`支持拥有`overflow`属性的区域，列表框，下拉菜单，`textarea`的滚动条自定义样式，所以用处还是挺大的。当然，兼容所有浏览器的滚动条样式目前是不存在的。\n\n[DEMO](https://i.jakeyu.top/demo/CSS3%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F.html)\n\n# 滚动条属性\n\n* **::-webkit-scrollbar** 滚动条整体部分\n* **::-webkit-scrollbar-thumb**  滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）\n* **::-webkit-scrollbar-track**  滚动条的轨道（里面装有Thumb）\n* **::-webkit-scrollbar-button** 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。\n* **::-webkit-scrollbar-track-piece** 内层轨道，滚动条中间部分（除去）\n* **::-webkit-scrollbar-corner** 边角，即两个滚动条的交汇处\n* **::-webkit-resizer** 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件\n\n# 简洁版\n\n这里就不贴出详细代码了，demo里面可以通过查看源码寻找具体样式的设置。来看看demo中第二个滚动条的样式\n\n```css\n/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/\n::-webkit-scrollbar\n{\n    width: 16px;\n    height: 16px;\n    background-color: #F5F5F5;\n}\n\n/*定义滚动条轨道 内阴影+圆角*/\n::-webkit-scrollbar-track\n{\n    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);\n    border-radius: 10px;\n    background-color: #F5F5F5;\n}\n\n/*定义滑块 内阴影+圆角*/\n::-webkit-scrollbar-thumb\n{\n    border-radius: 10px;\n    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n    background-color: #555;\n}\n```\n\n# 详细设置\n\n定义滚动条就是利用伪元素与伪类，那什么是伪元素和伪类呢？\n\n伪类大家应该很熟悉`:link`,`:focus`,`:hover`，此外CSS3中又增加了许多伪类选择器，如`:nth-child`，`:last-child`，`:nth-last-of-type()`等。\n\nCSS中的伪元素大家以前看过：`:first-line`,`:first-letter`,`:before`,`:after`。那么在CSS3中，伪元素进行了调整，在以前的基础上增加了一个`：`也就是现在变成了`::first-letter`,`::first-line`,`::before`,`::after`，另外CSS3还增加了一个`::selection`。两个`：：`和一个`：`在css3中主要用来区分伪类和伪元素。\n\nwebkit的伪类和伪元素的实现很强，可以把滚动条当成一个页面元素来定义，再结合一些高级的CSS3属性，比如渐变、圆角、RGBa等等。然后如果有些地方要用图片，可以把图片也可以转换成Base64，不然每次都得加载那个多个图片，增加请求数。\n\n任何对象都可以设置：边框、阴影、背景图片等等，创建的滚动条任然会按照操作系统本身的设置来完成其交互的行为。下面的伪类可以应用到上面的伪元素中。有点小复杂，具体怎么写可以看第一个demo，那里也有注释。\n\n```css\n:horizontal\n/*horizontal伪类适用于任何水平方向上的滚动条*/\n\n:vertical\n/*vertical伪类适用于任何垂直方向的滚动条*/\n\n:decrement\n/*decrement伪类适用于按钮和轨道碎片。表示递减的按钮或轨道碎片，例如可以使区域向上或者向右移动的区域和按钮*/\n\n:increment\n/*increment伪类适用于按钮和轨道碎片。表示递增的按钮或轨道碎片，例如可以使区域向下或者向左移动的区域和按钮*/\n\n:start\n/*start伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的前面*/\n\n:end\n/*end伪类适用于按钮和轨道碎片。表示对象（按钮 轨道碎片）是否放在滑块的后面*/\n\n:double-button\n/*double-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一对按钮。也就是轨道碎片紧挨着一对在一起的按钮。*/\n\n:single-button\n/*single-button伪类适用于按钮和轨道碎片。判断轨道结束的位置是否是一个按钮。也就是轨道碎片紧挨着一个单独的按钮。*/\n\n:no-button\n/*no-button伪类表示轨道结束的位置没有按钮。*/\n\n:corner-present\n/*corner-present伪类表示滚动条的角落是否存在。*/\n\n:window-inactive\n/*适用于所有滚动条，表示包含滚动条的区域，焦点不在该窗口的时候。*/\n\n::-webkit-scrollbar-track-piece:start {\n/*滚动条上半边或左半边*/\n}\n\n::-webkit-scrollbar-thumb:window-inactive {\n/*当焦点不在当前区域滑块的状态*/\n}\n\n::-webkit-scrollbar-button:horizontal:decrement:hover {\n/*当鼠标在水平滚动条下面的按钮上的状态*/\n}\n```\n\n\n# 参考\n\n> 地址： [CSS3自定义滚动条样式 -webkit-scrollbar - 轩枫阁](https://www.xuanfengge.com/css3-webkit-scrollbar.html)\n","tags":["CSS"],"categories":["前端"]},{"title":"Content Security Policy (CSP) 介绍","url":"/2018/08/26/Content-Security-Policy-CSP-介绍/","content":"\n> 内容安全策略   (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。\n\n<!--more-->\n\n# 起因\n\n当我不经意间在 Twitter 页面 `view source` 后，发现了惊喜。\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <title>Twitter</title>\n  <style>\n  body {\n    background-color: #ffffff;\n    font-family: sans-serif;\n  }\n  a {\n    color: #1da1f2;\n  }\n  svg {\n    color: #1da1f2;\n    display: block;\n    fill: currentcolor;\n    height: 21px;\n    margin: 13px auto;\n    width: 24px;\n  }\n  </style>\n</head>\n<body>\n    <noscript>\n      <center>If you’re not redirected soon, please <a href=\"/\">use this link</a>.</center>\n    </noscript>\n    <script nonce=\"SG0bV9rOanQfzG0ccU8WQw==\">\n\n      document.cookie = \"app_shell_visited=1;path=/;max-age=5\";\n\n      location.replace(location.href.split(\"#\")[0]);\n    </script>\n</body>\n</html>\n```\n\n相比平时看到的其他站点的源码，可以说是很清爽了。没有乱七八糟的标签，功能却一样不少。特别有迷惑性，以为这便是页面所有的源码，但查看 DevTools 的 Source 面板后很容易知道这并不是真实的 HTML 代码。但为何页面源码给出的是如此清爽的版本，这里先不研究。\n\n把目光移向 script 标签时，发现一个不认识的 `nonce` 属性。它以及它后面的神秘字符串成功引起了我的好奇。再去看 Google 首页的源码，也有好些 `nonce` 的运用。是时候去了解一下这里的 `nonce` 是什么了。\n\n```js\n! <script nonce=\"SG0bV9rOanQfzG0ccU8WQw==\">\n\n    document.cookie = \"app_shell_visited=1;path=/;max-age=5\";\n\n    location.replace(location.href.split(\"#\")[0]);\n</script>\n```\n\n# Content Security Policy (CSP)\n\n要了解 `nonce`， 先了解 [Content-Security-Policy(CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)。\n\n我们都知道浏览器有同源策略（[same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy)）的安全限制，即每个站点只允许加载来自和自身同域（origin）的数据，`https://a.com` 是无法从 `https://b.com` 加载到资源的。每个站点被严格限制在了自已的孤岛上，自己就是一个沙盒，这样很安全，整个网络不会杂乱无章。主要地，它能解决大部分安全问题。假若没有同源策略，恶意代码能够轻松在浏览器端执行然后获取各种隐私信息：银行帐号，社交数据等。\n\n> 那网站间如何进行数据共享，当然是有办法的，了解下 [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。\n\n现实中，问题是同源策略也并不是万无一失，跨域攻击 [Cross-site scripting (XSS)](https://en.wikipedia.org/wiki/Cross-site_scripting) 便包含五花八门绕开限制的手段，形式上通过向页面注入恶意代码完成信息的窃取或攻击。比如 UGC 类型的站点，因为内容依赖用户创建，这就开了很大一个口子，允许用户输入的内容运行在页面上。当然，因为我们都知道会有注入攻击，所以对用户输入的内容进行防 XSS 过滤也成了标配。\n\nContent-Security-Policy 从另一方面给浏览器加了层防护，能极大地减少这种攻击的发生。\n\n## 原理\n\nCSP 通过告诉浏览器一系列规则，严格规定页面中哪些资源允许有哪些来源， 不在指定范围内的统统拒绝。相比同源策略，CSP 可以说是很严格了。\n\n其实施有两种途径：\n\n* 服务器添加 `Content-Security-Policy` 响应头来指定规则\n* HTML 中添加 <meta> 标签来指定 `Content-Security-Policy` 规则\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004494-f3c9bdf2-9e95-11e8-8793-e2966d79ecae.png)\n\n*mobile.twitter.com header 中的 CSP 规则*\n\n为了测试方便，以下示例均使用 `<meta>` 标签来开启 CSP 规则。但 `<meta>` 中有些指令是不能使用的，后面会了解到。只有响应头中才能使用全部的限制指令。\n\n一个简单示例\n\n创建一个 HTML 文件放入以下内容：\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' https://unpkg.com\">\n    <title>CSP Test</title>\n</head>\n<body>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n</body>\n</html>\n```\n\n在该测试文件所在目录开启一个本地 server 以访问，这里使用 Python 自带的 server:\n\n```sh\npython -m SimpleHTTPServer 8000\n```\n\n然后访问 localhost:8000 以观察结果：\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004498-fdd37004-9e95-11e8-895d-53797ae105c1.png)\n\n符合 CSP 规则情况下的正常访问\n\n然后我们将 `Content-Security-Policy` 改成不允许任何资源再试一下：\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n-     <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' https://unpkg.com\">\n+     <meta http-equiv=\"Content-Security-Policy\" content=\"script-src ‘none’\">\n    <title>CSP Test</title>\n</head>\n<body>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n</body>\n</html>\n```\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004501-0fac3a18-9e96-11e8-98bf-01e77f4a5e6a.png)\n\n*触发 CSP 规则资源被 block 的情况*\n\n下面我们来解释这里设置的 CSP 规则及理解为何资源加载失败。\n\nCSP 规则\n无论是 header 中还是 `<meta>` 标签中指定，其值的格式都是统一的，由一系列 CSP 指令（directive）组合而成。\n\n示例：\n\n```HTML\nContent-Security-Policy: <policy-directive>; <policy-directive>…\n```\n\n这里 directive，即指令，是 CSP 规范中规定用以详细详述某种资源的来源，比如前面示例中使用的 `script-src`，指定脚本可以有哪些合法来源，`img-src` 则指定图片，以下是常用指令：\n\n* `base-uri` 限制可出现在页面 `<base>` 标签中的链接。\n* `child-src` 列出可用于 worker 及以 frame 形式嵌入的链接。 譬如: `child-src https://youtube.com` 表示只能从 Youtube 嵌入视频资源。\n* `connect-src` 可发起连接的地址 (通过 XHR, WebSockets 或 EventSource)。\n* `font-src` 字体来源。譬如，要使用 Google web fonts 则需要添加 `font-src https://themes.googleusercontent.com` 规则。\n* `form-action` `<form>` 标签可提交的地址。\n* `frame-ancestors` 当前页面可被哪些来源所嵌入（与 `child-src` 正好相反）。作用于 `<frame>`, `<iframe>`, `<embed>` 及 `<applet>`。 该指令不能通过 `<meta>` 指定且只对非 HTML文档类型的资源生效。\n* `frame-src` 该指令已在 level 2 中废弃但会在 level 3 中恢复使用。未指定的情况下回退到 `tochild-src` 指令。\n* `img-src` 指定图片来源。\n* `media-src` 限制音视频资源的来源。\n* `object-src` Flash 及其他插件的来源。\n* `plugin-types` 限制页面中可加载的插件类型。\n* `report-uri` 指定一个可接收 CSP 报告的地址，浏览器会在相应指令不通过时发送报告。不能通过 `<meta>` 标签来指定。\n* `style-src` 限制样式文件的来源。\n* `upgrade-insecure-requests` 指导客户端将页面地址重写，HTTP 转 HTTPS。用于站点中有大量旧地址需要重定向的情形。\n* `worker-src` CSP Level 3 中的指令，规定可用于 worker, shared worker, 或 service worker 中的地址。\n\n> `child-src`  与 `frame-ancestors`  看起来比较像。前者规定的是页面中可加载哪些 iframe，后者规定谁可以以 iframe 加载本页。 比如来自不同站点的两个网页 A 与 B，B，B 中有 iframe 加载了 A。那么\n> * A 的 frame-ancestors 需要包含 B\n> * B 的 child-src 需要包含 A\n\n默认情况下，这些指令都是最大条件开放的，可以理解为其默认值为 `*`。比如 `img-src`，如果不明确指定，则可以从所有地方加载图片资源。\n\n还有种特殊的指令 `default-src`，如果指定了它的值，则相当于改变了这些未指定的指令的默认值。可以理解为，上面 `img-src` 如果没指定，本来其默认值是 `*`，可以加载所有来源的图片，但设置 `default-src` 后，默认值就成了 `default-src` 指定的值。\n\n常见的做法会设置 `default-src ‘self’`，这样所有资源都被限制在了和页面同域下。如果此时想要加载从 CDN 来的图片，将图片来源单独添加上即可。\n\n```HTML\nContent-Security-Policy: default-src ‘self’; img-src https://cdn.example.com\n```\n\n现在来看开头那个示例，也许现在就能看明白了。因为页面中需要从 CDN 加载 React 库，所以我们`<meta>` 标签指定了如下 CSP 规则：\n\n```HTML\nscript-src 'self' https://unpkg.com\n```\n\n这里的 `self` 及后来改成的 `none` 是预设值，需用引号包裹，否则会当成 URI 来解析。这里的 CSP 规则表示页面中脚本只能从同域及 `https://unpkg.com` 加载。假如我们把后者去掉，同样会像上图截图那样 React 库会加载失败，同时控制台中会有加载失败的日志及被触发的规则列出来。\n\n改成 `none` 之后表示页面不加载任何脚本，即使自己站点上的脚本都无法被加载执行。这里不妨试一下在 `csp_test.html` 旁边创建一个脚本文件 `test.js`:\n\ntest.js\n\n```js\nalert(‘来自 test.js 的问候！’)\n```\n\n同时在页面中引用它：\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'none'\">\n    <title>CSP Test</title>\n</head>\n<body>\n    <script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>\n+    <script src=\"./test.js\"></script>\n</body>\n</html>\n```\n\n页面执行结果：\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004512-262c4df0-9e96-11e8-88e9-df4e08cb98f1.png)\n\n*script-src none 时页面将不加载任何脚本*\n\n是的，哪怕是自己的脚本也无法被加载执行。CSP 就是这样严格和明确，不存在模棱两可的情况。所以在指定来源时，我们需要确认 URI 是否正确。\n\n## 指令可接受的值\n\n指令后面跟的来源，有两种写法\n\n* 预设值\n* URI 通配符\n\n### 预设值\n\n其中预设值有以下这些：\n\n* `none` 不匹配任何东西。\n* `self` 匹配当前域，但不包括子域。比如 example.com 可以，api.example.com 则会匹配失败。\n* `unsafe-inline` 允许内嵌的脚本及样式。是的，没看错，对于页面中内嵌的内容也是有相应限制规则的。\n* `unsafe-eval` 允许通过字符串动态创建的脚本执行，比如 eval，setTimeout 等。\n\n特别地，在 CSP 的严格控制下，页面中内联脚本及样式也会受影响，在没有明确指定的情况下，其不能被浏览器执行。\n\n考虑下面的代码：\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>CSP Test</title>\n    <style>\n        body{\n            color:red;\n        }\n    </style>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n    <script>\n        window.onload=function(){\n            alert('hi jack!')\n        }\n    </script>\n</body>\n</html>\n```\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004521-427e59bc-9e96-11e8-9608-743f4e3bfefe.png)\n\n*未指定 CSP 的情况*\n\n根据 MDN 上的描述，如果站点未指定 CSP 无则，浏览器默认不会开启相应检查，所以上面一切运行正常，只受正常的同域限制 。\n\n> If the site doesn't offer the CSP header, browsers likewise use the standard same-origin policy.\n> — 来自 MDN 关于 [Content Security Policy (CSP) 的描述](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)\n\n我们加上 CSP 限制：\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n+    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'\">\n    <title>CSP Test</title>\n    <style>\n        body{\n            color:red;\n        }\n    </style>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n    <script>\n        window.onload=function(){\n            alert('hi jack!')\n        }\n    </script>\n</body>\n</html>\n```\n\n配置站点默认只信息同域的资源，但注意，这个设置并不包含内联的情况，所以结果会如下图。\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004526-54cf1a5c-9e96-11e8-8bca-c980e51a82ae.png)\n\n*内联代码被禁止*\n\n如何修复它呢。如果我们想要允许页面内的内联脚本或样式，则需要明确地通过 script-src 和 style-src 指出来。\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n!    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' ‘unsave-inline’\">\n    <title>CSP Test</title>\n    <style>\n        body{\n            color:red;\n        }\n    </style>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n    <script>\n        window.onload=function(){\n            alert('hi jack!')\n        }\n    </script>\n</body>\n</html>\n```\n\n这里 `default-src 'self' ‘unsave-inline’` 配置默认可信的来源有这些： 和页面同域的，以及内联的。\n\n刷新页面，样式及脚本又可以正常执行了。\n\n通常是不建议使用 `unsafe-inline` 的（同样也不推荐使用 `unsafe-eval`），因为内联的脚本和样式维护不便，也不利用良好地组织代码。最佳实践是样式抽离到样式文件，脚本放到单独的 js 文件中加载，让 HTML 文件纯粹一点才是好的做法。即使是 `onclick=“myHandler”` 或 `href=“javascript:;”` 这种平时常见的写法，也属于内联的脚本，是需要改造的。\n\n如果页面中非得用内联的写法，还有种方式。即页面中这些内联的脚本或样式标签，赋值一个加密串，这个加密串由服务器生成，同时这个加密串被添加到页面的响应头里面。\n\n```js\n<script nonce=\"EDNnf03nceIOfn39fn3e9h3sdfa\">\n  // 这里放置内联在 HTML 中的代码\n</script>\n```\n\n页面 HTTP 响应头的 `Content-Security-Policy` 配置中包含相同的加密串：\n\n```HTML\nContent-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'\n```\n\n注意这里的 `nonce-` 前缀。\n\n这也就是文章开头看到的方式，到这里明白了。\n\n`<style>` 标签也是类似的处理。\n\n这里的加密串一定是随机不可预测的，否则达不到安全效果，且每次页面被访问时重新生成。\n\n除了使用 `nonce` 指定加密串，还可以通过混淆的 hash 值来达到目的。这种做法不需要在标签上加 `nonce` 而是将需要内嵌的代码本身使用加密算法生成 hash 后放入 CSP 指令中作为值使用，这里的加密算法支持 sha256, sha384 和 sha512。此时 CSP 中使用的前缀为相应的算法名。\n\nhash 方式的示例：\n\n```js\n<script>alert('Hello, world.');</script>\n```\n\n```HTML\nContent-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='\n```\n\n### eval\n\njs 中好些地方是可以以字符串方式动态创建代码并执行，这被认为是不安全的，所以不推荐使用，一般最佳实践里都会提。\n\n* `setTimeout/setInterval` 可接收一段字符串作为代码执行。```js setTimeout('alert(1)',1000) ```。\n* `eval` 。```js eval('alert(1)') ```。\n* `Function` 构造函数。 ```js new Function('alert(1)') ```。\n\n和内联一样，有专门的指令 `unsafe-eval` 以允许类似代码的执行。但建议的做法是对于 `eval` 和 `Function` 构造器，杜绝使用，而 `setTimeout/setInterval` 可改造为非字符串形式。\n\n```js\nsetTimout(function(){\n    alert(1);\n}, 1000)\n```\n\n### URI\n\n除了上面的预设值，还可通过提供完整的 URI 或带通配符 `*` 的地址来匹配，以指定资源的合法来源。这里 URI 的规则和配置服务器的跨域响应头是一样的，参考 [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)。\n\n* `*://*.example.com:*` 会匹配所有 `example.com` 的子域名，但不包括 `example.com`。\n* `http://example.com` 和 `http://www.example.com` 是两个不同的 URI。\n* `http://example.com:80` 和 `http://example.com` 也是是两个不同的 URI，虽然网站默认端口就是 80\n\n> 根据维基百科 [Uniform Resource Identifier](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier) 页面 给出的解释，一个完整的 URI 由以下部分组成：\n> `URI = scheme:[//authority]path[?query][#fragment]`\n>\n> 其中 `authority` 又包含：\n> `authority = [userinfo@]host[:port]`\n>\n> 所以你可以认为其中某一项不同，那都是两个 URI。了解这点很重要，一如上面列出的第一条例子 `*.example.com`， 我们很容易先入为主地认为既然已经允许了该域名的所有子域名，那必然 `example.com` 也是合法的。\n\n因为 URI 是进行动态匹配的，所以解释了上面提到的预设值缘何要加引号。因为如果不加引号的话， `self` 会表示 `host` 是 `self` 的资源地址，而不会表示原有的意思。\n\n优先级\nCSP 的配置是很灵活的。每条指令可指定多个来源，空格分开。而一条 CSP 规则可由多条指令组成，指令间用分号隔开。各指令间没有顺序的要求，因为每条指令都是各司其职。甚至一次响应中， `Content-Security-Policy` 响应头都可以重复设置。\n\n我们来看这些情形下 CSP 的表现。\n\n* 对于设置了多次响应头的情况，最严格的规则会生效。比如下面两条响应头中，虽然 第二条中设置 `connect-src` 允许 `http://example.com/`，但第一条里面设置了 `connect-src` 为 `none`，所以更加严格的 `none` 会生效。参见 [Multiple content security policies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#Multiple_content_security_policies)。\n\n```HTML\nContent-Security-Policy: default-src 'self' http://example.com;\n                         connect-src 'none';\nContent-Security-Policy: connect-src http://example.com/;\n                         script-src http://example.com/\n```\n\n* 同一指令多次指定，以第一个为准，后续的会被忽略。\n\n*csp_test.html*\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self';default-src 'unsafe-inline';\">\n    <title>CSP Test</title>\n    <style>\n        body{\n            color:red;\n        }\n    </style>\n</head>\n<body>\n    <h1>Hello, World!</h1>\n    <script>\n        window.onload=function(){\n            alert('hi jack!')\n        }\n    </script>\n</body>\n</html>\n```\n\n![](//blogimg.jakeyu.top/Content-Security-Policy-CSP-介绍/44004528-6a4a9f5a-9e96-11e8-88b6-6aee3342ed08.png)\n\n*重复配置同一指令时效果展示*\n\n很智能地， 浏览器不仅会将检测不过的资源及指令打印出来，重复配置时被忽略的指令也会提示出来。\n\n* 指定 `default-src` 的情况下，它会充当 `Fetch` 类指令 的默认值。即 `default-src` 并不对所有指令生效，其他指令默认值仍是 `*`。\n\n# 发送报告\n\n当检测到非法资源时，除了控制台看到的报错信息，也可以让浏览器将日志发送到服务器以供后续分析使用。接收报告的地址可在 `Content-Security-Policy` 响应头中通过 `report-uri` 指令来配置。当然，服务端需要编写相应的服务来接收该数据。\n\n```HTML\nContent-Security-Policy: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;\n```\n\n服务端拿到的是以 JSON 形式传来的数据。\n\n```JSON\n{\n  \"csp-report\": {\n    \"document-uri\": \"http://example.org/page.html\",\n    \"referrer\": \"http://evil.example.com/\",\n    \"blocked-uri\": \"http://evil.example.com/evil.js\",\n    \"violated-directive\": \"script-src 'self' https://apis.google.com\",\n    \"original-policy\": \"script-src 'self' https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser\"\n  }\n}\n```\n\n# 报告模式\n\nCSP 提供了一种报告模式，该模式下资源不会真的被限制加载，只会对检测到的问题进行上报 ，以 `JSON` 数据的形式发送到 `report-uri` 指定的地方。\n\n通过指定 `Content-Security-Policy-Report-Only` 而不是 `Content-Security-Policy`，则开启了报告模式。\n\n```HTML\nContent-Security-Policy-Report-Only: default-src 'self'; ...; report-uri /my_amazing_csp_report_parser;\n```\n\n当然，你也可以同时指定两种响应头，各自里的规则还会正常执行，不会互相影响。比如：\n\n```HTML\nContent-Security-Policy: img-src *;\nContent-Security-Policy-Report-Only: img-src ‘none’; report-uri http://reportcollector.example.com/collector.cgi\n```\n\n这里图片还是会正常加载，但是 `img-src ‘none’` 也会检测到并且发送报告。\n\n报告模式对于测试非常有用。在开启 CSP 之前肯定需要对整站做全面的测试，将发现的问题及时修复后再真正开启，比如上面提到的对内联代码的改造。\n\n# 推荐的做法\n\n这样的安全措施当然是能尽快启用就尽快。以下是推荐的做法：\n\n* 先只开启报告模式，看影响范围，修改问题。\n* 添加指令时从 `default-src ‘none’` 开始，查看报错，逐步添加规则直至满足要求。\n* 上线后观察一段时间，稳定后再由报告模式转到强制执行。\n\n# 浏览器兼容性\n\n目前发布的 [Level 3](https://www.w3.org/TR/CSP3/) 规范 中大部分还未被浏览器实现，通过 [Can I Use](https://caniuse.com/#search=CSP) 的数据 来看，除 IE 外，Level 2 的功能已经得到了很好的支持。这里还有一分来自 W3C 跟踪的各浏览器实现情况的统计：[Implementation Report for Content Security Policy Level 2](https://w3c.github.io/webappsec/implementation_reports/CSP2_implementation_report.html)。\n\n对于浏览器不支持的情况，也不必担心，会回退到同源策略的限制上。\n\n# 参考\n\n> 原文：[http://www.cnblogs.com/Wayou/p/intro_to_content_security_policy.html](http://www.cnblogs.com/Wayou/p/intro_to_content_security_policy.html)\n> 作者： 刘哇勇\n","tags":["HTML"],"categories":["前端"]},{"title":"Object.create","url":"/2018/08/23/Object-create/","content":"\n在Vue和Vuex的源码中，作者都使用了`Object.create(null)`来初始化一个新对象。为什么不用更简洁的`{}`呢？\n\n在`SegmentFault`和`Stack Overflow`等开发者社区中也有很多人展开了讨论，在这里总结成文，温故知新。\n\n<!--more-->\n\n# 定义\n\n照搬一下MDN上的定义：\n\n```js\nObject.create(proto,[propertiesObject])\n```\n\n* proto:新创建对象的原型对象\n* propertiesObject:可选。要添加到新对象的可枚举（新添加的属性是其自身的属性，而不是其原型链上的属性）的属性。\n\n# 实现类式继承\n\n下面的例子演示了如何使用`Object.create()`来实现类式继承。这是一个所有版本`JavaScript`都支持的单继承。\n\n```js\n// Shape - 父类(superclass)\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\n// 父类的方法\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n\n// Rectangle - 子类(subclass)\nfunction Rectangle() {\n  Shape.call(this); // call super constructor.\n}\n\n// 子类续承父类\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n\nvar rect = new Rectangle();\n\nconsole.log('Is rect an instance of Rectangle?',\n  rect instanceof Rectangle); // true\nconsole.log('Is rect an instance of Shape?',\n  rect instanceof Shape); // true\nrect.move(1, 1); // Outputs, 'Shape moved.'\n```\n\n如果你希望能继承到多个对象，则可以使用混入的方式。\n\n```js\nfunction MyClass() {\n     SuperClass.call(this);\n     OtherSuperClass.call(this);\n}\n\n// 继承一个类\nMyClass.prototype = Object.create(SuperClass.prototype);\n// 混合其它\nObject.assign(MyClass.prototype, OtherSuperClass.prototype);\n// 重新指定constructor\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = function() {\n     // do a thing\n};\n```\n\n[Object.assign](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 会把`OtherSuperClass`原型上的函数拷贝到 `MyClass`原型上，使 `MyClass` 的所有实例都可用 `OtherSuperClass` 的方法。`Object.assign` 是在 ES2015 引入的，且可用 [polyfilled](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill)。要支持旧浏览器的话，可用使用 [jQuery.extend()](https://api.jquery.com/jQuery.extend/) 或者 [_.assign()](https://lodash.com/docs/#assign)。\n\n# 使用 Object.create 的 propertyObject参数\n\n```js\nvar o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: {\n    writable:true,\n    configurable:true,\n    value: \"hello\"\n  },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) {\n      console.log(\"Setting `o.bar` to\", value);\n    }\n  }\n});\n\n\nfunction Constructor(){}\no = new Constructor();\n// 上面的一句就相当于:\no = Object.create(Constructor.prototype);\n// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码\n\n\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//\"q\"\n\ndelete o.p\n//false\n\n//创建一个可写的,可枚举的,可配置的属性p\no2 = Object.create({}, {\n  p: {\n    value: 42,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  }\n});\n```\n\n# Object.create()、{…}的区别\n\n先看看我们经常使用的`{}`创建的对象是什么样子的：\n\n```js\nvar o = {a: 1};\nconsole.log(o)\n```\n\n在chrome控制台打印如下：\n\n![](//blogimg.jakeyu.top/详解Object.create/Jietu20180823-225215@2x.png)\n\n从上图可以看到，新创建的对象继承了`Object`自身的方法，如`hasOwnProperty`、`toString`等，在新对象上可以直接使用。\n\n再看看使用`Object.create()`创建对象：\n\n```js\nvar o = Object.create(null,{\n    a:{\n        writable:true,\n        configurable:true,\n        value:'1'\n    }\n})\nconsole.log(o)\n```\n\n在chrome控制台打印如下：\n\n![](//blogimg.jakeyu.top/详解Object.create/Jietu20180823-225402@2x.png)\n\n可以看到，新创建的对象除了自身属性a之外，原型链上没有任何属性，也就是没有继承`Object`的任何东西，此时如果我们调用`o.toString()`会报`Uncaught TypeError`的错误。\n\n大家可能会注意到，第一个参数使用了`null`。也就是说将`null`设置成了新创建对象的原型，自然就不会有原型链上的属性。我们再把上面的例子改一改：\n\n```js\nvar o = Object.create({},{\n    a:{\n        writable:true,\n        configurable:true,\n        value:'1'\n    }\n})\nconsole.log(o)\n```\n\n将`null`改为`{}`，结果是怎样的？在chrome控制台打印如下：\n\n![](//blogimg.jakeyu.top/详解Object.create/Jietu20180823-225532@2x.png)\n\n我们看到，这样创建的对象和使用`{}`创建对象已经很相近了，但是还是有一点区别：多了一层`proto`嵌套。\n\n我们最后再来改一下：\n\n```js\nvar o = Object.create(Object.prototype,{\n    a:{\n        writable:true,\n        configurable:true,\n        value:'1'\n    }\n})\nconsole.log(o)\n```\n\nchrome控制台打印如下：\n\n![](//blogimg.jakeyu.top/详解Object.create/Jietu20180823-225725@2x.png)\n\n这次就和使用`{}`创建的对象一模一样了。至此，我相信大家已经对两者的区别十分清楚了。\n\n# Object.create(null)的使用场景\n\n再回到文章开头的问题，为什么很多源码作者会使用`Object.create(null)`来初始化一个新对象呢？这是作者的习惯，还是一个最佳实践？\n\n其实都不是，这并不是作者不经思考随便用的，也不是javascript编程中的最佳实践，而是需要因地制宜，具体问题具体分析。\n\n我们进一步比较一下`Object.create(null)`和`{}`创建控对象的区别：\n\n在chrome打印如下：\n\n![](//blogimg.jakeyu.top/详解Object.create/Jietu20180823-230002@2x.png)\n\n从上图可以看到，使用`create`创建的对象，没有任何属性，显示`No properties`，我们可以把它当作一个非常纯净的`map`来使用，我们可以自己定义`hasOwnProperty`、`toString`方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。举个例子：\n\n```js\n//Demo1:\nvar a= {...省略很多属性和方法...};\n//如果想要检查a是否存在一个名为toString的属性，你必须像下面这样进行检查：\nif(Object.prototype.hasOwnProperty.call(a,'toString')){\n    ...\n}\n//为什么不能直接用a.hasOwnProperty('toString')?因为你可能给a添加了一个自定义的hasOwnProperty\n//你无法使用下面这种方式来进行判断,因为原型上的toString方法是存在的：\nif(a.toString){}\n\n//Demo2:\nvar a = Object.create(null)\n//你可以直接使用下面这种方式判断，因为存在的属性，都将定义在a上面，除非手动指定原型：\nif(a.toString){}\n```\n\n另一个使用`create(null)`的理由是，在我们使用`for..in`循环的时候会遍历对象原型链上的属性，使用`create(null)`就不必再对属性进行检查了，当然，我们也可以直接使用`Object.keys[]`。\n\n# 总结\n\n1. 你需要一个非常干净且高度可定制的对象当作数据字典的时候；\n2. 想节省`hasOwnProperty`带来的一丢丢性能损失并且可以偷懒少些一点代码的时候\n\n用`Object.create(null)`吧！其他时候，请用`{}`。\n\n# 参考\n\n* [详解Object.create(null)](https://juejin.im/post/5acd8ced6fb9a028d444ee4e)\n* [Object.create()--MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill)\n","tags":["JS"],"categories":["前端"]},{"title":"数组去重","url":"/2018/08/18/数组去重/","content":"\n# Set方法\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5]\n\nconsole.log([...new Set(arr)])  //[1, 2, 3, 4, 5]\n```\n\n# indexOf\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5]\nlet newArr = []\n\narr.forEach(item => {\n    if(newArr.indexOf(item) === -1) {\n        newArr.push(item)\n    }\n})\n\nconsole.log(newArr) //[1, 2, 3, 4, 5]\n```\n\n正常情况下使用这种方式没问题，但是当`arr`中有`NaN`时：\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5, NaN, NaN]\nlet newArr = []\n\narr.forEach(item => {\n    if(newArr.indexOf(item) === -1) {\n        newArr.push(item)\n    }\n})\n\nconsole.log(newArr) //[1, 2, 3, 4, 5, NaN, NaN]\n```\n\n结果与预期的不符，因为`indexOf`判断`NaN`时，结果始终为`-1`。\n\n我们可以使用`includes`进行判断，`includes`会正确判断`NaN`，但是与`Object.is()`表现不同的是`+0`和`-0`，`includes`判断`+0`、`-0`为`true`。\n\n关于`Object.is()`请查看：[在相等比较中使用 Object.is()让结果更准确](https://i.jakeyu.top/2018/08/14/%E5%9C%A8%E7%9B%B8%E7%AD%89%E6%AF%94%E8%BE%83%E4%B8%AD%E4%BD%BF%E7%94%A8-Object-is-%E8%AE%A9%E7%BB%93%E6%9E%9C%E6%9B%B4%E5%87%86%E7%A1%AE/)\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5, NaN, NaN]\nlet newArr = []\n\narr.forEach(item => {\n    if(!newArr.includes(item)) {\n        newArr.push(item)\n    }\n})\n\nconsole.log(newArr) //[1, 2, 3, 4, 5, NaN]\n```\n\n# 使用对象Key\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5, NaN, NaN]\nlet newArr = []\nlet obj = {}\n\narr.forEach(item => {\n    if(!obj[item]) {\n        obj[item] = true\n        newArr.push(item)\n    }\n})\n\nconsole.log(newArr) //[1, 2, 3, 4, 5, NaN]\n```\n\n但是如果下面的情况，使用这种方式就会有问题：\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5, '5', NaN, NaN]\nlet newArr = []\nlet obj = {}\n\narr.forEach(item => {\n    if(!obj[item]) {\n        obj[item] = true\n        newArr.push(item)\n    }\n})\n\nconsole.log(newArr) //[1, 2, 3, 4, 5, NaN]\n```\n\n我们发现`'5'`被过滤掉了，因为`Object`的会把`key`默认转换成字符串，所以识别`5`时，会当成`'5'`处理，所以再判断`'5'`时，对象中已经存在。\n\n对于这样的情况，我们可以使用ES6的`Map`结构。\n\n```js\nlet arr = [1, 2, 2, 3, 3, 4, 5, '5', NaN, NaN]\nlet newArr = []\nlet obj = new Map()\n\narr.forEach(item => {\n    if(!obj.has(item)) {\n        obj.set(item,true)\n        newArr.push(item)\n    }\n})\n\nconsole.log(newArr) //[1, 2, 3, 4, 5, \"5\", NaN]\n```\n\n我们看到`Map`并没有把`5`转换成`'5'`。\n\n关于`Map`更多了解，请查看：[Set 和 Map 数据结构](http://es6.ruanyifeng.com/#docs/set-map)\n","tags":["JS"],"categories":["前端"]},{"title":"解构","url":"/2018/08/14/解构/","content":"\n# 对象解构\n\n## 基本用法\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\"\n}\n\nlet { type, name } = node\n\nconsole.log(type) // Indentifier\nconsole.log(type) // foo\n```\n\n## 解构赋值\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\"\n}\nlet type = 'Literal'\nlet name = 5\n\n({ type, name } = node)\n\nconsole.log(type) // Indentifier\nconsole.log(name) // foo\n```\n\n** 注： ** 一定要用小括号包裹解构赋值语句，JavaScript引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在解构赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。\n\n## 给函数解构赋值\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\"\n}\nlet type = 'Literal'\nlet name = 5\n\nfunction outputInfo(value) {\n    console.log(value === node) // true\n}\n\noutputInfo({ type, name } = node)\n\nconsole.log(type) // Indentifier\nconsole.log(name) // foo\n```\n\n## 默认值\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\"\n}\nlet type = 'Literal'\nlet name = 5\n\nlet { type, name, value } = node\n\nconsole.log(type) // Indentifier\nconsole.log(name) // foo\nconsole.log(value) // undefined\n```\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\"\n}\nlet type = 'Literal'\nlet name = 5\n\nlet { type, name, value = true } = node\n\nconsole.log(type) // Indentifier\nconsole.log(name) // foo\nconsole.log(value) // true\n```\n\n## 非同名局部变量赋值\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\"\n}\n\nlet { type: localType, name: localName } = node\n\nconsole.log(localType) // Indentifier\nconsole.log(localName) // foo\n```\n\n默认值\n\n```js\nlet node = {\n    type: \"Indentifier\"\n}\n\nlet { type: localType, name: localName = \"bar\" } = node\n\nconsole.log(localType) // Indentifier\nconsole.log(localName) // bar\n```\n\n## 嵌套对象解构\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\",\n    loc: {\n        start: {\n            line: 1,\n            column: 1\n        },\n        end: {\n            line: 1,\n            column: 4\n        }\n    }\n}\n\nlet { loc: { start } } = node\n\nconsole.log(start.line) // 1\nconsole.log(start.column) // 1\n```\n\n非同名局部变量赋值\n\n```js\nlet node = {\n    type: \"Indentifier\",\n    name: \"foo\",\n    loc: {\n        start: {\n            line: 1,\n            column: 1\n        },\n        end: {\n            line: 1,\n            column: 4\n        }\n    }\n}\n\nlet { loc: { start: localStart } } = node\n\nconsole.log(localStart.line) // 1\nconsole.log(localStart.column) // 1\n```\n\n# 数组解构\n\n## 基本用法\n\n```js\nlet colors = [ \"red\", \"green\", \"blue\" ]\n\nlet [ firstColor, secondColor ] = colors\n\nconsole.log(firstColor) // red\nconsole.log(secondColor) // green\n```\n\n## 取特定位置\n\n```js\nlet colors = [ \"red\", \"green\", \"blue\" ]\n\nlet [ , , thirdColor ] = colors\n\nconsole.log(thirdColor) // blue\n```\n\n## 解构赋值\n\n```js\nlet colors = [ \"red\", \"green\", \"blue\" ]\nlet firstColor = 'black'\nlet secondColor = 'purple'\n\nlet [ firstColor, secondColor ] = colors\n\nconsole.log(firstColor) // red\nconsole.log(secondColor) // green\n```\n\n## 交换变量\n\n### ES5\n\n```js\nlet a = 1\nlet b = 2\nlet tmp\n\ntmp = a\na = b\nb = tmp\n```\n\n### ES6\n\n```js\nlet a = 1\nlet b = 2\n\n[ a, b ] = [ b, a ]\n```\n\n## 默认值\n\n```js\nlet colors = [ \"red\" ]\n\nlet [ firstColor, secondColor = 'green' ] = colors\n\nconsole.log(firstColor) // red\nconsole.log(secondColor) // green\n```\n\n## 嵌套数组解构\n\n```js\nlet colors = [ \"red\", [ \"green\", \"lightgreen\" ], \"blue\" ]\n\nlet [ firstColor, [ secondColor ] ] = colors\n\nconsole.log(firstColor) // red\nconsole.log(secondColor) // green\n```\n\n## 不定元素\n\n```js\nlet colors = [ \"red\", \"green\", \"blue\" ]\n\nlet [ firstColor, ...restColors ] = colors\n\nconsole.log(firstColor) // red\nconsole.log(restColors) // [ \"green\", \"blue\" ]\n```\n\n## 克隆\n\n```js\nlet colors = [ \"red\", \"green\", \"blue\" ]\n\nlet [ ...cloneColors ] = colors\n\nconsole.log(cloneColors) // [ \"red\", \"green\", \"blue\" ]\n```\n\n# 混合解构\n\n```js\nlet node = {\n    type: 'Identifier',\n    name: 'foo',\n    loc: {\n        start: {\n            line: 1,\n            column: 1\n        },\n        end: {\n            line: 1,\n            column: 4\n        },\n        range: [0, 3]\n    }\n}\n\nlet { loc: { start }, range: [startIndex] } = node\n\nconsole.log(start.line) // 1\nconsole.log(start.column) // 1\nconsole.logs(startIndex) // 0\n```\n\n# 参考\n\n* 深入理解ES6 -- 作者: 【美】Nicholas C. Zakas\n","tags":["ES6"],"categories":["前端"]},{"title":"在相等比较中使用 Object.is()让结果更准确","url":"/2018/08/14/在相等比较中使用-Object-is-让结果更准确/","content":"\n当在`JavaScript`中比较两个值时，可能习惯于使用`==`或`===`，我更喜欢后者，因为`==`存在强制类型转换。但是`===`也不完全准确。\n\n<!--more-->\n\n![](//blogimg.jakeyu.top/在相等比较中使用Object.is让结果更准确/Jietu20180814-220057.png)\n\n比较`NaN`需要使用`isNaN()`方法才可以正确检测 NaN。\n\nES6中引入了`Object.is()`方法来弥补全等运算符的不准确运算。这个方法接收两个参数，如果这两个参数类型相同且具有相同的值，则返回`true`。\n\n![](//blogimg.jakeyu.top/在相等比较中使用Object.is让结果更准确/Jietu20180814-220601.png)\n\n对于`Object.is()`方法来说，其运行结果大部分情况中与`===`运算符相同，唯一区别在于`+0`和`-0`被识别为不相等并且`NaN`与`NaN`等价。\n\n放一张对比图:\n\n![](//blogimg.jakeyu.top/在相等比较中使用Object.is让结果更准确/pCyqkLc.png)\n\n\n参考\n\n* 深入理解ES6 -- 作者: 【美】Nicholas C. Zakas\n* [为什么你应该在相等比较中使用 Object.is()](http://www.jstips.co/zh_cn/javascript/why-you-should-use-Object.is(%29-in-equality-comparison/)\n","tags":["ES6"],"categories":["前端"]},{"title":"video汇总","url":"/2018/07/19/video汇总/","content":"\n开发中遇到的video一些问题的汇总。\n\n![](//blogimg.jakeyu.top/video汇总/hmtl5video-thumb-1200x565.jpg)\n\n<!--more-->\n\n## 倍数播放\n\nB站，或者腾讯视频等主流视频网站视频现在都支持倍速播放功能。介绍一下实现方法。\n\n其实很简单，使用HTML5 video 原生 [`playbackrate`](http://www.w3school.com.cn/tags/av_prop_playbackrate.asp) 属性就能实现。\n\n```js\nvar video = document.getElementById(\"video\");\n\nvar speed = video.playbackRate //获取播放速度\n\nvideo.playbackRate = 0.5 //设置播放速度为0.5\n```\n\n## 常用属性\n\n```html\n<video\n  id=\"video\"\n  src=\"video.mp4\"\n  controls = \"true\"\n  poster=\"images.jpg\" /*视频封面*/\n  preload=\"auto\"\n  webkit-playsinline=\"true\" /*这个属性是ios 10中设置可以让视频在小窗内播放，也就是不是全屏播放*/\n  playsinline=\"true\"  /*IOS微信浏览器支持小窗内播放*/\n  x-webkit-airplay=\"allow\"\n  x5-video-player-type=\"h5\"  /*启用H5播放器,是wechat安卓版特性*/\n  x5-video-player-fullscreen=\"true\" /*全屏设置，设置为 true 是防止横屏*/\n  x5-video-orientation=\"portraint\" //播放器支付的方向， landscape横屏，portraint竖屏，默认值为竖屏\n  style=\"object-fit:fill\">\n</video>\n```\n\n* `src`: 视频地址\n* `controls`: 使用系统默认控制组件\n* `poster`: 属性规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。如果未设置该属性，则使用视频的第一帧来代替。\n* `preload`: 属性规定在页面加载后载入视频。\n* `webkit-playsinline、playsinline`: 视频播放时局域播放，不脱离文档流 。但是这个属性比较特别， 需要嵌入网页的APP比如WeChat中UIwebview 的allowsInlineMediaPlayback = YES webview.allowsInlineMediaPlayback = YES，才能生效。换句话说，如果APP不设置，你页面中加了这标签也无效，这也就是为什么安卓手机WeChat 播放视频总是全屏，因为APP不支持playsinline，而ISO的WeChat却支持。\n* `x-webkit-airplay=”allow”`: 这个属性应该是使此视频支持ios的AirPlay功能。使用AirPlay可以直接从使用iOS的设备上的不同位置播放视频、音乐还有照片文件，也就是说通过AirPlay功能可以实现影音文件的无线播放，当然前提是播放的终端设备也要支持相应的功能\n* `x5-video-player-type`: 启用同层H5播放器，就是在视频全屏的时候，div可以呈现在视频层上，也是WeChat安卓版特有的属性。同层播放别名也叫做沉浸式播放，播放的时候看似全屏，但是已经除去了control和微信的导航栏，只留下”X”和”<”两键。目前的同层播放器只在Android（包括微信）上生效，暂时不支持iOS。至于为什么同层播放只对安卓开放，是因为安卓不能像ISO一样局域播放，默认的全屏会使得一些界面操作被阻拦，如果是全屏H5还好，但是做直播的话，诸如弹幕那样的功能就无法实现了，所以这时候同层播放的概念就解决了这个问题。不过在测试的过程中发现，不同版本的IOS和安卓效果略有不同\n* `x5-video-orientation`: 声明播放器支持的方向，可选值landscape 横屏, portraint竖屏。默认值portraint。无论是直播还是全屏H5一般都是竖屏播放，但是这个属性需要x5-video-player-type开启H5模式\n* `x5­-video­-player­-fullscreen`: 全屏设置。它又两个属性值，ture和false，true支持全屏播放，false不支持全屏播放。其实，IOS 微信浏览器是webkit内核，相关的属性都支持，也是为什么X5同层播放不支持的原因。安卓微信浏览器是X5内核，一些属性标签比如playsinline就不支持，所以始终全屏。\n\n## 自动播放\n\n```js\nconst video = document.getElementById('video')\nvideo.play()\n// 兼容微信\ndocument.addEventListener('WeixinJSBridgeReady', function () {\n    video.play()\n}, false)\n```\n\n## 参考链接\n\n* [视频H5 video标签最佳实践](https://segmentfault.com/a/1190000009395289)\n","tags":["video"],"categories":["前端"]},{"title":"css3实现文字渐变色动画","url":"/2018/06/27/css3实现文字渐变色动画/","content":"\n![](//blogimg.jakeyu.top/css3实现文字渐变色动画/Untitled.gif)\n\n<!--more-->\n\n利用css3`background-clip`属性：\n\nbackground-clip: border-box || padding-box || context-box || no-clip || text\n\n```html\n<div class=\"title\">彩蛋不只是结尾才有</div>\n```\n\n```css\n.title {\n  font-size: 16px;\n  background-image: -webkit-linear-gradient(90deg, #4e17df, #fb6bea 25%, #4e17df 50%, #fb6bea 75%, #4e17df);\n  -webkit-text-fill-color: transparent;\n  -webkit-background-clip: text;\n  background-size: 100% 600%;\n  animation: title 10s linear infinite;\n}\n\n@keyframes title {\n  0% {\n    background-position: 0 0;\n  }\n\n  100% {\n    background-position: 0 -300%;\n  }\n}\n```\n","tags":["CSS"],"categories":["前端"]},{"title":"Android微信真机联调","url":"/2018/06/05/Android微信真机联调/","content":"\n![](//blogimg.jakeyu.top/Android微信真机联调/unnamed.png)\n\n<!--more-->\n\n## chrome开发者工具调试\n\n1. 使用微信打开 `http://debugx5.qq.com`\n2. 在打开的网页中选择 【信息】->【TBS settings】，勾选 【是否打开 TBS 内核 Inspector 调试功能】\n![](//blogimg.jakeyu.top/Android微信真机联调/WechatIMG8.png)\n3. 重启微信\n4. 开启安卓开发者调试工具，打开USB调试\n5. 使用chrome打开 `chrome://inspect`\n\n<div class=\"swiper\">\n![](//blogimg.jakeyu.top/Android微信真机联调/Jietu20180605-171919.png)\n![](//blogimg.jakeyu.top/Android微信真机联调/Jietu20180605-172348.png)\n</div>\n\n## TBS Studio\n\n[官方文档](http://bbs.mb.qq.com/thread-1416936-1-1.html)\n","tags":["工具"],"categories":["工具"]},{"title":"NexT v5.1.4 进阶配置","url":"/2018/06/04/NexT v5.1.4 进阶配置/","content":"\n![](//blogimg.jakeyu.top/swiper内容超出纵向滚动/big.jpg)\n\n<!--more-->\n\n## 添加swiper\n\n### demo\n\n[https://i.jakeyu.top/2018/06/03/mac%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86/#%E6%88%AA%E5%9B%BE](https://i.jakeyu.top/2018/06/03/mac%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86/#%E6%88%AA%E5%9B%BE)\n\n### 配置\n\n编辑主题配置文件`/themes/next/_config.ylm`，在vendors下面添加：\n\n```yml\n# swiper version 4.3.2\n# http://www.swiper.com.cn/\nswiper_css: //cdnjs.loli.net/ajax/libs/Swiper/4.3.2/css/swiper.min.css\nswiper_js: //cdnjs.loli.net/ajax/libs/Swiper/4.3.2/js/swiper.min.js\n```\n\n编辑`/themes/next/layout/_partials/head.swig`，添加：\n\n```html\n<link rel=\"stylesheet\" href=\"{{ theme.vendors.swiper_css }}\">\n```\n\n新建`/themes/next/layout/_third-party/swiper/swiper.swig`\n\n```swig\n<script type=\"text/javascript\" src=\"{{ theme.vendors.swiper_js }}\"></script>\n```\n\n编辑`/themes/next/layout/_layout.swig`，添加：\n\n```swig\n.......\n{% include '_scripts/boostrap.swig' %}\n{% include '_third-party/swiper/swiper.swig' %}\n{% include '_third-party/comments/index.swig' %}\n{% include '_third-party/search/index.swig' %}\n.......\n```\n\n新建`/themes/next/source/css/_common/components/third-party/swiper.styl`\n\n```styl\n.swiper{\n  position: relative;\n  overflow: hidden;\n}\n```\n\n编辑`/themes/next/source/css/_common/components/third-party/third-party.styl`，添加：\n\n```styl\n.......\n@import \"busuanzi-counter\";\n@import \"swiper\";\n@import \"algolia-search\" if hexo-config('algolia_search.enable');\n.......\n```\n\n编辑`/themes/next/source/js/src/util.js`，添加：\n\n```js\nNexT.utils = NexT.$u = {\n  swiper: function() {\n    $('.swiper').each(function(index,item){\n      var _ = $(item)\n      var wapper = $('<div class=\"swiper-wrapper\"></div>')\n      _.addClass('swiper-' + (index+1))\n      _.append('<div class=\"swiper-pagination\"></div><div class=\"swiper-button-prev\"></div><div class=\"swiper-button-next\"></div>')\n      _.find('img').each(function (index,item) {\n        wapper.append($('<div class=\"swiper-slide\"></div>').append(item))\n      })\n      _.prepend(wapper)\n      _.find('br').remove()\n\n      new Swiper('.swiper-' + (index + 1), {\n      \tautoHeight: true,\n        preloadImages: true,\n        loop : true,\n        pagination: {\n          el: '.swiper-pagination',\n        },\n        navigation: {\n          nextEl: '.swiper-button-next',\n          prevEl: '.swiper-button-prev',\n        },\n        mousewheel: true,\n      })\n    })\n  },\n  /**\n   * Wrap images with fancybox support.\n   */\n  wrapImageWithFancyBox: function () {\n  .......\n```\n\n编辑`/themes/next/source/js/src/bootstrap.js`，添加：\n\n```js\n......\nNexT.utils.swiper()\nCONFIG.fancybox && NexT.utils.wrapImageWithFancyBox();\n......\n```\n\n注意：一定要在`CONFIG.fancybox && NexT.utils.wrapImageWithFancyBox();`前面添加\n\n### 写作\n\n```markdown\n<div class=\"swiper\">\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180604-141733.png)\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180604-141841.png)\n</div>\n```\n\n## 添加运行时间\n\n### 配置\n\n编辑`/themes/next/source/css/_mixins/base.styl`，添加\n\n```css\n@media (max-width: 767px) {\n  .since-line {\n    display: none;\n  }\n  #since {\n    display: block;\n  }\n}\n```\n\n编辑`/themes/next/layout/_layout.swig`，添加：\n\n```swig\n<footer id=\"footer\" class=\"footer\">\n  <div class=\"footer-inner\">\n    {% include '_partials/footer.swig' %}\n    {% include '_third-party/analytics/analytics-with-widget.swig' %}\n    {% block footer %}{% endblock %}\n    <span class=\"post-meta-divider since-line\">|</span>\n    <span id=\"since\"></span>\n  </div>\n</footer>\n```\n\n在`_layout.swig`文件最后添加:\n\n```js\n  <script type=\"text/javascript\">\n    function show_date_time () {\n      window.setTimeout(function () {\n        show_date_time();\n      }, 1000);\n      var BirthDay = new Date(2016,8,25);\n      var today = new Date();\n      var timeold = (today.getTime() - BirthDay.getTime());\n      var msPerDay = 24 * 60 * 60 * 1000;\n      var e_daysold = timeold / msPerDay;\n      var daysold = Math.floor(e_daysold);\n      var e_hrsold = (e_daysold - daysold) * 24;\n      var hrsold = Math.floor(e_hrsold);\n      var e_minsold = (e_hrsold - hrsold) * 60;\n      var minsold = Math.floor((e_hrsold - hrsold) * 60);\n      var seconds = Math.floor((e_minsold - minsold) * 60);\n      $('#since').html(daysold + \"天\" + hrsold + \"小时\" + minsold + \"分\" + seconds + \"秒\");\n    }\n    show_date_time();\n  </script>\n```\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"mac好用的软件整理","url":"/2018/06/03/mac好用的软件整理/","content":"\n![](//blogimg.jakeyu.top/mac好用的软件整理/bijibendiannaotupian5.jpeg)\n\n<!--more-->\n\n先粗略写一下，后面详细说明\n\n{% note danger %} 如果点击app store地址打开错误，请关闭电脑代理再打开 {% endnote %}\n\n# 开发\n\n## iHosts\n\n[app store 地址](https://itunes.apple.com/cn/app/ihosts-%E7%BC%96%E8%BE%91%E7%A5%9E%E5%99%A8/id1102004240?mt=12)\n\nhost管理工具，随时快捷键呼出，呼出位置是鼠标所在位置。切换配置过得代理\n\n<video src=\"//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180604-131614-HD.mp4\" controls=\"controls\">Your browser does not support the video tag.</video>\n\n## iTerm2 + Oh My ZSH\n\n[https://www.iterm2.com/](https://www.iterm2.com/)\n[http://ohmyz.sh/](http://ohmyz.sh/)\n\n终端神器\n\n## go2Shell\n\n[http://zipzapmac.com/go2shell](http://zipzapmac.com/go2shell)\n\n在当前文件夹打开终端\n\n<video src=\"//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180604-131015.mp4\" controls=\"controls\">\nYour browser does not support the video tag.\n</video>\n\n## postman\n\n[https://www.getpostman.com/](https://www.getpostman.com/)\n\n功能强大的网页调试与发送网页HTTP请求的工具。\n\n## sourcetree\n\n[https://www.sourcetreeapp.com/](https://www.sourcetreeapp.com/)\n\ngit图形管理\n\n## gitter\n\n[https://gitter.im/vuejs/vue](https://gitter.im/vuejs/vue)\n\nGitter是GitHub存储库的开发人员和用户的即时通讯聊天室系统。\n\n## Medis\n\n[https://github.com/luin/medis](https://github.com/luin/medis)\n\nredis 数据库客户端\n\n## Studio 3T\n\n[https://studio3t.com/](https://studio3t.com/)\n\nmongodb 数据库客户端，个人用户免费\n\n## Cyberduck\n\n[https://cyberduck.io/](https://cyberduck.io/)\n\nCyberduck is a libre server and cloud storage browser for Mac and Windows with support for FTP, SFTP, WebDAV, Amazon S3, OpenStack Swift, Backblaze B2, Microsoft Azure & OneDrive, Google Drive and Dropbox.\n\n## ForkLift\n\n[app store](https://itunes.apple.com/cn/app/forklift-file-manager-and-ftp-sftp-webdav-amazon-s3-client/id412448059?mt=12)\n\n FTP + SFTP + WebDAV + Amazon s3 客户端\n\n## charles\n\n[https://www.charlesproxy.com/](https://www.charlesproxy.com/)\n\nmac http 代理、抓包等工具\n\n# 笔记\n\n## Bear\n\n[http://www.bear-writer.com/](http://www.bear-writer.com/)\n\n高颜值、高效率的写作工具\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180604-133443.png)\n\n## 奇妙清单\n\n[https://www.wunderlist.com/zh/](https://www.wunderlist.com/zh/)\n\n记录待办事项，并可以设置提醒\n\n和`Bear`各有优势。`Bear`如果要和其他设备同步需要付费，`奇妙清单`是免费的。所以工作的时候我选择`Bear`，因为工作离不开电脑。平时自己的项目或者记录要做的时用`奇妙清单`，随时可以添加，因为idea转瞬即逝，即便没有电脑也可以使用手机添加\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180604-133607.png)\n\n# 图片\n\n## imageOptim\n\n[https://imageoptim.com/mac](https://imageoptim.com/mac)\n\n图片压缩\n\n## PicU\n\n[https://github.com/chenxtdo/UPImageMacApp](https://github.com/chenxtdo/UPImageMacApp)\n\n七牛图片上传\n\n# 视频\n\n## IINA\n\n[https://lhc70000.github.io/iina/zh-cn/](https://lhc70000.github.io/iina/zh-cn/)\n\n支持全格式、颜值很高的视频播放器，\n\n# 工具\n\n## Haste\n\n[https://itunes.apple.com/cn/app/haste-quick-web-search/id1175250324?mt=12](https://itunes.apple.com/cn/app/haste-quick-web-search/id1175250324?mt=12)\n\nHaste 是一款一站式，大撒网式搜索工具，当你双击 ⌘  键两次后会自动弹出搜索框，输入关键目标词，按回车键即可在包括主流搜索引擎在内的所有互联网网站上进行目标搜索。\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20181004-172333@2x.png)\n\n## OmniDiskSweeper\n\n[https://www.omnigroup.com/more/](https://www.omnigroup.com/more/)\n\n清理电脑神器\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180815-221430@2x.png)\n\n## iStat Menus\n\n[https://bjango.com/mac/istatmenus/](https://bjango.com/mac/istatmenus/)\n\n系统监控\n\n## yomail\n\n[http://www.yomail.com/](http://www.yomail.com/)\n\n邮箱客户端\n\n## Maipo\n\n[https://weiboformac.sinaapp.com/](https://weiboformac.sinaapp.com/)\n\n微博客户端\n\n## Tickeys\n\n[官网](http://www.yingdev.com/projects/tickeys)\n\n打字机械音效声音模拟器\n\n## Bartender\n\n[https://www.macbartender.com/](https://www.macbartender.com/)\n\n图标整理\n\n## NameChanger\n\n[官网](https://mrrsoftware.com/namechanger/?utm_source=toolstouse.github.io)\n\n批量修改文件名\n\n## SiteSucker\n\n[http://ricks-apps.com/](http://ricks-apps.com/)\n\n站点文件爬取\n\n## iText\n\n[app store](https://itunes.apple.com/cn/app/itext-ocr-%E8%AF%86%E5%88%AB%E5%9B%BE%E7%89%87%E4%B8%AD%E7%9A%84%E6%96%87%E5%AD%97/id1314980676?mt=12)\n\n图片翻译成文字\n\n## magnet\n\n[app store](https://itunes.apple.com/cn/app/magnet/id441258766?mt=12)\n\n调整应用窗口大小\n\n## cakebrew\n\n[https://www.cakebrew.com/](https://www.cakebrew.com/)\n\nbrew安装的软件管理\n\n## The Unarchiver\n\n[app store](https://itunes.apple.com/cn/app/the-unarchiver/id425424353?mt=12)\n\n功能强大的解压工具\n\n## Keka\n\n[https://www.keka.io/en/](https://www.keka.io/en/)\n\n这款软件 app store 售价为 ￥12，而官网下载是免费的。\n主要用于压缩，而解压功能远不如 [The Unarchiver](#The-Unarchiver) 强大\n\n## macDown\n\n[https://macdown.uranusjr.com/](https://macdown.uranusjr.com/)\n\n简单好用的markdow编辑工具\n\n## 截图\n\n[app store](https://itunes.apple.com/cn/app/%E6%88%AA%E5%9B%BE-jietu-%E5%BF%AB%E9%80%9F%E6%A0%87%E6%B3%A8-%E4%BE%BF%E6%8D%B7%E5%88%86%E4%BA%AB%E7%9A%84%E6%88%AA%E5%B1%8F%E5%B7%A5%E5%85%B7/id1059334054?mt=12)\n\n截图功能包括区域截图／窗口截图／全屏截图／倒计时截图／录制屏幕，保存可自定义选择图片和视频质量\n\n<div class=\"swiper\">\n![](//blogimg.jakeyu.top/mac好用的软件整理/314x0w.jpg)\n![](//blogimg.jakeyu.top/mac好用的软件整理/314x0w1.jpg)\n![](//blogimg.jakeyu.top/mac好用的软件整理/314x0w2.jpg)\n![](//blogimg.jakeyu.top/mac好用的软件整理/314x0w3.jpg)\n![](//blogimg.jakeyu.top/mac好用的软件整理/314x0w4.jpg)\n</div>\n\n## LICEcap\n\n[官网](https://www.cockos.com/licecap/)\n\nLICEcap 是一款屏幕录制工具，支持导出 GIF 动画图片格式，轻量级、使用简单，录制过程中可以随意改变录屏范围。\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180627-174341@2x.png)\n\nLICEcap 非常轻量级，安装包不到 500KB。运行后会以窗口的方式显示在桌面，拖动选取一个合适的大小范围，点击 Record 选取保存路径就开始录屏了。LICEcap 在录屏过程中可以随时拖动窗口改变录屏范围，Stop 过后自动保存为 GIF 格式。\n\n## paste\n\n[app store](https://itunes.apple.com/cn/app/paste-2/id967805235?mt=12)\n\n保存复制过的内容\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/paste.png)\n\n## 1password\n\n[app store](https://itunes.apple.com/cn/app/1password-7/id1333542190?mt=12)\n\n保存密码工具，大概每个月28元，但是跟安全相比，很便宜了\n\n## Reeder 3\n\n[app store](https://itunes.apple.com/cn/app/reeder-3/id880001334?mt=12)\n\nRSS等订阅工具\n\n## appcleaner\n\n[https://freemacsoft.net/appcleaner/](https://freemacsoft.net/appcleaner/)\n\n软件卸载\n\n## Sip\n\n[https://sipapp.io/](https://sipapp.io/)\n\n屏幕取色器\n\n## sketch\n\n[https://www.sketchapp.com/](https://www.sketchapp.com/)\n\n轻量，易用的矢量设计工具\n\n### 插件\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180606-095302.png)\n\n## 加速大师\n\n[app store](https://itunes.apple.com/cn/app/%E5%8A%A0%E9%80%9F%E5%A4%A7%E5%B8%88/id1144825078?mt=12)\n\nMac加速大师是一款功能强大的多合一系统优化App，它可以清理Mac多种类型的垃圾文件，优化启动项目，清理无用的app。适合Mac的日常维护，尤其适合于使用多年的旧Mac，性能提升显著。更重要的是它完全免费，绝对值得拥有。\n\n<div class=\"swiper\">\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180606-095457@2x.png)\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180606-095531@2x.png)\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180606-095549@2x.png)\n![](//blogimg.jakeyu.top/mac好用的软件整理/Jietu20180606-095517@2x.png)\n</div>\n\n## handshaker\n\n[app store](https://itunes.apple.com/cn/app/handshaker-%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/id1012930195?mt=12)\n\n在mac上管理安卓手机\n\n## Irvue\n\n[app store](https://itunes.apple.com/cn/app/irvue/id1039633667?mt=12)\n\n自动换壁纸软件,它自动获取 Unsplash 上的高质量无版权图片作为壁纸。在其菜单栏菜单中的 Update interval（更新时间）中可以设置更新间隔，从每半小时到每月都可以设置，也可以选择手动更新。\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/v2-b4315ba434fa712d0cc5d40968a2417d_hd.jpg)\n\n## Unsplash\n\n[app store](https://itunes.apple.com/cn/app/unsplash-wallpapers/id1284863847?mt=12)\n\n作为质量最高的免费无版权图片资源网站之一，Unsplash 一直被众多第三方壁纸应用选为图片来源，而这个高质量的照片网站终于有官方的 Mac 客户端了。Unsplash 的 macOS 客户端设计非常简约，打开应用后它会常驻在菜单栏上，点击图标即可看到当前壁纸缩略图，你可以选择随机更换一张新壁纸、下载原图或在 Unsplash 网站上查看图片。\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/v2-72675cc6687447d4dca5dd15f7d2ac3d_hd.jpg)\n\n# 屏保\n## Aerial\n\n项目地址: [JohnCoates/Aerial: Apple TV Aerial Screensaver for Mac](https://github.com/JohnCoates/Aerial)\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/v2-405866de1e275d972dcff2fab1c527a0_b.gif)\n\n## 极简时钟：Fliqlo\n\n官网: [Fliqlo - The Flip Clock Screensaver](https://fliqlo.com/#about-screensaver)\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/v2-90dd82e5da45361b7b9441ee39077baa_hd.jpg)\n\n## 更简约的时钟：Padbury\n\n官网：[Padbury Clock — A Screen Saver for macOS](http://padbury.me/clock/)\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/v2-4c550cd86d79c21f32d0935fc8bbf42c_hd.jpg)\n\n## Watch Screensaver for OSX\n\n官网: [rasmusnielsen — creative](http://www.rasmusnielsen.dk/applewatch/)\n\n![](//blogimg.jakeyu.top/mac好用的软件整理/v2-3d1b8cffb2c69e0537aacfa3946027d4_b.gif)\n","tags":["mac"],"categories":["mac"]},{"title":"swiper内容超出纵向滚动","url":"/2018/05/28/swiper内容超出纵向滚动/","content":"\n![](//blogimg.jakeyu.top/swiper内容超出纵向滚动/big.jpg)\n\n<!-- more -->\n\n## 打包报错\n\n使用`swiper 4.x`，webpack打包出错\n\n```err\njs/dist/app.js from UglifyJs\nUnexpected token: name (Dom7) [./node_modules/dom7/dist/dom7.modular.js:14,0][js/dist/app.js:24688,6]\n```\n\n最后使用`swiper 3.4.2`解决\n\n## 超出内容滚动\n\n```js\nthis.swiper = new Swiper('#swiper', {\n  direction: 'vertical'\n})\nvar startScroll, touchStart, touchCurrent;\nthis.swiper.slides.on('touchstart', function (e) {\n  startScroll = this.scrollTop;\n  touchStart = e.targetTouches[0].pageY;\n}, true);\nthis.swiper.slides.on('touchmove', function (e) {\n  if (startScroll > 0 && startScroll < this.scrollHeight - this.offsetHeight) {\n    e.stopPropagation();\n  }\n  touchCurrent = e.targetTouches[0].pageY;\n  var touchesDiff = touchCurrent - touchStart;\n  var slide = this;\n  var onlyScrolling =\n        (slide.scrollHeight > slide.offsetHeight) && // allow only when slide is scrollable\n        (\n            (touchesDiff < 0 && startScroll === 0) || // start from top edge to scroll bottom\n            (touchesDiff > 0 && startScroll === (slide.scrollHeight - slide.offsetHeight)) || // start from bottom edge to scroll top\n            (startScroll > 0 && startScroll < (slide.scrollHeight - slide.offsetHeight)) // start from the middle\n        );\n  if (onlyScrolling) {\n    e.stopPropagation();\n  }\n}, true);\n```\n\n## 答案出处\n\n[Unexpected token: name (Dom7) ](https://github.com/JeffreyWay/laravel-mix/issues/1244)\n[超出内容滚动](https://github.com/nolimits4web/Swiper/issues/1467)\n","tags":["前端"],"categories":["前端"]},{"title":"Mac 彻底删除 Atom","url":"/2018/05/17/Mac-彻底删除-Atom/","content":"\n![](//blogimg.jakeyu.top/Mac 彻底删除 Atom/1_JSK29tJmY2hyGS9xDOGkzg.png)\n\n<!--more-->\n\n自从更新到`1.25.0`后，经常崩溃，查到原因[ISSUES](https://github.com/atom/atom/issues/17020)，但是官方还没有解决，所以需要删除Atom，重新安装`1.24.1`。\n\n## 删除所有Package\n\n```sh\nrm -rf ~/.atom/packages\n```\n\n## 彻底卸载Atom\n\n参考: [How to Completely Uninstall Atom for Mac?](https://discuss.atom.io/t/how-to-completely-uninstall-atom-for-mac/9084/34)\n\n```sh\nrm -rf ~/.atom\nrm -rf /usr/local/bin/atom\nrm -rf /usr/local/bin/apm\nrm -rf /Applications/Atom.app\nrm -rf ~/Library/Preferences/com.github.atom.plist\nrm -rf \"~/Library/Application Support/com.github.atom.ShipIt\"\nrm -rf \"~/Library/Application Support/Atom\"\nrm -rf \"~/Library/Saved Application State/com.github.atom.savedState\"\nrm -rf ~/Library/Caches/com.github.atom\nrm -rf ~/Library/Caches/Atom\n```\n","categories":["Mac"]},{"title":"git commit规范 和 Change log","url":"/2018/05/10/git-commit规范-和-Change-log/","content":"\n![](//blogimg.jakeyu.top/git/ITH_Managing-Code-in-GIT.jpg)\n\n<!--more-->\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。\n\n```sh\ngit commit -m \"hello world\"\n```\n\n上面代码的`-m`参数，就是用来指定 commit mesage 的。\n\n如果一行不够，可以只执行`git commit`，就会跳出文本编辑器，让你写多行。\n\n```sh\ngit commit\n```\n\n基本上，你写什么都行（[这里](http://www.commitlogsfromlastnight.com/)，[这里](http://blog.no-panic.at/2014/10/20/funny-initial-git-commit-messages/)和[这里](http://whatthecommit.com/)）。\n\n![](//blogimg.jakeyu.top/git/bg2016010601.png)\n\n但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。\n\n![](//blogimg.jakeyu.top/git/bg2016010602.png)\n\n目前，社区有多种 Commit message 的写法规范。本文介绍[Angular 规范](https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0)（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。\n\n# Commit message 的作用\n\n格式化的Commit message，有几个好处。\n\n1. 提供更多的历史信息，方便快速浏览。\n\n比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。\n\n```sh\ngit log <last tag> HEAD --pretty=format:%s\n```\n\n![](//blogimg.jakeyu.top/git/bg2016010604.png)\n\n2. 可以过滤某些commit（比如文档改动），便于快速查找信息。\n\n比如，下面的命令仅仅显示本次发布新增加的功能。\n\n```sh\ngit log <last release> HEAD --grep feature\n```\n\n3. 可以直接从commit生成Change log。\n\nChange Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。\n\n![](//blogimg.jakeyu.top/git/bg2016010603.png)\n\n# Commit message 的格式\n\n每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。\n\n```\n<type>(<scope>): <subject>\n// 空一行\n<body>\n// 空一行\n<footer>\n```\n\n其中，Header 是必需的，Body 和 Footer 可以省略。\n\n不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。\n\n## Header\n\nHeader部分只有一行，包括三个字段：`type `（必需）、`scope `（可选）和`subject `（必需）。\n\n### type\n\n`type`用于说明 commit 的类别，只允许使用下面7个标识。\n\n* build：影响构建系统或外部依赖项的更改（示例范围：gulp，broccoli，npm）。如果添加某个依赖 A，那可能是`build(npm): add dependenceA`\n* ci：我们的CI配置文件和脚本的更改（示例范围：Travis，Circle，BrowserStack，SauceLabs）\n* feat：新功能（feature）\n* fix：修补bug\n* docs：文档（documentation）\n* style： 不影响代码含义的更改（空格，格式，缺少分号等）\n* perf: 代码更改可提高性能\n* refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n* test：增加测试\n* chore：构建过程或辅助工具的变动\n\n如果`type`为`feat`和`fix`，则该 commit 将肯定出现在 Change log 之中。其他情况（`docs`、`chore`、`style`、`refactor`、`test`）由你决定，要不要放入 Change log，建议是不要。\n\n### scope\n\n`scope`用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n### subject\n\n`subject`是 commit 目的的简短描述，不超过50个字符。\n\n* 以动词开头，使用第一人称现在时，比如change，而不是changed或changes\n* 第一个字母小写\n* 结尾不加句号（.）\n\n## Body\n\nBody 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。\n\n```\nMore detailed explanatory text, if necessary.  Wrap it to\nabout 72 characters or so.\n\nFurther paragraphs come after blank lines.\n\n- Bullet points are okay, too\n- Use a hanging indent\n```\n\n有两个注意点。\n\n> 1. 使用第一人称现在时，比如使用change而不是changed或changes。\n> 2. 应该说明代码变动的动机，以及与以前行为的对比。\n\n## Footer\n\nFooter 部分只用于两种情况。\n\n### 不兼容变动\n\n如果当前代码与上一个版本不兼容，则 Footer 部分以`BREAKING CHANGE`开头，后面是对变动的描述、以及变动理由和迁移方法。\n\n```\nBREAKING CHANGE: isolate scope bindings definition has changed.\n\n    To migrate the code follow the example below:\n\n    Before:\n\n    scope: {\n      myAttr: 'attribute',\n    }\n\n    After:\n\n    scope: {\n      myAttr: '@',\n    }\n\n    The removed `inject` wasn't generaly useful for directives so there should be no code using it.\n```\n\n### 关闭 Issue\n\n如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。\n\n```\nCloses #234\n```\n\n也可以一次关闭多个 issue 。\n\n```\nCloses #123, #245, #992\n```\n\n## Revert\n\n还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。\n\n```\nrevert: feat(pencil): add 'graphiteWidth' option\nThis reverts commit 667ecc1654a317a13331b17617d973392f415f02.\n```\n\nBody部分的格式是固定的，必须写成`This reverts commit <hash>.`，其中的`hash`是被撤销 commit 的 SHA 标识符。\n\n如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的`Reverts`小标题下面。\n\n# commit验证\n\n## commitlint\n\n[commitlint](https://github.com/marionebl/commitlint) 提供了检测 commit 的功能和一些最基础的规则。使用者需要根据这些规则配置出自己的规范。\n\n首先在项目中安装依赖\n\n```sh\nyarn add @commitlint/cli @commitlint/config-conventional --dev\n```\n\n在`package.json`中添加： \n\n```json\n\"commitlint\": {\n  \"extends\": [\n    \"@commitlint/config-conventional\"\n  ],\n  \"rules\": {\n    \"subject-case\": [\n      0\n    ]\n  }\n}\n```\n\n检查`commit`当然是要在每次执行`git commit`的时候，所以我们使用[husky](https://github.com/typicode/husky)\n\n```\nyarn add husky --dev\n```\n\n在`package.json`中添加：\n\n```json\n\"husky\": {\n  \"hooks\": {\n    \"commit-msg\": \"commitlint -e $GIT_PARAMS\"\n  }\n}\n```\n\n## validate-commit-msg\n\n[validate-commit-msg](https://github.com/kentcdodds/validate-commit-msg) 用于检查 Node 项目的 Commit message 是否符合格式。\n\n它的安装是手动的。首先，拷贝下面这个[JS文件](https://github.com/kentcdodds/validate-commit-msg/blob/master/index.js)，放入你的代码库。文件名可以取为`validate-commit-msg.js`。\n\n接着，把这个脚本加入 Git 的 hook。下面是在`package.json`里面使用 [ghooks](http://npm.im/ghooks)，把这个脚本加为`commit-msg`时运行。\n\n```json\n\"config\": {\n    \"ghooks\": {\n      \"commit-msg\": \"./validate-commit-msg.js\"\n    }\n  }\n```\n\n然后，每次`git commit`的时候，这个脚本就会自动检查 Commit message 是否合格。如果不合格，就会报错。\n\n```sh\n$ git add -A\n$ git commit -m \"edit markdown\"\nINVALID COMMIT MSG: does not match \"<type>(<scope>): <subject>\" ! was: edit markdown\n```\n\n# Commitizen\n\n[Commitizen](https://github.com/commitizen/cz-cli)是一个撰写合格 Commit message 的工具。\n\n安装命令如下。\n\n```\nnpm install -g commitizen\n```\n\n然后，在项目目录里，运行下面的命令，使其支持 Angular 的 Commit message 格式。\n\n```\ncommitizen init cz-conventional-changelog --save --save-exact\n```\n\n以后，凡是用到`git commit`命令，一律改为使用`git cz`。这时，就会出现选项，用来生成符合格式的 Commit message。\n\n![](//blogimg.jakeyu.top/git/bg2016010605.png)\n\n# 生成 Change log\n\n如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成（[例1](https://github.com/ajoslin/conventional-changelog/blob/master/CHANGELOG.md)，[例2](https://github.com/karma-runner/karma/blob/master/CHANGELOG.md)，[例3](https://github.com/btford/grunt-conventional-changelog/blob/master/CHANGELOG.md)）。\n\n生成的文档包括以下三个部分。\n\n* New features\n* Bug fixes\n* Breaking changes.\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\n\n[conventional-changelog](https://github.com/conventional-changelog/conventional-changelog) 就是生成 Change log 的工具，运行下面的命令即可。\n\n```\n$ npm install -g conventional-changelog\n$ cd my-project\n$ conventional-changelog -p angular -i CHANGELOG.md -w\n```\n\n上面命令不会覆盖以前的 Change log，只会在`CHANGELOG.md`的头部加上自从上次发布以来的变动。\n\n如果你想生成所有发布的 Change log，要改为运行下面的命令。\n\n```\n$ conventional-changelog -p angular -i CHANGELOG.md -w -r 0\n```\n\n为了方便使用，可以将其写入`package.json`的`scripts`字段。\n\n```json\n{\n  \"scripts\": {\n    \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -w -r 0\"\n  }\n}\n```\n\n以后，直接运行下面的命令即可。\n\n```sh\n$ npm run changelog\n```\n\n# 声明\n\n> 作者： 阮一峰\n> 转载自： [http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n","tags":["工具"],"categories":["工具"]},{"title":"Javascript原生base64编码解码函数btoa(atob)用法","url":"/2018/05/08/Javascript原生base64编码解码函数btoa(atob)用法/","content":"\n`window.btoa`和`window.atob`分别编码与解码`base64 `，它们在现代浏览器中受到广泛的支持。\n\n<!--more-->\n\n## 兼容性\n\n`btoa`和`atob`在除IE之外的浏览器上都能够得到良好的兼容：\n```\nIE：10+\nChrome：4+\nFirefox：2+\nSafari：3.1+\nOpera：11.5+\n```\n\n## 编码base64函数btoa\n提示：函数名中的b表示binary即原始的待编码数据，a表示ASCII，即编码后的结果（base64编码后，就只是纯的ASCII字符），btoa就是将binary的数据转为ASCII字符（串）。\n\n用法：\n```js\nconsole.log(btoa('Hello world!'));//SGVsbG8gd29ybGQh\n```\n\n## 解码base64函数atob\n可以将base64字符串还原成二进制格式（通常是原始的字符串，JavaScript中字符串就是一种序列化的二进制数据）\n\n用法：\n```js\nconsole.log(atob('SGVsbG8gd29ybGQh'));//Hello world!\n```\n\n## 原始数据含非ASCII字符（例如中文）时的处理\n执行下面的代码：\n```js\nbtoa('我是中文');\n```\n会有如下的报错信息：\n```\nUncaught DOMException: Failed to execute ‘btoa’ on ‘Window’: The string to be encoded contains characters outside of the Latin1 range.(…)\n```\n\n说明只能对ASCII字符进行编码，对于中文来说，可以通过下面的方式进行编码：\n```js\nconsole.log(btoa(unescape(encodeURIComponent('我是中文'))));//5oiR5piv5Lit5paH\n```\n\n解码方法：\n```js\nconsole.log(decodeURIComponent(escape(atob('5oiR5piv5Lit5paH'))));//我是中文\n```\n\n> 作者：lyz810\n> 原文：[https://blog.lyz810.com/article/2016/07/javascript-base64-encode-and-decode/](https://blog.lyz810.com/article/2016/07/javascript-base64-encode-and-decode/)\n","tags":["前端"],"categories":["前端"]},{"title":"nodemon热重启","url":"/2018/05/01/nodemon热重启/","content":"\n![](//blogimg.jakeyu.top/nodemon%E7%83%AD%E9%87%8D%E5%90%AF/35731649-652807e8-080e-11e8-88fd-1b2f6d553b2d.png)\n\n<!--more-->\n\n[https://github.com/remy/nodemon](https://github.com/remy/nodemon)\n\n## 本地安装\n\n```sh\nnpm install nodemon --save\n```\n\n## 创建配置文件 `nodemon.json`\n\n```json\n{\n  \"restartable\": \"rs\",\n  \"ignore\": [\n    \"node_modules/\",\n    \"public/**/*.*\"\n  ],\n  \"verbose\": true,\n  \"execMap\": {\n    \"js\": \"node --harmony\"\n  },\n  \"watch\": [\n\n  ],\n  \"env\": {\n    \"NODE_ENV\": \"development\"\n  },\n  \"ext\": \"js json\"\n}\n```\n\n* restartable-设置重启模式\n* ignore-设置忽略文件\n* verbose-设置日志输出模式，true 详细模式\n* execMap-设置运行服务的后缀名与对应的命令\n```json\n{\n\t“js”: “node –harmony”\n}\n```\n* 表示使用 nodemon 代替 node\n* watch-监听哪些文件的变化，当变化的时候自动重启\n* ext-监控指定的后缀文件名\n\n## 运行\n\n```sh\nnodemon app.js\n```\n","tags":["Node"],"categories":["Node"]},{"title":"css扩展语言通过变量声明媒体查询","url":"/2018/04/14/css扩展语言通过变量声明媒体查询/","content":"\n\n<!--more-->\n\n# scss\n\n```scss\n$mobile: 'only screen and (max-device-width: 720px),\nonly screen and (-webkit-min-device-pixel-ratio: 1.5) and (max-width: 720px)';\n\n@media #{$mobile}{\n    font-size: (100vw/7.5);\n}\n```\n\n# Less\n\n```less\n@mobile: ~\"only screen and (max-device-width: 720px), only screen and (-webkit-min-device-pixel-ratio: 1.5) and (max-width: 720px)\";\n\n@media @mobile{\n    font-size: (100vw/7.5);\n}\n```\n\n# postcss\n\n```postcss\n@custom-media --mobile only screen and (max-device-width: 720px),\n                       only screen and (-webkit-min-device-pixel-ratio: 1.5) and (max-width: 720px);\n\n@media (--mobile){\n    font-size: (100vw/7.5);\n}\n```\n","tags":["CSS"],"categories":["前端"]},{"title":"ngixn反向代理报错解决","url":"/2018/03/16/ngixn反向代理报错解决/","content":"今天在写[七牛图床管理](https://github.com/FeddyTeam/qiniu-images-manager)时，使用nginx反向代理，加载文件报错<span style=\"color:red;\">Net::ERR_INCOMPLETE_CHUNKED_ENCODING</span>\n\n<!--more-->\n\n查看nginx日志文件`/usr/local/var/log/nginx/error.log`发现下面这行：\n\n```log\n2018/03/16 15:22:21 [crit] 77033#0: *3361 open() \"/usr/local/var/run/nginx/proxy_temp/7/12/0000000127\" failed (13: Permission denied) while reading upstream, client: 127.0.0.1, server: dev.jakeyu.top, request: \"GET /app.js HTTP/1.1\", upstream: \"http://127.0.0.1:8081/app.js\", host: \"dev.jakeyu.top:8080\", referrer: \"http://dev.jakeyu.top:8080/\"\n```\n\n于是切换到`proxy_temp`所在目录，修改目录用户：\n\n```sh\nchown -R jake ./proxy-temp\n```\n\n完美解决\n","tags":["Nginx"],"categories":["服务器"]},{"title":"移动端fixed和input获取焦点软键盘弹出影响定位的问题","url":"/2018/03/15/移动端fixed和input获取焦点软键盘弹出影响定位的问题/","content":"\n在移动端使用fixed将按钮定位在底部时，当input获取焦点弹出软键盘时，在安卓系统会奖底部的按钮顶上去。效果图：\n\n![](//blogimg.jakeyu.top/%E7%A7%BB%E5%8A%A8%E7%AB%AFfixed%E5%92%8Cinput%E8%8E%B7%E5%8F%96%E7%84%A6%E7%82%B9%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E5%87%BA%E5%BD%B1%E5%93%8D%E5%AE%9A%E4%BD%8D%E7%9A%84%E9%97%AE%E9%A2%98/WechatIMG6.jpeg)\n\n<!--more-->\n\n解决办法：\n\n```js\n        var h = document.body.clientHeight;\n        window.onresize = function(){\n            if (document.body.clientHeight < h) {\n                document.getElementsByClassName('footer')[0].style.display = \"none\";\n            }else{\n                document.getElementsByClassName('footer')[0].style.display = \"block\";\n            }\n        }\n```\n","tags":["前端"],"categories":["前端"]},{"title":"元素旋转90度后居中","url":"/2018/03/11/元素旋转90度后居中/","content":"\n```html\n<div class=\"outer\">\n    <div class=\"inner rotate\">Centered?</div>\n</div>\n```\ndiv.outer是一个窄垂直条。 div.inner旋转90度。我想要文本居中？出现在其容器div.outer中心。不确定div.outer的大小。\n\n\n<p data-height=\"265\" data-theme-id=\"light\" data-slug-hash=\"qodqzq\" data-default-tab=\"css,result\" data-user=\"JakeLaoyu\" data-embed-version=\"2\" data-pen-title=\"qodqzq\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/JakeLaoyu/pen/qodqzq/\">qodqzq</a> by Jake (<a href=\"https://codepen.io/JakeLaoyu\">@JakeLaoyu</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<!--more-->\n\n关键是将顶部和左边的位置设置为50％，然后将transformX和transformY设置为-50％。\n\n```css\n.inner {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n}\n\n.rotate {  \n    transform:  translateX(-50%) translateY(-50%) rotate(-90deg);\n}\n```\n\n\n> 原文地址 [https://codeday.me/bug/20171009/83576.html](https://codeday.me/bug/20171009/83576.html)\n","tags":["前端"],"categories":["前端"]},{"title":"横向视频在手机垂直时全屏播放","url":"/2018/03/08/横向视频在手机垂直时全屏播放/","content":"\n通过监听`window.orientation`，让视频在手机上保持全屏播放\n\n<!--more-->\n\n# HTML\n\n```html\n<div class=\"video-wrap\">\n    <video\n        id=\"video\"\n        controls=\"false\"\n        x5-video-player-type=\"h5\"\n        x5-video-player-fullscreen='true'\n        preload\n        webkit-playsinline=\"true\"\n        playsinline\n        x5-video-orientation=\"landscape\"\n        x5-video-player-type=\"h5\"\n    >\n        <source src=\"//img.dxycdn.com/biz/topic_files/biz/lilai-onconnect-h5/dist/video/video.mp4\" type=\"video/mp4\" />\n    </video>\n</div>\n```\n\n# CSS\n\n```css\n.video-wrap {\n    &.vertical {\n        transform: translateX(-50%) translateY(-50%) rotate(90deg);\n        position: absolute;\n        top: 50%;\n        left: 50%;\n    }\n\n    &.horizontal {\n        width: 100%;\n        height: 100%;\n    }\n}\n\n#video {\n    width: 100%;\n    height: 100%;\n}\n```\n\n# JS\n\n```js\nconst $video = $('.video-wrap')\n\nchangeVideoDirection(window.orientation)\n\n// 监听屏幕旋转\nwindow.addEventListener('orientationchange', function () {\n  setTimeout(function () {\n    changeVideoDirection(window.orientation)\n  }, 300)\n}, false)\n\n/**\n * 视频自动播放\n * @return {[type]} [description]\n */\nexports.videoAutoPlay = function () {\n  const video = document.getElementById('video')\n  video.play()\n  // 兼容微信\n  document.addEventListener('WeixinJSBridgeReady', function () {\n    video.play()\n  }, false)\n\n  video.addEventListener('ended', function () {\n    location.href = `${location.origin}/services/onconnect/form`\n  })\n}\n\n\n/**\n * 修改视频播放角度\n * @param  {[type]} angle 0：竖屏 90：横屏\n * @return {[type]}       [description]\n */\nfunction changeVideoDirection (angle) {\n  if(angle == 0) {\n    $video.removeClass('horizontal')\n    $video.addClass('vertical')\n    let clientW = document.body.clientWidth\n    let clientH = document.body.clientHeight\n    $video.width(Math.max(clientW, clientH))\n    $video.height(Math.min(clientW, clientH))\n  }else{\n    $video.removeClass('vertical')\n    $video.addClass('horizontal')\n    $video.width('100%')\n    $video.height('100%')\n  }\n}\n\n```\n","tags":["前端"],"categories":["前端"]},{"title":"ios微信background-attachment失效解决","url":"/2018/03/08/ios微信background-attachment失效解决/","content":"\n```css\nbody:before{\n    content: ' ';\n    position: fixed;\n    z-index: -1;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background: url(\"../images/bg.png?ewrfg\") center no-repeat;\n    background-size: 100% 100%;\n}\n```\n","tags":["前端"],"categories":["前端"]},{"title":"nth-child用法","url":"/2018/02/22/nth-child用法/","content":"\n`nth-child`是个神奇的东西，但是总会忘记一些常用的用法。\n\n<!--more-->\n\n## :nth-child(2)\n选取第几个标签，“2可以是你想要的数字”\n\n```css\nul li:nth-child(2){background:#090}\n```\n\n## :nth-child(n+4)\n选取大于等于4标签，“n”表示从整数，下同\n\n```css\nul li:nth-child(n+4){background:#090}\n```\n\n## :nth-child(-n+4)\n选取小于等于4标签\n\n```css\nul li:nth-child(-n+4){background:#090}\n```\n\n## :nth-child(2n)\n选取偶数标签，2n也可以是even\n\n```css\nul li:nth-child(2n){background:#090}\n```\n\n## :nth-child(2n-1)\n选取奇数标签，2n-1可以是odd\n\n```css\nul li:nth-child(2n-1){background:#090}\n```\n\n## :nth-child(3n+1)\n自定义选取标签，3n+1表示“隔二取一”\n\n```css\nul li:nth-child(3n+1){background:#090}\n```\n\n## :last-child\n选取最后一个标签\n\n```css\nul li:last-child{background:#090}\n```\n\n## :nth-last-child(3)\n选取倒数第几个标签,3表示选取第3个\n\n```css\nul li:nth-last-child(3){background:#090}\n```\n","tags":["前端"],"categories":["前端"]},{"title":"canvas多指触控[转]","url":"/2017/09/18/canvas多指/","content":"\n\n![](//blogimg.jakeyu.top/2017091815057255674792.png)\n<!--more-->\n\n\n> **原文：**[触摸事件](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch_events)\n\n为了给触摸界面提供有力支持, 触摸事件提供了响应用户对触摸屏或者触摸板上操作的能力.\n\n# 定义\n\n## 平面\n\n对触摸敏感的平面\n\n## 触摸点\n\n平面上的一个接触点. 有可能是手指 (或者 肘部, 耳朵, 鼻子, 或任何东西, 不过大多数情况下是手指) 或者触摸笔.\n\n# 接口\n\n## [TouchEvent](https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent)\n\n代表当触摸行为在平面上变化的时候发生的事件.\n\n## [Touch](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch)\n\n代表用户与触摸平面间的一个接触点.\n\n## [TouchList](https://developer.mozilla.org/zh-CN/docs/Web/API/TouchList)\n\n\n代表一系列的Touch; 一般在用户多个手指同时接触触控平面时使用这个接口.\n\n## [DocumentTouch](https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentTouch)\n\n包含了一些创建[Touch](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch)对象与[TouchList](https://developer.mozilla.org/zh-CN/docs/Web/API/TouchList)对象的便捷方法.\n\n# 例子\n\n这个例子可跟踪多点同时触控,允许用户用多指触摸的方式在`<canvas>`元素上画图. 这个例子只会在支持触摸事件的浏览器下生效.\n\n> **注意**: 我们用“手指”表示用户与触摸平面进行交互,除此以外也可以是触摸笔或者其他方式.\n\n## 创建 canvas\n\n```html\n<canvas id=\"canvas\" width=\"600\" height=\"600\" style=\"border:solid black 1px;\">\n  Your browser does not support canvas element.\n</canvas>\n<br>\n<button onclick=\"startup()\">Initialize</button>\n<br>\nLog: <pre id=\"log\" style=\"border: 1px solid #ccc;\"></pre>\n```\n\n## 设置事件处理器\n\n当页面加载时，下面的`startup()`函数本应通过我们在`<body>`元素上设置的`onload` 属性而被*触发，但是由于MND在线案例系统限制，我们在这里通过一个按钮的点击事件触发。*\n\n```js\nfunction startup() {\n  var el = document.getElementsByTagName(\"canvas\")[0];\n  el.addEventListener(\"touchstart\", handleStart, false);\n  el.addEventListener(\"touchend\", handleEnd, false);\n  el.addEventListener(\"touchmove\", handleMove, false);\n  log(\"initialized.\")\n}\n```\n\n这里给我们的`<canvas>`元素设置了所有触摸相关的事件监听器，因此当事件触发时我们就可以处理它们.\n\n## 跟踪新的触摸行为\n\n我们将检测正在进行的触摸事件\n\n```js\nvar ongoingTouches = new Array();\n```\n\n当一个 `touchstart` 事件被触发, 代表在触摸板上一个发生了一个新的触摸行为,下面的 `handleStart()`函数会被调用.\n\n```js\nfunction handleStart(evt) {\n  evt.preventDefault();\n  var el = document.getElementsByTagName(\"canvas\")[0];\n  var ctx = el.getContext(\"2d\");\n  var touches = evt.changedTouches;\n\n  for (var i=0; i<touches.length; i++) {\n    ongoingTouches.push(touches[i]);\n    var color = colorForTouch(touches[i]);\n    ctx.fillStyle = color;\n    ctx.fillRect(touches[i].pageX-2, touches[i].pageY-2, 4, 4);\n  }\n}\n```\n\n [event.preventDefault()](https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault)阻止了浏览器继续处理触摸事件 (这同样也阻止了鼠标事件的传递). 而后我们拿到事件上下文，从事件的[TouchEvent.changedTouches](https://developer.mozilla.org/zh-CN/docs/Web/API/TouchEvent/changedTouches) 属性中拿到改变中的触摸点列表.\n\n 我们遍历上述的点列表[Touch](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch) 并把这些点压入一个代表当前活动的触摸点组成的数组中，以这些点为起点画矩形; 我们设置线条宽度为四像素，所以最终我们画出来的是一个四乘四的正方形。\n\n##  当触摸移动时绘制\n\n每当一根或者几根手指在触摸平面上移动时, `touchmove` 事件被触发, 随之`handleMove()`函数被调用.此例子中，这个函数更新了上面保存过的触摸点信息，之后，从触摸点之前的位置到现在的位置之间绘制直线，且对每个点都进行这样的操作.\n\n```js\nfunction handleMove(evt) {\n  evt.preventDefault();\n  var el = document.getElementsByTagName(\"canvas\")[0];  \n  var ctx = el.getContext(\"2d\");\n  var touches = evt.changedTouches;\n\n  ctx.lineWidth = 4;\n\n  for (var i=0; i<touches.length; i++) {\n    var color = colorForTouch(touches[i]);\n    var idx = ongoingTouchIndexById(touches[i].identifier);\n\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);\n    ctx.lineTo(touches[i].pageX, touches[i].pageY);\n    ctx.closePath();\n    ctx.stroke();\n    ongoingTouches.splice(idx, 1, touches[i]);  // swap in the new touch record\n  }\n}\n```\n\n这里同样遍历了所有被改变的触摸点,但为了决定每次新触摸要绘制的线段的起点，它也查询了我们先前缓存的触摸信息数组。这是通过查找每个触摸的  [Touch.identifier](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier) 属性来做到的.这个属性是个整数，每次触摸都不同，在触摸事件期间手指一直接触表面，这个属性保持不变。\n\n这样我们就可以拿到先前每个触摸的坐标点，之后以适当的上下文方法将两点连接起来，并绘制线段。\n\n当这条线绘制完毕后我们调用 [Array.splice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice),把`ongoingTouches`数组中之前的触摸点信息用现在的信息来代替.\n\n## 对触摸行为的结束进行处理\n\n当用户从触摸表面抬起手指时，`touchend` 事件被触发. 类似的当手指移除`canvas`区域外，我们会得到`touchleave` 事件. 我们利用相同的方式来处理这两种情况，即调用下面的`handleEnd()`函数.这个函数的作用是给每个已经结束的触摸绘制最后一段线段，同时把这个触摸点从进行中的触摸列表数组中移除.\n\n```js\nfunction handleEnd(evt) {\n  evt.preventDefault();\n  var el = document.getElementsByTagName(\"canvas\")[0];  \n  var ctx = el.getContext(\"2d\");\n  var touches = evt.changedTouches;\n\n  ctx.lineWidth = 4;\n\n  for (var i=0; i<touches.length; i++) {\n    var color = colorForTouch(touches[i]);\n    var idx = ongoingTouchIndexById(touches[i].identifier);\n\n    ctx.fillStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(ongoingTouches[i].pageX, ongoingTouches[i].pageY);\n    ctx.lineTo(touches[i].pageX, touches[i].pageY);\n    ongoingTouches.splice(i, 1);  // remove it; we're done\n  }\n}\n```\n\n这个函数跟之前的函数很类似，唯一的区别是我们调用[Array.splice()](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice)时, 在正在进行的触摸列表中，我们仅仅将一个触摸的标识移除，而不再添加这个触摸新的信息。结果就是我们停止跟踪这个触摸点。\n\n## 处理取消触摸事件\n\n如果用户的手指滑出触摸区域，滑入浏览器界面时，或者触摸需要取消时，`touchcancel` 事件会被传递,下面的 `handleCancel()` 函数会被触发.\n\n```js\nfunction handleCancel(evt) {\n  evt.preventDefault();\n  var touches = evt.changedTouches;\n\n  for (var i=0; i<touches.length; i++) {\n    ongoingTouches.splice(i, 1);  // remove it; we're done\n  }\n}\n```\n\n因为我们的目的是立刻结束触摸，所以我们直接从正在进行的触摸列表中删除，不会绘制最后一部分线段。\n\n## 便捷函数\n\n这个例子使用了两个很方便的函数，有必要简单了解下这两个函数，会有助于更加清楚的理解代码剩余的部分。\n\n## 为每次触摸选择一个颜色\n\n为了让每次触摸绘制的内容看起来不相同，colorForTouch()函数用来根据每一次触摸所独有的标识来取颜色 . 这个标识的范围通常是0到所有活动触摸对象的数量-1. 而基本不可能会有人用多于16根手指去使用这个demo,我们直接把这种情况转为灰色。\n\n```js\nfunction colorForTouch(touch) {\n  var id = touch.identifier;\n  id = id.toString(16); // make it a hex digit\n  return \"#\" + id + id + id;\n}\n```\n\n这个函数返回一个字符串，可以用在 `<canvas>` 函数中用来设置绘制颜色. 举例来说，若触摸的标识符`Touch.identifier`为10, 转换后的字符串为 \"#aaa\".\n\n## 查询正在进行的触摸行为\n\n下面的`ongoingTouchIndexById()` 函数通过遍历查找数组 `ongoingTouches` 来找到与给定标识相匹配的触摸行为，之后返回这个触摸行为在数组中的下标。\n\n```js\nfunction ongoingTouchIndexById(idToFind) {\n  for (var i=0; i<ongoingTouches.length; i++) {\n    var id = ongoingTouches[i].identifier;\n\n    if (id == idToFind) {\n      return i;\n    }\n  }\n  return -1;    // not found\n}\n```\n","tags":["前端"],"categories":["前端"]},{"title":"兼容前后端共用模块代码(摘自《深入浅出Node.js》)","url":"/2017/09/14/兼容前后端共用模块代码/","content":"\n## 模块的侧重点\n\n前后端JavaScript分别搁置在HTTP的两端，它们扮演的角色并不同。浏览器端的JavaScript需要经历从同一个服务器端分发到多个客户端执行，而服务器端JavaScript则是相同的代码需要多次执行。前者的瓶颈在于带宽，后者的瓶颈则在于CPU和内存等资源。前者需要通过网络加载代码，后者从磁盘中加载，两者的加载速度不在一个数量级上。\n\n<!--more-->\n\n纵观Node的模块引入过程，几乎全都是同步的。尽管与Node强调异步的行为有些相反，但它是合理的。但是如果前端模块也采用同步的方式来引入，那将会在用户体验上造成很大的问题。UI在初始化过程中需要花费很多时间来等待脚本加载完成。\n\n鉴于网络的原因，CommonJS为后端JavaScript制定的规范并不完全适合前端的应用场景。经过一段争执之后，AMD规范最终在前端应用场景中胜出。它的全称是Asynchronous Module Definition，即是“异步模块定义”，详见[https://github.com/amdjs/amdjs-api/wiki/AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)。除此之外，还有玉伯定义的CMD规范。\n\n\n## AMD规范\nAMD规范是CommonJS模块规范的一个延伸，它的模块定义如下：\n\n```js\ndefine(id?, dependencies?, factory);\n```\n\n它的模块`id`和`依赖`是可选的，与Node模块相似的地方在于`factory`的内容就是实际代码的内容。下面的代码定义了一个简单的模块：\n\n```js\ndefine(function() {\n  var exports = {};\n  exports.sayHello = function() {\n    alert('Hello from module: ' + module.id);\n  };\n  return exports;\n});\n```\n\n不同之处在于AMD模块需要用`define`来明确定义一个模块，而在Node实现中是隐式包装的，它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现导出。\n\n## CMD规范\n\nCMD规范由国内的玉伯提出，与AMD规范的主要区别在于定义模块和依赖引入的部分。AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中：\n\n```js\ndefine(['dep1', 'dep2'], function (dep1, dep2) {\n  return function () {};\n});\n```\n\n与AMD模块规范相比，CMD模块更接近于Node对CommonJS规范的定义：\n```js\ndefine(factory);\n```\n在依赖部分，CMD支持动态引入，示例如下：\n\n```js\ndefine(function(require, exports, module) {\n  // The module code goes here\n});\n```\n\n`require、exports`和`module`通过形参传递给模块，在需要依赖模块时，随时调用`require()`引入即可。\n\n## 兼容多种模块规范\n\n为了让同一个模块可以运行在前后端，在写作过程中需要考虑兼容前端也实现了模块规范的环境。为了保持前后端的一致性，类库开发者需要将类库代码包装在一个闭包内。以下代码演示如何将`hello()`方法定义到不同的运行环境中，它能够兼容`Node`、`AMD`、`CMD`以及常见的浏览器环境中：\n\n```js\n;(function (name, definition) {\n  // 检测上下文环境是否为AMD或CMD\n  var hasDefine = typeof define === 'function',\n    // 检查上下文环境是否为Node\n    hasExports = typeof module !== 'undefined' && module.exports;\n\n  if (hasDefine) {\n    // AMD环境或CMD环境\n    define(definition);\n  } else if (hasExports) {\n    // 定义为普通Node模块\n    module.exports = definition();\n  } else {\n    // 将模块的执行结果挂在window变量中，在浏览器中this指向window对象\n    this[name] = definition();\n  }\n})('hello', function () {\n  var hello = function () {};\n  return hello;\n});\n```\n\n> 摘自《深入浅出Node.js》: 2.7　前后端共用模块\n","tags":["JS"],"categories":["Node"]},{"title":"express处理views中HTML和ejs共存","url":"/2017/08/11/express处理views中HTML和ejs共存/","content":"\n<!--more-->\n\n配置模版渲染\n\n```js\napp.set('views', path.join(__dirname, 'views'));\napp.engine('html', require('ejs').renderFile)\napp.set('view engine', 'ejs');\n```\n\n之后可以再`html`文件中使用`ejs`语法渲染变量\n\n```js\nres.render('index.html', {\n    title: '哦'\n  })\n```\n","tags":["Node"],"categories":["Node"]},{"title":"mysql数据库导入导出","url":"/2017/07/12/mysql数据库导入导出/","content":"\n\n![](//blogimg.jakeyu.top/20170712149982499685082.png)\n<!--more-->\n\n# 导出所有库\n## 系统命令行\n```sh\nmysqldump -u username -p password --all-databases > all.sql\n```\n\n# 导入所有库\n## mysql命令行\n```sh\nmysql>source all.sql;\n```\n\n# 导出某些库\n## 系统命令行\n```sh\nmysqldump -u username -p password --databases db1 db2 > db1db2.sql\n```\n\n# 导入某些库\n## mysql命令行\n```sh\nmysql>source db1db2.sql;\n```\n\n# 导入某个库\n## 系统命令行\n```sh\nmysql -u username -p password db1 < db1.sql;\n```\n\n## mysql命令行\n```sh\nmysql>source db1.sql;\n```\n\n# 导出某些数据表\n## 系统命令行\n```sh\nmysqldump -u username -p password db1 table1 table2 > tb1tb2.sql\n```\n\n# 导入某些数据表\n## 系统命令行\n```sh\nmysql -u username -p password db1 < tb1tb2.sql\n```\n\n## mysql命令行\n```sh\nmysql>user db1;\nmysql>source tb1tb2.sql;\n```\n","tags":["服务器"],"categories":["服务器"]},{"title":"使用Yeoman定制前端脚手架","url":"/2017/06/28/使用Yeoman-Generators制作脚手架/","content":"\n![](//blogimg.jakeyu.top/20170628149866105196233.png)\n\n<!--more-->\n\n首先附上Yeoman官网：[http://yeoman.io/](http://yeoman.io/)\n\n我制作的前端脚手架：[generator-jake-front](https://github.com/JakeLaoyu/generator-jake-front)\n\n以及我在前端同学的分享会上的分享ppt：[yeoman.key](https://i.jakeyu.top/files/yeoman.key)\n\n如果想快速制作一个脚手架，并且不需要实现特别复杂的定制化，看完这篇文章足够，如果想要实现复杂的功能，需要去查看[官方文档](http://yeoman.io/)。\n\n# 环境\n\n需要安装[Nodejs](https://nodejs.org/zh-cn/)\n\n全局安装需要的工具\n\n```sh\nnpm install -g yo\nnpm install -g generator-generator\n```\n\n# 初始化项目\n\n执行下面命令，执行之前并不需要自己新建文件夹，yo generator会帮助我们建好文件夹\n\n```sh\nyo generator\n```\n\n项目名称自己设置，必须是以`generator-`开头，协议选择`MIT`，在设置了一系列问题之后\n\n\n![](//blogimg.jakeyu.top/2017062814986615489491.jpg)\n\n自动生成如下目录\n\n```\ngenerator-test\n├── LICENSE\n├── README.md\n├── __tests__\n│   └── app.js\n├── generators\n│   └── app\n│       ├── index.js\n│       └── templates\n│           └── dummyfile.txt\n└── package.json\n```\n\n# 配置\n\n`generators/app/templates/`是默认存放文件的目录，把所有模版文件放在这个目录下\n\n`/generators/app/index.js`是`Yeoman`的配置文件，定义如何生成我们的脚手架\n\n## prompting\n\n`Prompts`是`generator`与用户交互的主要方式。`prompt`模块由 [Inquirer.js](https://github.com/SBoudrias/Inquirer.js)提供，你可以参考它的[API](https://github.com/SBoudrias/Inquirer.js)，在可用的提示选项列表。\n\n`prompt`方法是异步的并且返回一个 promise。在你运行下一个任务前去完成它，你需要返回 promise。\n\n```js\nmodule.exports = class extends Generator {\n  prompting() {\n    // Have Yeoman greet the user.\n    this.log(yosay(\n      'Welcome to the awe-inspiring ' + chalk.red('generator-downloads') + ' generator!'\n    ));\n\n    const prompts = [{\n      type: 'confirm',\n      name: 'someAnswer',\n      message: 'Would you like to enable this option?',\n      default: true\n    }];\n\n    return this.prompt(prompts).then(props => {\n      // To access props later use this.props.someAnswer;\n      this.props = props;\n    });\n  }\n};\n```\n\n做一些适当的修改，实现更通用的脚手架。可以查阅[API](http://yeoman.io/generator/)\n\n* `this.appname`: 获取当前文件夹名称\n* `this.user.git.name()`: 获取全局`git`用户名\n* `this.user.git.email()`: 获取全局`git`邮箱\n* `this.github.username()`: 获取`github`用户名\n\n定义对象中的`type`，管理交互方式。使用`input`实现控制台输入。\n\n```js\ntype: 'input',\nname: 'author',\nmessage: 'author',\ndefault: this.user.git.name()\n```\n\n这样便实现了让用户输入作者名称，默认为git全局配置的用户名。然后在其他配置中使用`this.props.author`实现获取用户输入。\n\n## writing\n\n`Generators`在`this.fs`暴露了所有的文件的方法，这是一个实例，[mem-fs editor](https://github.com/sboudrias/mem-fs-editor) - 确保为所有可获得的方法选择[模块文件](https://github.com/sboudrias/mem-fs-editor)。\n\n值得注意的是，通过`this.fs`暴露`commit`，你不应该在你的`generator`去调用它。`Yeoman`在运行循环的冲突阶段结束后，在内部调用它。\n\n### 复制一个模板文件\n\n例如：`./templates/index.html`的文件内容是：\n\n```html\n<html>\n  <head>\n    <title><%= title %></title>\n  </head>\n</html>\n```\n\n然后，我们将使用[copyTpl](https://github.com/sboudrias/mem-fs-editor#copyfrom-to-options)方法去复制作为模板的处理中的文件。`copyTpl`使用的是[ejs](http://ejs.co/) 模板引擎。\n\n```js\nmodule.exports = class extends Generator {\n  writing() {\n    this.fs.copy(\n      this.templatePath('index.html'),\n      this.destinationPath('index.html'),\n      { title: 'Templating with Yeoman' }\n    );\n  }\n};\n```\n\n一旦generator运行成功，`index.html`将会包含：\n\n```html\n<html>\n  <head>\n    <title>Templating with Yeoman</title>\n  </head>\n</html>\n```\n\n`json`也同样适用上面的语法，配置`package.json`文件可以适应不同的项目。\n\n## install\n\n`install`方法设置在文件copy完成之后执行的命令，例如\n\n```js\nmodule.exports = class extends Generator {\ninstall() {\nthis.installDependencies({\n      bower: true,\n      npm: true,\n      yarn: false,\n      callback: function () {\n       this.log('Everything is ready!');\n      }\n    });\n  }\n};\n```\n\n## 测试\n\n由于我们在本地开发，并不知道用起来怎么样，所以可以使用`npm link`命令，相当于在全局安装了此脚手架，然后在新文件夹中执行`yo`，选择脚手架，便可以测试\n\n\n## 发布\n\n`generator-test/package.json`中的`name`要在[https://www.npmjs.com/](https://www.npmjs.com/)没被创建过，才可以发布。\n\n发布需要一个`npm`的账号，如果没有使用`npm adduser`创建；\n\n如果已有账号，运行`npm login`登陆。\n\n在项目根目录下，运行`npm publish`就可以发布了。如果更新后重新发布，注意修改根目录下的`package.json`文件中的版本号。\n\n使用`npm unpublish 包名`命令可以撤销发布，只有在发包的24小时内才允许撤销发布的包。\n","tags":["工具"],"categories":["工具"]},{"title":"node读写Excel","url":"/2017/06/18/node读写Excel/","content":"\nnode 有很多读写excel的模块，这里我只写我所使用的模块。\n\n* xlsx:读取excel\n* excel-export: 导出excel\n\n![](//blogimg.jakeyu.top/20170618149771883564592.png)\n\n<!--more-->\n\n# [xlsx](https://www.npmjs.com/package/xlsx)读取excel文件\n\n## 库中所提及的一些概念\n\n* workbook 对象，指的是整份 Excel 文档。我们在使用 js-xlsx 读取 Excel 文档之后就会获得 workbook 对象。\n* worksheet 对象，指的是 Excel 文档中的表。我们知道一份 Excel 文档中可以包含很多张表，而每张表对应的就是 worksheet 对象。\n* cell 对象，指的就是 worksheet 中的单元格，一个单元格就是一个 cell 对象。\n\n## 它们的关系如下：\n\n```js\n// workbook\n{\n    SheetNames: ['sheet1', 'sheet2'],\n    Sheets: {\n        // worksheet\n        'sheet1': {\n            // cell\n            'A1': { ... },\n            // cell\n            'A2': { ... },\n            ...\n        },\n        // worksheet\n        'sheet2': {\n            // cell\n            'A1': { ... },\n            // cell\n            'A2': { ... },\n            ...\n        }\n    }\n}\n```\n\n## 用法\n\n1. 用 XLSX.read 读取获取到的 Excel 数据，返回 workbook\n2. 用 XLSX.readFile 打开 Excel 文件，返回 workbook\n3. 用 workbook.SheetNames 获取表名\n4. 用 workbook.Sheets[xxx] 通过表名获取表格\n5. 用 worksheet[address]操作单元格\n6. 用XLSX.utils.sheet_to_json针对单个表获取表格数据转换为json格式\n7. 用XLSX.writeFile(wb, 'output.xlsx')生成新的 Excel 文件\n\n\n读取 Excel 文件\n\n```js\nXLSX.read(data, read_opts) //尝试解析数据\nXLSX.readFile(filename, read_opts) //尝试读取文件名和解析。\n```\n\n获取excel中的表\n\n```js\n// 获取 Excel 中所有表名\nvar sheetNames = workbook.SheetNames; // 返回 ['sheet1', 'sheet2',……]\n// 根据表名获取对应某张表\nvar worksheet = workbook.Sheets[sheetNames[0]];\n```\n\n通过 worksheet[address] 来操作表格，以 ! 开头的 key 是特殊的字段。\n\n```js\n// 获取 A1 单元格对象\nlet a1 = worksheet['A1']; // 返回 { v: 'hello', t: 's', ... }\n// 获取 A1 中的值\na1.v // 返回 'hello'\n// 获取表的有效范围\nworksheet['!ref'] // 返回 'A1:B20'\nworksheet['!range'] // 返回 range 对象，{ s: { r: 0, c: 0}, e: { r: 100, c: 2 } }\n// 获取合并过的单元格\nworksheet['!merges'] // 返回一个包含 range 对象的列表，[ {s: { r: 0, c: 0 }, c: { r: 2, c: 1 } } ]\n```\n\n获取 Excel 文件中的表转换为json数据\n\n```js\nXLSX.utils.sheet_to_json(worksheet)  //针对单个表，返回序列化json数据\n```\n\n# excel-export导出excel\n\n```js\nvar excelPort = require('excel-export');\nvar path = require('path')\nexports.write = function(req, res, next) {\n    var datas = req.datas;\n    var conf = {};\n    var filename = 'filename'; //只支持字母和数字命名\n\n\n    conf.cols = [{\n        caption: '学号',\n        type: 'string',\n        width: 20\n    }, {\n        caption: '姓名',\n        type: 'string',\n        width: 40\n    }, {\n        caption: '岗位',\n        type: 'string',\n        width: 200\n    }, {\n        caption: '工时(h)',\n        type: 'string',\n        width: 200\n    }];\n\n\n    var array = [];\n    array = [\n        [13084233, Jake, 图书馆, 20],\n        [13084233, Jake, 图书馆, 20],\n        [13084233, Jake, 图书馆, 20],\n        [13084233, Jake, 图书馆, 20],\n        [13084233, Jake, 图书馆, 20]\n    ];\n\n\n    conf.rows = array;\n    var result = excelPort.execute(conf);\n\n    var random = Math.floor(Math.random() * 10000 + 0);\n\t\n    var uploadDir = path.join(__dirname, '../', '/public/files/')\n    var filePath = uploadDir + filename + random + \".xlsx\";\n\n    fs.writeFile(filePath, result, 'binary', function(err) {\n        if (err) {\n            console.log(err);\n        }\n    });\n}\n```\n","tags":["Node"],"categories":["Node"]},{"title":"杂七杂八","url":"/2017/06/04/杂七杂八/","content":"\n![](//blogimg.jakeyu.top/20170604149657311876282.jpg)\n<!--more-->\n\n# 分解url\n\n```js\n// 分解URL参数\nfunction parseQueryString(url) {\n\tvar obj = {},\n\t\tkeyvalue = [],\n\t\tkey = \"\",\n\t\tvalue = \"\";\n\tvar paraString = url.substring(url.indexOf(\"?\") + 1, url.length).split(\"&\");\n\n\tfor (var i in paraString) {\n\n\t\tkeyvalue = paraString[i].split(\"=\");\n\t\tkey = keyvalue[0];\n\t\tvalue = keyvalue[1];\n\t\tobj[key] = value;\n\t}\n\treturn obj;\n}                                                                                                                            \n```\n\n# 时间转换\n\n```js\nfunction dateConvert(date, format) {\n\tdate = parseInt(date);\n\tvar Udate = new Date(date);\n\tvar Y = Udate.getFullYear(),\n\t\tM = Udate.getMonth() < 10 ? \"0\" + (Udate.getMonth() + 1) : (Udate.getMonth() + 1),\n\t\tD = Udate.getDate() < 10 ? \"0\" + Udate.getDate() : Udate.getDate(),\n\t\th = Udate.getHours(),\n\t\tm = Udate.getMinutes(),\n\t\ts = Udate.getSeconds(),\n\t\tresult;\n\tif (!format) {\n\t\tformat = \"Y/M/D h:m:s\";\n\t}\n\tif (format.indexOf(\"Y\") >= 0) {\n\t\tformat = format.replace(\"Y\", Y);\n\t}\n\tif (format.indexOf(\"M\") >= 0) {\n\t\tformat = format.replace(\"M\", M);\n\t}\n\tif (format.indexOf(\"D\") >= 0) {\n\t\tformat = format.replace(\"D\", D);\n\t}\n\tif (format.indexOf(\"h\") >= 0) {\n\t\tformat = format.replace(\"h\", h);\n\t}\n\tif (format.indexOf(\"m\") >= 0) {\n\t\tformat = format.replace(\"m\", m);\n\t}\n\tif (format.indexOf(\"s\") >= 0) {\n\t\tformat = format.replace(\"s\", s);\n\t}\n\treturn format;\n};\n```\n\n# 返回两个日期之间的日期\n\n```js\n\n// Returns an array of dates between the two dates\nvar getDates = function(startDate, endDate) {\n  var dates = [],\n      currentDate = startDate,\n      addDays = function(days) {\n        var date = new Date(this.valueOf());\n        date.setDate(date.getDate() + days);\n        return date;\n      };\n  while (currentDate <= endDate) {\n    dates.push(currentDate);\n    currentDate = addDays.call(currentDate, 1);\n  }\n  return dates;\n};\n\n// Usage\nvar dates = getDates(new Date(2013,10,22), new Date(2013,11,25));                                                                                                           \ndates.forEach(function(date) {\n  console.log(date);\n});\n```\n\n# 获取某年某月的天数\n\n```js\nfunction getDaysInOneMonth(year, month){  \n  month = parseInt(month, 10);  \n  var d= new Date(year, month, 0);  \n  return d.getDate();  \n}  \n```\n\n# 身份证验证\n\n```js\nfunction checkID(ID) {\n\tif (typeof ID !== 'string') return '非法字符串';\n\tvar city = {\n\t\t11: \"北京\",\n\t\t12: \"天津\",\n\t\t13: \"河北\",\n\t\t14: \"山西\",\n\t\t15: \"内蒙古\",\n\t\t21: \"辽宁\",\n\t\t22: \"吉林\",\n\t\t23: \"黑龙江 \",\n\t\t31: \"上海\",\n\t\t32: \"江苏\",\n\t\t33: \"浙江\",\n\t\t34: \"安徽\",\n\t\t35: \"福建\",\n\t\t36: \"江西\",\n\t\t37: \"山东\",\n\t\t41: \"河南\",\n\t\t42: \"湖北 \",\n\t\t43: \"湖南\",\n\t\t44: \"广东\",\n\t\t45: \"广西\",\n\t\t46: \"海南\",\n\t\t50: \"重庆\",\n\t\t51: \"四川\",\n\t\t52: \"贵州\",\n\t\t53: \"云南\",\n\t\t54: \"西藏 \",\n\t\t61: \"陕西\",\n\t\t62: \"甘肃\",\n\t\t63: \"青海\",\n\t\t64: \"宁夏\",\n\t\t65: \"新疆\",\n\t\t71: \"台湾\",\n\t\t81: \"香港\",\n\t\t82: \"澳门\",\n\t\t91: \"国外\"\n\t};\n\tvar birthday = ID.substr(6, 4) + '/' + Number(ID.substr(10, 2)) + '/' + Number(ID.substr(12, 2));\n\tvar d = new Date(birthday);\n\tvar newBirthday = d.getFullYear() + '/' + Number(d.getMonth() + 1) + '/' + Number(d.getDate());\n\tvar currentTime = new Date().getTime();\n\tvar time = d.getTime();\n\tvar arrInt = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\n\tvar arrCh = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];\n\tvar sum = 0,\n\t\ti, residue;\n\n\tif (!/^\\d{17}(\\d|x)$/i.test(ID)) return '非法身份证';\n\tif (city[ID.substr(0, 2)] === undefined) return \"非法地区\";\n\tif (time >= currentTime || birthday !== newBirthday) return '非法生日';\n\tfor (i = 0; i < 17; i++) {\n\t\tsum += ID.substr(i, 1) * arrInt[i];\n\t}\n\tresidue = arrCh[sum % 11];\n\tif (residue !== ID.substr(17, 1)) return '非法身份证哦';\n\n\treturn city[ID.substr(0, 2)] + \",\" + birthday + \",\" + (ID.substr(16, 1) % 2 ? \" 男\" : \"女\")\n}\n```\n\n\n# 判断是移动端和IE8\n\n```js\nwindow.isMobile = /mobile/i.test(window.navigator.userAgent);\nwindow.isIE8 = /MSIE 8.0/i.test(window.navigator.userAgent);\n```\n\n移动端详细判断\n\n```js\nvar isMobile = {\n        Android: function() {\n            return navigator.userAgent.match(/Android/i);\n        },\n        BlackBerry: function() {\n            return navigator.userAgent.match(/BlackBerry/i);\n        },\n        iOS: function() {\n            return navigator.userAgent.match(/iPhone|iPad|iPod/i);\n        },\n        Opera: function() {\n            return navigator.userAgent.match(/Opera Mini/i);\n        },\n        Windows: function() {\n            return navigator.userAgent.match(/IEMobile/i);\n        },\n        any: function() {\n            return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());\n        }\n    }\n```\n\n# 让元素进入页面时自动显示在页面可视区域\n\n```js\nfunction showElemView(elem) {\n    if ($(window).scrollTop() < elem.offset().top - $(window).height()) {\n        $(window).scrollTop(elem.offset().top - $(window).height() + elem.outerHeight());\n    } else {\n        //\n    }\n};\n```\n\n# 文本框根据输入内容自适应高度\n\n```js\n/*\n* @param                {HTMLElement}        输入框元素\n* @param                {Number}                设置光标与输入框保持的距离(默认0)\n* @param                {Number}                设置最大高度(可选)\n*/\nfunction autoTextarea(elem, extra, maxHeight) {\n    extra = extra || 0;\n    var isFirefox = !!document.getBoxObjectFor || 'mozInnerScreenX' in window,\n        isOpera = !!window.opera && !!window.opera.toString().indexOf('Opera'),\n        addEvent = function(type, callback) {\n            elem.addEventListener ?\n                elem.addEventListener(type, callback, false) :\n                elem.attachEvent('on' + type, callback);\n        },\n        getStyle = elem.currentStyle ? function(name) {\n            var val = elem.currentStyle[name];\n\n            if (name === 'height' && val.search(/px/i) !== 1) {\n                var rect = elem.getBoundingClientRect();\n                return rect.bottom - rect.top -\n                    parseFloat(getStyle('paddingTop')) -\n                    parseFloat(getStyle('paddingBottom')) + 'px';\n            };\n\n            return val;\n        } : function(name) {\n            return getComputedStyle(elem, null)[name];\n        },\n        minHeight = parseFloat(getStyle('height'));\n\n    elem.style.resize = 'none';\n\n    var change = function() {\n        var scrollTop, height,\n            padding = 0,\n            style = elem.style;\n\n        if (elem._length === elem.value.length) return;\n        elem._length = elem.value.length;\n\n        if (!isFirefox && !isOpera) {\n            padding = parseInt(getStyle('paddingTop')) + parseInt(getStyle('paddingBottom'));\n        };\n        scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n\n        elem.style.height = minHeight + 'px';\n        if (elem.scrollHeight > minHeight) {\n            if (maxHeight && elem.scrollHeight > maxHeight) {\n                height = maxHeight - padding;\n                style.overflowY = 'auto';\n            } else {\n                height = elem.scrollHeight - padding;\n                style.overflowY = 'hidden';\n            };\n            style.height = height + extra + 'px';\n            scrollTop += parseInt(style.height) - elem.currHeight;\n            document.body.scrollTop = scrollTop;\n            document.documentElement.scrollTop = scrollTop;\n            elem.currHeight = parseInt(style.height);\n        };\n    };\n\n    addEvent('propertychange', change);\n    addEvent('input', change);\n    addEvent('focus', change);\n    change();\n};\n```\n\n# 转换日期时间格式\n\n```js\nfunction dateConvert(date, format) {\n    date = parseInt(date);\n    var Udate = new Date(date);\n    var Y = Udate.getFullYear(),\n        M = Udate.getMonth() < 10 ? \"0\" + (Udate.getMonth() + 1) : (Udate.getMonth() + 1),\n        D = Udate.getDate() < 10 ? \"0\" + Udate.getDate() : Udate.getDate(),\n        h = Udate.getHours(),\n        m = Udate.getMinutes(),\n        s = Udate.getSeconds(),\n        result;\n\n    if (!format) {\n        format = \"Y/M/D h:m:s\";\n    }\n\n    if (format.indexOf(\"Y\") >= 0) {\n        format = format.replace(\"Y\", Y);\n    }\n    if (format.indexOf(\"M\") >= 0) {\n        format = format.replace(\"M\", M);\n    }\n    if (format.indexOf(\"D\") >= 0) {\n        format = format.replace(\"D\", D);\n    }\n    if (format.indexOf(\"h\") >= 0) {\n        format = format.replace(\"h\", h);\n    }\n    if (format.indexOf(\"m\") >= 0) {\n        format = format.replace(\"m\", m);\n    }\n    if (format.indexOf(\"s\") >= 0) {\n        format = format.replace(\"s\", s);\n    }\n\n    return format;\n};\n```\n\n# 产生介于两个数之间的随机数\n\n## 取整数\n\n取整数，并且包含最小值和最大值\n\n```js\nfunction randomNum(minNum,maxNum) {\n    var nums = maxNum - minNum;\n    var num = Math.floor(Math.random() * nums + minNum);\n    return num;\n}\n```\n\n## 任意值\n\n取两书之间任意值，不包含最小值和最大值\n\n```js\nfunction randomNum(minNum,maxNum) {\n    var nums = maxNum - minNum;\n    var num = Math.random() * nums + minNum;\n    return num;\n}\n```\n\n## 保留指定小数位数\n\n保留`digits`位小数\n\n```js\nfunction randomNum(minNum,maxNum,digits) {\n    var nums = maxNum - minNum;\n    var num = Math.floor(Math.random() * nums + minNum).toFixed(digits);\n    return num;\n}\n```\n\n# js下载文件\n\n```js\nfunction download() {\n    var $form = $('<form method=\"GET\"></form>');\n    $form.attr('action', '/download/papers/1');\n    $form.appendTo($('body'));\n    $form.submit();\n}\n```\n\n# iframe 获取内部元素\n\n```js\n    <iframe class=\"viewbord\" src=\"\" frameborder=\"0\"></iframe>\n    <iframe class=\"music\" src=\"\" frameborder=\"0\"></iframe>\n    <script>\n        var bord = document.getElementsByClassName('viewbord')[0];\n        bord.style.height = document.body.clientHeight + 'px';\n        bord.style.width = document.body.clientWidth + 'px';\n        bord.addEventListener('load', function() {\n            document.title = document.getElementsByClassName('viewbord')[0].contentWindow.document.title;\n\n            var simUrl = document.getElementsByClassName('viewbord')[0].contentWindow.document.getElementsByClassName('chris-txt-box')[0]\n\n            if (simUrl) {\n                simUrl.onclick = function(e) {\n                    window.location.href = simUrl.getAttribute('href')\n                }\n            }\n        });\n    </script>\n```\n\n# IE8 input不支持placeholder处理办法\n\n```js\n<input type=\"text\" onblur=\"if (this.value == '') {this.value = '省份';}\" onfocus=\"if (this.value == '省份') {this.value = '';}\" value=\"省份\" >\n```\n\n# 深拷贝\n\n```js\n//利用递归来实现深拷贝，如果对象属性的值是引用类型（Array,Object），那么对该属性进行深拷贝，直到遍历到属性的值是基本类型为止。  \nfunction deepClone(obj) {    \n  if(!obj || typeof obj!== 'object') {      \n    return;    \n  }    \n  var newObj= obj.constructor === Array ? [] : {};    \n  for(var key in obj){       \n    if(obj.hasOwnProperty(key)) {\n      if(obj[key] && typeof obj[key] === 'object') {  \n        //递归\n        newObj[key] = deepClone(obj[key]);          \n      }else {\n        newObj[key] = obj[key];         \n      }       \n    }    \n  }    \n  return newObj;\n}\n```\n\n# webpack兼容IE8\n\n```js\n    new webpack.optimize.UglifyJsPlugin({\n      mangle: {\n          // mangle options, if any\n      },\n      mangleProperties: {\n        screw_ie8: false,\n        //ignore_quoted: true,      // do not mangle quoted properties and object keys\n      },\n      compress: {\n        screw_ie8: false,\n        //properties: false // optional: don't convert foo[\"bar\"] to foo.bar\n      },\n      output: {\n        screw_ie8: false         \n      }\n    })\n```\n\n# H5播放音乐控制\n\n```html\n<audio id=\"bgMusic\" autoplay=\"autoplay\" loop=\"loop\">\n    <source src=\"Venice_Beach.mp3\" type=\"audio/mp3\">\n</audio>\n<img class=\"bgMusicControl rotate play\" src=\"//img.dxycdn.com/biz/topic_files/biz/invitation/dist/images/music.png\">\n```\n\n```scss\n.bgMusicControl {\n    @keyframes rotate {\n        from {}\n        to {\n            transform: rotate(360deg);\n        }\n    }\n    width: .5rem;\n    border-radius: 100%;\n    position: absolute;\n    right: .3rem;\n    top: .2rem;\n    z-index: 1000;\n    &.rotate {\n        animation: rotate 5s linear infinite;\n    }\n}\n```\n\n## 自动播放\n\n```js\nvar audio = document.getElementById(\"bgMusic\");\naudio.play();\n// 兼容微信\ndocument.addEventListener(\"WeixinJSBridgeReady\", function() {\n    audio.play();\n}, false);\n```\n\n## 播放、暂停控制\n\n```js\n$('.bgMusicControl').click(function() {\n    var _ = $(this)\n    if (_.hasClass('play')) {\n        audio.pause();\n        _.removeClass('play').addClass('pause')\n        _.removeClass('rotate')\n    } else {\n        audio.play();\n        _.removeClass('pause').addClass('play')\n        _.addClass('rotate')\n    }\n})\n```\n\n# .gitignore规则不生效解决办法\n\n原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交\n\n```sh\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n# 判断是否是iPhoneX\n\n```js\nvar isIphoneX = /iphone/gi.test(navigator.userAgent) && (screen.height == 812 && screen.width == 375)\n```\n\n```css\n@media (device-width: 375px) and (device-height: 812px) and (-webkit-min-device-pixel-ratio : 3) {\n\n}\n```\n\n# 微信点击触发颜色块\n\n```css\n-webkit-tap-highlight-color:rgba(0,0,0,0)\n```\n\n# sleep函数\n\n```js\nasync function test() {\n  console.log('Hello')\n  await sleep(1000)\n  console.log('world!')\n}\n\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\ntest()\n```\n\n\n# 斐波那契数列第N项\n\n## 循环\n\n```js\nfunction fibonacci (n) {\n  let n1 = 1\n  let n2 = 1\n  let sum = 1\n  for (let i = 3; i <= n; i++) {\n    sum = n1 + n2\n    n1 = n2\n    n2 = sum\n  }\n  return sum\n}\n```\n\n## 递归\n\n```js\nvar fibonacci = function (n){\n  if(n<=2){\n    return 1;\n  }\n  return fibonacci(n-1) + fibonacci(n-2);  \n}\nconsole.log(fibonacci(5));\n```\n\n### memoization方案进行优化\n\nmemoization方案在《JavaScript模式》和《JavaScript设计模式》都有提到。memoization是一种将函数执行结果用变量缓存起来的方法。当函数进行计算之前，先看缓存对象中是否有次计算结果，如果有，就直接从缓存对象中获取结果；如果没有，就进行计算，并将结果保存到缓存对象中。\n\n```js\nlet fibonacci = (function () {\n  let memory = {}\n  return function (n) {\n    if (memory[n] !== undefined) {\n      return memory[n]\n    }\n    if (n <= 2) {\n      memory[n] = 1\n    } else {\n      memory[n] = fibonacci(n - 1) + fibonacci(n - 2)\n    }\n    return memory[n]\n  }\n})()\n```\n\n## ES6\n\n```js\nconst fibonacci = (n) => {\n  let a = 0\n  let b = 1\n  let i = 1\n\n  while (i++ <= n) {\n    [a, b] = [b, a + b]\n  }\n  return a\n}\nconsole.log(fibonacci(6))\n```\n\n# postMessage使iframe高度自适应\n## parent\n\n```js\nwindow.addEventListener('message',function(e){\n  var height = e.data;\n  $('').css(\"height\", height);\n}, false);\n```\n\n## child\n\n```js\nvar height = $(document.body).height();\nwindow.parent.postMessage(height, \"*\");\n```\n\n# getScript\n\n```js\nconst getScript = (url, callback) => {\n  var script = document.createElement('script')\n  if (typeof (callback) !== 'undefined') {\n    if (script.readyState) {\n      script.onreadystatechange = function () {\n        if (script.readyState === 'loaded' || script.readyState === 'complete') {\n          script.onreadystatechange = null\n          callback()\n        }\n      }\n    } else {\n      script.onload = function () {\n        callback()\n      }\n    }\n  }\n  script.src = url\n  document.body.appendChild(script)\n}\n```\n\n# 柯里化\n\n实现：\n\n```js\nvar a = add(2)(3)(4); //9\n```\n\n## 方法一\n\n```js\nfunction add () {\n  let args = [...arguments]\n\n  let fn = function () {\n    let args1 = [...arguments]\n    return add.apply(null, args.concat(args1))\n  }\n\n  fn.toString = fn.valueOf = function () {\n    return args.reduce((res, item) => res + item)\n  }\n  return fn\n}\n```\n\n## 方法二\n\n```js\nfunction add () {\n  let res = [...arguments][0]\n  let fn = function () {\n    res += [...arguments][0]\n    return fn\n  }\n\n  fn.toString = fn.valueOf = function () {\n    return res\n  }\n  return fn\n}\n```\n\n# 进制转换\n\n```js\n//十进制转其他\nvar x=110;\nconsole.log(x);\nconsole.log(x.toString(8));\nconsole.log(x.toString(32));\nconsole.log(x.toString(16));\n```\n\n```js\n//其他转十进制\nvar x='110';\nconsole.log(parseInt(x,2));\nconsole.log(parseInt(x,8));\nconsole.log(parseInt(x,16));\n```\n\n```js\n//其他转其他\n//先用parseInt转成十进制再用toString转到目标进制 \n```\n\n# 下载文件\n\n```js\nexport const getBlob = (url: string) => {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.onload = function() {\n      if (xhr.status === 200) {\n        resolve(xhr.response)\n      } else {\n        reject('发生错误')\n      }\n    }\n    xhr.onerror = function() {\n      reject('发生错误')\n    }\n    xhr.open('GET', url)\n    xhr.responseType = 'blob'\n    xhr.send()\n  })\n}\n\nexport const saveAs = (blob, filename) => {\n  const link = document.createElement('a')\n  const body = document.querySelector('body')\n\n  link.href = window.URL.createObjectURL(blob)\n  link.download = filename\n\n  // fix Firefox\n  link.style.display = 'none'\n  body && body.appendChild(link)\n\n  link.click()\n  body && body.removeChild(link)\n\n  window.URL.revokeObjectURL(link.href)\n}\n\ngetBlob(\n  // 浏览器有缓存的情况下会导致下载失败，所以需要添加时间戳\n  args.add(imgUrl, {\n    time: Date.now(),\n  })\n)\n  .then((blob) => {\n    const fileName = `filename.png`;\n    saveAs(blob, fileName);\n  })\n```","tags":["JS"],"categories":["前端"]},{"title":"linux服务器创建swap[译]","url":"/2017/04/04/linux服务器创建swap/","content":"\n> 原文：[Add Memory Swap - Ubuntu or Debian 7](https://sg.godaddy.com/zh/help/add-memory-swap-ubuntu-or-debian-7-17326)\n> 翻译：Jake\n\n如果你想提高你的服务器的性能,增加交换空间(内存交换)是一个强大的和相对简单的开始。\n\n![](//blogimg.jakeyu.top/20170405149132163776809.gif)\n\n<!--more-->\n\n\n# swap介绍\n\n一旦内存快满的时候,交换空间是一个专用的服务器可以在其内存转储的内容的硬盘。要理解的真正好处,您需要熟悉处理器架构,但这里有一个简要的说明:\n\n* RAM处理器快速提供数据,这使得它非常有价值。\n* 一旦你的内存满是它需要删除或移动数据。\n* 删除内存的数据意味着它必须找到和检索的硬盘(缓慢)下次请求的数据。\n* 通过将数据从内存和交换空间,而不是简单地删除它从RAM,更快找到下一次的数据请求。\n* 从内存到交换空间移动数据消耗处理器资源,这样做实际上不断会降低应用程序的性能(这就是所谓的交换)。为了找到最优交换率,它需要调优。\n\n最后———虽然差异是分钟,为了清楚起见,本文将指导您通过创建一个交换文件——不是一个交换分区。如果你不知道这意味着什么,别担心。\n\n# 检查当前使用交换空间\n\n防止添加交换时有任何问题,首先检查你的系统没有启用已经交换空间。\n\n找到任何交换空间驱动:\n\n\tsudo swapon -s\n\n如果结果是空的,输出类似于下面的例子,你目前没有交换空间启用:\n\n\tFilename                Type        Size    Used    Priority\n\n如果您的系统是否已经配置了交换,结果看起来像这个例子:\n\n\tFilename           Type         Size      Used  Priority\n\t/dev/sda7          partition    123450    100   -1\n\n# 检查你的可用空间\n\n现在,您已经准备好创建一个交换文件,你需要找到你的服务器的硬盘空间。\n\n检查服务器上的可用空间量:\n\n\tdf -h\n\n这个命令显示了硬盘上的自由空间。在接下来的例子中,你有40 GB可用。确保有足够的自由空间交换文件。取决于你的需求所需要的空间,但一般来说,相当于系统RAM的二倍。\n\n\tFilesystem      Size  Used Avail Use% Mounted on    \n\t/dev/vda         50G  10G   40G   20% /             \n\tnone            4.0K     0  4.0K   0% /sys/fs/cgroup  \n\tudev            2.0G   12K  2.0G   1% /dev           \n\ttmpfs           396M  312K  396M   1% /run    \n\tnone            5.0M     0  5.0M   0% /run/lock  \n\tnone            2.0G     0  2.0G   0% /run/shm  \n\tnone            100M     0  100M   0% /run/user      \n\n# 创建一个交换文件\n\n将交换空间添加到系统通过创建一个名为swapfile的文件在你的根目录(/)和分配它作为交换。有两个命令,您可以使用它来创建交换文件:\n\n* fallocate\n* dd\n\n你只需要使用其中的一个。我们建议使用fallocate,但如果它不支持的文件系统上,您可以使用dd。\n\n你可以获得更多的文件空间使用`fallocate`,`fallocate `是一个用于操作文件空间的命令。`fallocate`命令创建了一个预先分配大小并且没有初始化的文件,与`dd`命令相比,它需要更长的时间,因为它必须写入0作为虚拟内容。\n\n## 使用fallocate创建一个交换文件\n\n创建用于交换的文件。对于这个示例,我们添加一个4 GB的文件:\n\n\tsudo fallocate -l 4G /swapfile\n\n确认正确的数量的空间被保留:\n\n\tls -lh /swapfile\n\n这个结果表明,添加文件是使用正确的留出的空间量:\n\n\t-rw------- 1 root root 4.0G Jul 08 10:52 /swapfile\n\n如果你得到一个失败消息说fallocate失败:操作不支持,您的文件系统目前不支持fallocate(例如,ext3)。使用更传统的方式使用dd命令。(这种情况应该很少)。\n\n## 使用dd创建一个交换文件\n\n在这个例子中,我们将添加一个不同大小的交换文件,1 GB,为了适应小型服务器。\n\n添加1 GB交换文件,通过指定一个块大小250MB并且数量为4。\n\n> 记得要仔细检查你的指令!这个命令有可能破坏数据如果(输出文件)指出错误的位置。\n\n\tsudo dd if=/dev/zero of=/swapfile bs=250M count=4\n\n几秒钟后,生成的输出是这样的:\n\n\t4+0 records in\n\t4+0 records out\n\t1048576000 bytes (1.0 GB) copied, 1.47414 s, 711 MB/s\n\n验证文件在服务器上创建:\n\n\tls -lh /swapfile\n\n如果文件被创建,命令返回类似于:\n\n\t-rw-r--r-- 1 root root 1.0G Jul 08 10:30 swapfile\n\n# 使交换文件\n\n现在创建的文件,格式互换,然后启用它。\n\n锁定交换文件的权限,因此只有`root`用户可以访问它:\n\n\tsudo chmod 600 /swapfile\n\n当第一次创建时,交换文件是可读的,所以锁权限可以防止用户阅读潜在的敏感信息。\n\n确认文件正确的权限:\n\n\tls -lh /swapfile\n\n这个命令返回类似于:\n\n\t-rw------- 1 root root 4.0G Jul 08 10:40 /swapfile\n\n这证实了,只有`root`用户启用了读写权限。\n\n格式文件创建一个交换空间:\n\n\tsudo mkswap /swapfile\n\n如果成功,该命令会返回类似这样:\n\n\tSetting up swapspace version 1, size = 4194300 KiB\n\tno label, UUID=e2f1e9cf-c0a9-4ed4-b8ab-714b8a7d6944\n\n挂载/启用系统中的交换空间:\n\n\tsudo swapon /swapfile\n\n验证交换空间是通过检查系统报告:\n\n\tsudo swapon -s\n\n这个命令返回类似于:\n\n\tFilename Type Size Used Priority\n\tswapfile file 4194300 0 -1\n\n# 使交换文件永久生效\n\n最后一步是将交换文件集成到您的系统的存储分区,通过`fstab `。\n\n打开`fstab `\n\n\tsudo vim /etc/fstab\n\n在fstab文件最后,添加这一行告诉系统自动使用新创建的交换空间:\n\n\t/swapfile none swap sw 0 0\n\n保存并关闭该文件:\n\n\t:wq!\n\n在下次重新启动后,自动交换使用\n\n# 调整交换文件\n\n现在您已经创建了交换文件,你应该进行调优,以确保它给你最佳性能。这不是你可以轻松地一口气就完成的工作，而是你会定期的作为管理员工作。\n\n优化你的交换文件意味着修补的设置,使其执行交换(也就是说,将内容从RAM交换):\n\n* 虚拟运存控制\n* 缓存压力\n调优是很重要的,因为一个配置不佳的交换文件会损害应用程序的性能。系统的RAM和交换空间之间的相互作用是时间密集的（在计算规模上），并且尝试交换频率太高（即交换冲突）可能需要更多的时间，而不仅仅是从硬盘中恢复数据。\n\n## 虚拟运存控制\n\nSwappiness只是设置控制频率使用交换文件。\n\n一个0到100之间的比例,swappiness值:\n\n* 0意味着避免交换过程的物理内存,直到绝对必要的(内存耗尽)\n* 100意味着积极(立刻)移动交换过程的物理内存和交换缓存\n\n你可以改变你的服务器的`swapiness`在`sysctl.conf`文件中。\n\n打开`/etc/sysctl.conf`:\n\n\tsudo vim /etc/sysctl.conf\n\n在文件的最后一行添加:\n\n\tvm.swappiness=10\n\n保存并且退出:\n\n\t:wq!\n\n来优化您的应用程序中,您可以测试更改swappiness值(0到100之间)和运行性能测试。\n\n## 缓存压力\n\n另一个设置是`vfs_cache_pressure`。 当VFS（虚拟文件系统）缓存对象（称为dentry和inode_cache对象）占用更大量的内存而不是其他数据（如页面缓存和交换）时，更改此设置可能会有所帮助。 因为VFS缓存访问有关文件系统的数据，所以经常被请求并且非常耗资源。 因此，它是您的系统缓存的主要设置。\n\n`vfs_cache_pressure`的值越高，您的服务器越有可能使用其交换。\n\n你可以改变你的服务器的缓存压力在`sysctl.conf`。\n\n打开`/etc/sysctl.conf`:\n\n\tsudo vim /etc/sysctl.conf\n\n在文件最后一行添加:\n\n\tvm.vfs_cache_pressure = 50\n\n保存并关闭文件:\n\n\t:wq!\n\n像`swappiness`,你可以提高性能通过测试不同的值。\n\n# 启用交换空间\n\n使用以下三个命令检查您的工作：\n\n## swapon -s命令：\n\n\tsudo swapon -s\n\n输出可能如下所示：\n\n\tFilename                Type        Size    Used    Priority\n\t/swapfile               file        4194300 0       -1\n\n您会看到添加了4 G的交换文件。\n\n## 有关更详细的报告：\n\n\tfree -m\n\n## 关于交换详细信息的报告：\n\n\tcat /proc/meminfo | grep -i swap\n\n# 结论\n\n交换可以有利于允许您的系统利用比原来可用的更多的内存。 在优化应用程序配置，添加更多RAM或升级服务器之前，这是一个可行的选择。\n\n但是，请务必记住定期调整交换文件，以确保您最充分地使用它。\n","tags":["服务器"],"categories":["服务器"]},{"title":"XSS攻击与预防","url":"/2017/03/31/XSS攻击与预防/","content":"\n![](//blogimg.jakeyu.top/2017033114909695634288.jpg)\n\n<!--more-->\n\n## Web安全之模拟XSS攻击\n\n跨站脚本（XSS, Cross Site Script）攻击指的是，攻击者可以让某网站执行一段非法脚本。这种情况很常见，比如提交一个表单用于修改用户名，我们可以在文本框中输入一些特殊字符，比如`<`,`>`,`'`,`\"`等，检查一下用户名是否正确修改了。\n\n### XSS的攻击方式\n- 反射型\n> 发出请求是,XSS代码出现在URL中,作为输入提交到服务器端,服务器端解析后响应,XSS代码随着响应内容一起传回浏览器,最后浏览器解析执行XSS代码。这个过程像一次反射,故叫做反射型XSS。\n- 存储型\n> 存储型XSS和反射型XSS的差别在于,提交的代码会存储在服务器中(例如数据库,内存,文件系统等),下次请求页面是不用再提交XSS代码。\n\n`XSS`一定是由用户的输入引起的，无论是提交表单、还是点击链接（参数）的方式，只要是对用户的输入不做任何转义就写到数据库，或者写到`html`，`js`中，就很有可能出错。\n\n从一个请求发出开始，到浏览器显示内容，与`XSS`相关的有三个地方`URL、HTML、JavaScript`。至于后台方面，它分两个功能，一个是将数据写到数据库，这时候也要对数据进行转义，但不是XSS的范畴，它更多是防止数据破坏`SQL`语句的结构；另一个是从数据库读取数据，直接生成`HTML`或者以`JSON`的方式传给前端，这些数据都必须转义后才能显示到浏览器中。\n\n## HTML字符\n\n`HTML`本身是一个文本文档，但在浏览器中却可以显现得花样百出，是因为很多字符对于浏览器来说是有特殊含义的，比如在`<script>`中的内容，浏览器会做一些动画等等。那么对这些特殊字符进行转义，就意味着让浏览器对待它们的时候，就像普通字符一样，比如`&lg;script&gt;`这段文字在浏览器中就会正常显示为`<script>`。\n\n### 简单的用来转义`HTML`的`JavaScript`方法\n\n```js\nfunction encodeHTML (a) {\n  return String(a)\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\");\n};\n```\n\n那么有哪些字符需要转义呢？这里列了一些常见的。\n\n`\" --> &#34;`\n`# --> &#35;`\n`$ --> &#36;`\n`& --> &#38;`\n`' --> &#39;`\n`( --> &#40;`\n`) --> &#41;`\n`; --> &#59;`\n`< --> &#60;`\n`> --> &#62;`\n\n\n在 escapeHTML 方法中，我使用了别名的方式转义，因为它比较容易记一点。无论是别名还是十六进制，它们表示的含义都是一样的，比如`&amp;`和`&#38;`都表示`&`符号。想要看更具体的列表可以参考[这个网站](http://ascii.cl/htmlcodes.htm)\n\n在浏览器收到 HTML 之后，首先会对所有的内容进行解码，它会把所有能识别的编码符号，解码成字面值。比如有\n\n```html\n<p>my name is&#58;&#32;<a href=\"https&#58;&#47;&#47;i.jakeyu.top\">名一</a></p>\n```\n\n经过浏览器解码就变成\n\n```html\n<p>my name is: <a href=\"https://i.jakeyu.top\">名一</a></p>\n```\n\n这里要说的是，浏览器只会对两个地方解码，一个是标签的**内容**（即`textContent`，除了`<script>`和`<style>`标签），另一个是标签的**属性值**。对于属性名是不会解码的。\n\n## URL\n\n早些时候，服务端还不支持在`URL`中直接传输`Unicode`，比如`https://i.jakeyu.top/search?q=你好`这样的地址，服务端无法识别“你好”这个值，所以必须编码之后进行传输。\n\n那么对于 URL，我们只需要对参数的值进行编码就可以了。比如上面这个链接，编码之后就是`https://i.jakeyu.top/find?q=%E4%BD%A0%E5%A5%BD`。\n\n如果对整个 URL 编码，那么链接就无效了。\n\n编码的方式很简单，浏览器提供了全局的`encodeURI`方法，调用之后就可以实现转义了。\n\n有一点很重要`encodeURI`是不会转义`:`,`/`,`?`,`&`,`=`这些在`URL`中有特殊含义的字符的，那么如果有个参数正好包含了这些字符，就不会转义，比如\n\n```js\nencodeURI('https://i.jakeyu.top/login?name=名一&from=http://other.com');\n\n// -> https://i.jakeyu.top/login?name=%E5%90%8D%E4%B8%80&from=http://other.com\n```\n\n\nfrom 参数的值并没有转义，这时候，就需要用到另一个方法`encodeURIComponent`\n\n```js\nvar param = encodeURIComponent('http://other.com');\nencodeURI('https://i.jakeyu.top/login?name=名一&from=') + param;\n\n// -> https://i.jakeyu.top/login?name=%E5%90%8D%E4%B8%80&from=http%3A%2F%2Fother.com\n```\n\n所以结论就是，如果要对整个 URL 进行转义，使用 encodeURI，如果对参数的值进行转义，使用 encodeURIComponent。\n\n当动态生成的链接地址需要赋值给`href`或者`src`属性时，需要对这些地址进行`URL`转义。当然，如果服务端支持在`URL`中包含`UTF-8`的字符的话，其实不转义也不会错，这就是为什么我们平时不会太注意对表单和`URL`参数进行转义的原因，因为服务端表现良好。\n\n## JavaScript 特殊字符\n\nJS 中的转义都是通过反斜杠完成，有三种类型，以`'`和`\"`为例\n\n* 直接反斜杠 --> \\'\\\"\n* 十六进制 --> \\x22\\x27\n* Unicode --> \\u0022\\u0027\n\n一般情况下可以直接通过反斜杠转义，但有些字符我们不知道怎么输入，很常见的比如 Web Font，在 CSS 中可以看到类似这样的代码\n\n```css\n.glyphicon-home::before {\n    content: \"\";\n}\n```\n那个 content 中的值可以通过十六进制或者 Unicode 的方式来代替。\n\nJS 转义一般用于显示用户输入的时候，比如用户输入了反斜杠，需要显示时，就必须`alert('\\\\');`。\n\n## 解码顺序\n\n当浏览器进行绘制时，首先会对 HTML 进行解码，然后是 URL，最后是执行 JS 时对它进行解码。\n\n现在考虑这三种编码同时存在的情况\n\n```js\n<a href=\"javascript&#58;&#32;alert('\\<https&#58;&#47;&#47;i.jakeyu.top/find?q=%E4%BD%A0%E5%A5%BD\\>');\">click</a>\n```\n\n首先是`HTML`解码，结果为\n\n```html\n<a href=\"javascript: alert('\\<https://i.jakeyu.top/find?q=%E4%BD%A0%E5%A5%BD\\>');\">click</a>\n```\n然后是`URL`解码，结果为\n\n```html\n<a href=\"javascript: alert('\\<https://i.jakeyu.top/find?q=你好\\>');\">click</a>\n```\n\n最后是`JS`解码，结果为\n\n```js\n<a href=\"javascript: alert('<https://i.jakeyu.top/find?q=你好>');\">click</a>\n```\n\n单击链接后，应该会出现一个弹窗，内容是`<https://i.jakeyu.top/find?q=你好>`。\n\n本文更多的是介绍如何防止XSS的发生，而不是它的危害。核心就是用适当的方法对 HTML, JS 进行转义。\n\n> 来自[[Web 安全]了解XSS与防范](https://segmentfault.com/a/1190000003874852)\n","tags":["方案"],"categories":["前端"]},{"title":"mongoose中使用populate处理嵌套","url":"/2017/03/21/mongoose中使用populate处理嵌套/","content":"\nnodejs在使用mongdb数据库中经常会使用到嵌套，比如一个多级分类等。这里我使用`学校-->学院-->学生`来展示使用populate处理嵌套。\n\n<!--more-->\n\n# 定义modal\n\n在模式中，我们需要使用`Schema.ObjectId`来表示要指向数据在mongodb数据库中的`_id`。\n\n## 学校\n\n在学校的Schema中，colleges属性是要包含的学院的`_id`属性数组。\n\n```js\nvar SchoolSchema = new Schema({\n\tname: String,\n\tcolleges: [{\n\t\ttype: Schema.ObjectId,\n\t\tref: 'College'\n\t}],\n\tcreateTime: {\n\t\ttype: Date,\n\t\tdefault: Date.now()\n\t}\n});\n\nvar School  = mongoose.model('School', SchoolSchema);\n```\n\n## 学院\n\n```js\nvar CollegeSchema = new Schema({\n\tname: String,\n\tstudents: [{\n\t\ttype: Schema.ObjectId,\n\t\tref: 'Student'\n\t}],\n\tcreateTime: {\n\t\ttype: Date,\n\t\tdefault: Date.now()\n\t}\n});\n\nvar College  = mongoose.model('College', CollegeSchema);\n```\n\n## 学生\n\n```js\nvar StudentSchema = new Schema({\n\tname: String,\n\tsex: String,\n\tage: Number,\n\tcreateTime: {\n\t\ttype: Date,\n\t\tdefault: Date.now()\n\t}\n});\n\nvar Student  = mongoose.model('Student', StudentSchema);\n```\n\n# 查找\n## 直接查找\n\n查找学校并找到指向的学院\n\n```js\nSchool\n\t.find()\n\t.populate('colleges', ['_id','name'])\n\t.exec((err, schools) => {\n\t\tif (err) {\n\t\t\tconsole.log(err)\n\t\t}\n\t\tconsole.log(schools)\n\t})\n```\n\n`populate`的第一个参数是学校表中需要指向学院表的属性，即`colleges`；第二个参数为要在学院中查找的属性。如果不填写第二个参数，则默认全都查出。\n\n这样查找出的结果中，学院的学生属性是该学院包含的学生的`_id`属性。如果需要都查找出来需要使用嵌套`populate`。\n\n## 嵌套\n\n```js\nSchool\n\t.find()\n\t.populate({\n\t\tpath: 'colleges',\n\t\tselect: ['_id', 'name'],\n\t\t// model: 'College',\n\t\tpopulate: {\n\t\t\tpath: 'students',\n\t\t\tselect: ['_id', 'name']\n\t\t\t\t// model: 'Student'\n\t\t}\n\t})\n\t.sort({\n\t\tcreateTime: -1\n\t}).exec(function(err, schools) {\n\t\tif (err) {\n\t\t\tconsole.log(err)\n\t\t}\n\t});\n```\n","tags":["mongoose"],"categories":["Node"]},{"title":"centos使用SS翻墙","url":"/2017/03/16/centos使用SS翻墙/","content":"\n![](//blogimg.jakeyu.top/shadowsocks.png)\n\n<!--more-->\n\n{% note danger %} \n梯子服务商推荐 [V2Club](https://join.v2fly.club/#/register?code=C5EnE7vC)，支持全平台，安全、稳定。\n{% endnote %}\n\n## socks5 全局代理\n### 安装 sslocal\n\n```sh\npip install shadowsocks # pip安装ss客户端\n如果提示 -bash: pip: command not found\n运行 yum -y install python-pip\n```\n\n### shadowsocks.json\n\n~~~sh\nvim /etc/shadowsocks.json\n--- shadowsocks.json ---\n{\n    \"server\":\"SERVER-IP\",   # 你的服务器ip\n    \"server_port\":PORT,    # 服务器端口\n    \"local_address\": \"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"PASSWORD\",    # 密码\n    \"timeout\":300,\n    \"method\":\"aes-128-cfb\", # 加密方式\n    \"fast_open\": false,\n    \"workers\": 1\n}\n--- shadowsocks.json ---\n~~~\n\n### 运行 sslocal\n\n```sh\nnohup sslocal -c /etc/shadowsocks.json &>> /var/log/sslocal.log &\n```\n\n\n## privoxy篇\n### 安装 privoxy\n\n```sh\nyum -y install privoxy\n```\n\n### 配置 socks5 全局代理\n\n```sh\necho 'forward-socks5 / 127.0.0.1:1080 .' >> /etc/privoxy/config\n```\n\n### 设置 http/https 代理\n\n```sh\nexport http_proxy=http://127.0.0.1:8118 # privoxy默认监听端口为8118\nexport https_proxy=http://127.0.0.1:8118\n```\n\n### 运行 privoxy\n\n\tservice privoxy start\n\n### 测试 socks5 全局代理\n\n```sh\ncurl www.google.com\n## 如果出现下面这段输出则代理成功！\n------------------------------------------------------------------------------\n<HTML><HEAD><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\">\n<TITLE>302 Moved</TITLE></HEAD><BODY>\n<H1>302 Moved</H1>\nThe document has moved\n<A HREF=\"http://www.google.com.hk/url?sa=p&amp;hl=zh-CN&amp;pref=hkredirect&amp;pval=yes&amp;q=http://www.google.com.hk/%3Fgws_rd%3Dcr&amp;ust=1480320257875871&amp;usg=AFQjCNHg9F5zMg83aD2KKHHHf-yecq0nfQ\">here</A>.\n</BODY></HTML>\n------------------------------------------------------------------------------\n```\n\n## 简化使用\n\n进过上面的步骤我们的确代理成功了。。但是每次都要输入这么多命令太麻烦\n这时我们可以利用 命令别名 来简化我们的操作\n\n```sh\nalias ssinit='nohup sslocal -c /etc/shadowsocks.json &>> /var/log/sslocal.log &'\nalias sson='export http_proxy=http://127.0.0.1:8118 && export https_proxy=http://127.0.0.1:8118 && systemctl start privoxy'\nalias ssoff='unset http_proxy && unset https_proxy && systemctl stop privoxy && pkill sslocal'\n```\n\n### 使用方法\n\n\t### 开启ss代理\n\tssinit\n\tsson\n\t## 关闭ss代理\n\tssoff\n","tags":["服务器"],"categories":["服务器"]},{"title":"异步编程之async","url":"/2017/03/15/async/","content":"\n![](//blogimg.jakeyu.top/async/async.png)\n\n<!--more-->\n\n[async官方DOC](http://caolan.github.io/async/index.html)\n\n## 介绍\n\n### node安装\n\n\tnpm install async --save\n\n使用\n\n\tvar async = require('async')\n\n### js文件\n\n[https://github.com/caolan/async/tree/master/dist](https://github.com/caolan/async/tree/master/dist)\n\nasync提供了很多函数用于异步流程控制，下面是async核心的几个函数，完整的函数请看[async官方DOC](http://caolan.github.io/async/index.html)\n\n```js\n\tasync.map(['file1','file2','file3'], fs.stat, function(err, results) {\n    // results is now an array of stats for each file\n\t});\n\n\tasync.filter(['file1','file2','file3'], function(filePath, callback) {\n\t  fs.access(filePath, function(err) {\n\t    callback(null, !err)\n\t  });\n\t}, function(err, results) {\n\t    // results now equals an array of the existing files\n\t});\n\n\tasync.parallel([\n\t    function(callback) { ... },\n\t    function(callback) { ... }\n\t], function(err, results) {\n\t    // optional callback\n\t});\n\n\tasync.series([\n\t    function(callback) { ... },\n\t    function(callback) { ... }\n\t]);\n```\n\n## series串行\n\n`series`的作用就是按照顺序一次执行。\n\n```js\nasync.series([\n  function(callback) {\n    setTimeout(function() {\n      callback(null, 1)\n        }, 2000);\n    },\n  function(callback) {\n    callback(null, 2);\n  }],\n  function(err, results) {\n    console.log(results);\n  });\n```\n\n输出结果为\n\n\t[ 1, 2 ]\n\n`series`函数的第一个参数可以是一个数组也可以是一个JSON对象，参数类型不同，影响的是返回数据的格式。\n\n```js\nasync.series({\n\tone: function(callback){\n\t\tcallback(null, 1);\n\t},\n\ttwo: function(callback){\n\t\tcallback(null, 2);\n\t}\n},function(err, results) {\n\tconsole.log(results);\n});\n```\n\n输出为\n\n\t{one: 1, two: 2}\n\n## waterfall瀑布流\n\n`waterfall`和`series`函数都是按照顺序执行，不同之处是`waterfall`每个函数产生的值都可以传递给下一个函数，`series`不可以。\n\n```js\nasync.waterfall([\n\tfunction(callback) {\n\t\tcallback(null, 'one', 'two');\n\t},\n\tfunction(arg1, arg2, callback) {\n\t\t// arg1 now equals 'one' and arg2 now equals 'two'\n\t\tconsole.log('function 2')\n\t\tconsole.log('arg1: ' + arg1)\n\t\tconsole.log('arg2: ' + arg2)\n\t\tcallback(null, 'three');\n\t},\n\tfunction(arg1, callback) {\n\t\tconsole.log('function 3')\n\t\tconsole.log('arg1: ' + arg1)\n\t\t\t// arg1 now equals 'three'\n\t\tcallback(null, 'done');\n\t}\n], function(err, result) {\n\t// result now equals 'done'\n\tconsole.log(result);\n});\n```\n\n输出\n\n```js\nfunction 2\narg1: one\narg2: two\nfunction 3\narg1: three\ndone\n```\n\n`waterfall`第一个参数只能为数组。当中途有函数出错，其err直接传给最终callback，结果被丢弃，后面的函数不再执行。\n\n## parallel(tasks, [callback])\n\n`paraller`函数是并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。\n传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。\n\n```js\nasync.parallel([\n    function(callback){\n        callback(null, 'one');\n    },\n    function(callback){\n        callback(null, 'two');\n    }\n],\nfunction(err, results){\n\n});\n```\n\ntasks参数可以是一个数组或是json对象，和`series`函数一样，tasks参数类型不同，返回的results格式会不一样。\n\n将示例中tasks的回调函数用setTimeout在1000毫秒后调用，然后在`parallel`的回调函数中输出results，看一看整个过程花费了1s还是2s。\n\n```js\nvar async=require(\"async\");\nasync.parallel([\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'one')\n        },1000);\n    },\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'two')\n        },1000);\n    }\n],\nfunction(err, results){\n    console.log(results);\n});\n```\n\n## parallelLimit(tasks, limit, [callback])\n\n`parallelLimit`函数和`parallel`类似，但是它多了一个参数limit。 limit参数限制任务只能同时并发一定数量，而不是无限制并发，示例如下：\n\n```js\nasync.parallelLimit([\n    function(callback){\n        callback(null, 'one');\n    },\n    function(callback){\n        callback(null, 'two');\n    }\n],\n2,\nfunction(err, results){\n\n});\n```\n\n将示例中tasks的回调函数用setTimeout在1000毫秒后调用，limit参数设置为1，然后在parallelLimit的回调函数中输出results，看一看整个过程花费了1s还是2s。\n\n```js\nvar async=require(\"async\");\nasync.parallelLimit([\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'one');\n        }, 1000);\n    },\n    function(callback){\n        setTimeout(function(){\n            callback(null, 'two');\n        }, 1000);\n    }\n],\n1,\nfunction(err, results){\n    console.log(results);\n});\n```\n\n## map(coll, iteratee, callbackopt)\n\n`map`函数遍历传入的数组，并执行同样的操作，最终返回结果\n\n* cool:数组\n* iteratee:对数组每一项要执行的函数\n* callbackopt:回调函数\n\n```js\nasync.map([1, 2, 3, 4, 5],\n\tfunction(item, callback) {\n\t\tcallback(null, item + 5)\n\t},\n\tfunction(err, result) {\n\t\tconsole.log(result)\n\t})\n```\n\n\t[ 6, 7, 8, 9, 10 ]\n","tags":["JS"],"categories":["Node"]},{"title":"数组","url":"/2017/03/04/数组/","content":"\n# 数组和字符串之间相互转换\n## split()\n\n`split()`函数是将字符串转换为数组\n\n```js\nvar sentence = 'the quick brown for jumped over the lazy dog'\nvar words = sentence.split(' ')\nfor (let i = 0; i < words.length; i++) {\n\tconsole.log(\"word \" + i + ': ' + words[i])\n}\n```\n\n输出\n```js\nword 0: the\nword 1: quick\nword 2: brown\nword 3: for\nword 4: jumped\nword 5: over\nword 6: the\nword 7: lazy\nword 8: dog\n```\n\n## join()、toString()\n\n`join()` `toString()`两个方法可以将数组转化为字符串。这两个方法都返回一个包含数组所有元素的字符串，各元素之间默认用逗号分隔开\n\n```js\nvar names = ['David', 'Cynthia', 'Raymond', 'mike']\nvar namestr = names.join()\nconsole.log(namestr)\nvar namestr_1 = names.toString()\nconsole.log(namestr_1)\n```\n\n输出\n\n```js\nDavid,Cynthia,Raymond,mike\nDavid,Cynthia,Raymond,mike\n```\n\n如果为`join()`传入参数，则各元素之间使用传入的参数隔开\n\n```JS\nvar names = ['David', 'Cynthia', 'Raymond', 'mike']\nvar namestr = names.join(';')\nconsole.log(namestr)\n```\n\n输出\n\n```js\nDavid;Cynthia;Raymond;mike\n```\n\n# 存取函数\n## indexOf()、lastIndexOf()\n\n`indexOf()`函数是最常用的存取函数之一，用来查找传进来的参数在目标数组中是否存在。如果目标数组包含该参数，就返回该元素在数组中的索引；如果不包含，就返回`-1`。\n\n```js\nvar name = ['jake', 'yu', 'lao']\nconsole.log('yu is at: ' + name.indexOf('yu'))\nconsole.log('aaa is at: ' + name.indexOf('aaa'))\n```\n\n输出\n\n```js\nyu is at: 1\naaa is at: -1\n```\n\n如果数组中包含多个相同的元素，`indexOf()`函数总是返回第一个与参数相同的元素的索引。`lastIndexOf()`函数返回相同元素的最后一个元素的索引，如果没有找到相同元素，则返回`-1`\n\n## findIndex()\n\n除IE以外的所有浏览器（非边缘）都支持Array.prototype.findIndex。但是[Polyfill](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex#Polyfill)很好的解决了这个问题\n\n```js\nvar indexOfStevie = myArray.findIndex(i => i.hello === \"stevie\");\n```\n\n兼容\n\n```js\n// https://tc39.github.io/ecma262/#sec-array.prototype.findIndex\nif (!Array.prototype.findIndex) {\n  Object.defineProperty(Array.prototype, 'findIndex', {\n    value: function(predicate) {\n     // 1. Let O be ? ToObject(this value).\n      if (this == null) {\n        throw new TypeError('\"this\" is null or not defined');\n      }\n\n      var o = Object(this);\n\n      // 2. Let len be ? ToLength(? Get(O, \"length\")).\n      var len = o.length >>> 0;\n\n      // 3. If IsCallable(predicate) is false, throw a TypeError exception.\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n\n      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.\n      var thisArg = arguments[1];\n\n      // 5. Let k be 0.\n      var k = 0;\n\n      // 6. Repeat, while k < len\n      while (k < len) {\n        // a. Let Pk be ! ToString(k).\n        // b. Let kValue be ? Get(O, Pk).\n        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).\n        // d. If testResult is true, return k.\n        var kValue = o[k];\n        if (predicate.call(thisArg, kValue, k, o)) {\n          return k;\n        }\n        // e. Increase k by 1.\n        k++;\n      }\n\n      // 7. Return -1.\n      return -1;\n    }\n  });\n}\n```\n\n# 由已知数组创建新数组\n## concat()、splice()\n\n`concat()`和`splice()`方法允许通过已有的数组创建新数组。`concat()`方法可以合并多个数组创建一个新数组，`splice()`方法截取一个数组的子集创建一个新数组。\n\n### concat()\n\n该方法的发起者是一个数组，参数是另外一个数组或者多个数组。作为参数的数组，其中的所有元素都被连接到调用`concat()`方法的数组后面。下面的程序展示了`concat()`方法的工作原理：\n\n```js\nvar cisDept = ['jake', 'mike', 'jenn']\nvar dmpDept = ['bryan', 'cynthia']\nvar dmpDept_2 = ['bryan', 'cynthia']\nvar itDiv = cisDept.concat(dmpDept)\nconsole.log(itDiv)\nvar itDiv = cisDept.concat(dmpDept, dmpDept_2)\nconsole.log(itDiv)\n```\n\n输出\n\n```js\n[ 'jake', 'mike', 'jenn', 'bryan', 'cynthia' ]\n[ 'jake', 'mike', 'jenn', 'bryan', 'cynthia', 'bryan', 'cynthia' ]\n```\n\n### splice()\n\n`splice()`方法从现有数组里截取一个新数组。该方法的第一个参数是截取的起始索引，第二个参数是截取的长度。该方法会改变原来的数组。如果第二个参数传入的是`0`，则不删除\n\n```js\nvar num = [1, 2, 3, 4, 5, 6]\nvar numSpl = num.splice(1, 3)\nconsole.log(numSpl)\nconsole.log(num)\n```\n\n输出\n\n```js\n[ 2, 3, 4 ]\n[ 1, 5, 6 ]\n```\n\n# 添加和删除\n## push()、unshift()\n\n`push()`方法会将一个元素添加到数组末尾：\n\n```js\nvar nums = [1, 2, 3, 4, 5]\nnums.push(6, 7, 8)\nconsole.log(nums)\n```\n\n输出\n\n```js\n[ 1, 2, 3, 4, 5, 6, 7, 8 ]\n```\n\n`unshift()`方法会将一个元素添加到数组开头\n\n```js\nvar nums = [1, 2, 3, 4, 5]\nnums.unshift(6, 7, 8)\nconsole.log(nums)\n```\n\n输出\n\n```js\n[ 6, 7, 8, 1, 2, 3, 4, 5 ]\n```\n\n## pop()、shift()\n\n`pop()`方法可以删除数组末尾的元素，并返回该元素\n\n```js\nvar nums = [1, 2, 3, 4, 5]\nvar popNum = nums.pop()\nconsole.log(nums)\t//[ 1, 2, 3, 4 ]\nconsole.log(popNum)\t//5\n```\n\n`shift()`方法可以删除数组开头的元素，并返回该元素\n\n```js\nvar nums = [1, 2, 3, 4, 5]\nvar popNum = nums.shift()\nconsole.log(nums)\t//[ 2, 3, 4, 5 ]\nconsole.log(popNum)\t//1\n```\n\n## splice()\n\n使用`splice()`方法为数组添加元素，需提供如下参数\n\n* 起始索引\n* 需要删除的元素个数(不删除为0)\n* 想要添加的元素\n\n```js\nvar nums = [1, 2, 3, 4, 5]\nnums.splice(3, 0, 11, 11, 11, 11, 11)\nconsole.log(nums)\t//[ 1, 2, 3, 11, 11, 11, 11, 11, 4, 5 ]\n```\n\n# 排序\n## reverse()\n\n`reverse()`可以对数组进行翻转\n\n```js\nvar nums = [1, 2, 3, 4, 5]\nnums.reverse()\nconsole.log(nums)\t//[ 5, 4, 3, 2, 1 ]\n```\n\n## sort()\n\n如果数组是字符串类型，那么数组的可变方法`sort()`就非常好使:\n\n```js\nvar name = ['David', 'Mike', 'Cynthia', 'Clayton']\nname.sort()\nconsole.log(name)\t//[ 'Clayton', 'Cynthia', 'David', 'Mike' ]\n```\n\n但是如果数组元素是数字类型，`sort()`方法的排序结果就不能让人满意了\n\n```js\nvar nums = [3, 1, 2, 100, 4, 200]\nnums.sort()\nconsole.log(nums)\t//[ 1, 100, 2, 200, 3, 4 ]\n```\n\n`sort()`方法是按照字典顺序对元素进行排序，因此它假定元素都是字符串类型。为了让`sort()`方法也能排序数字类型的元素，可以在调用方法是传入一个比较大小的函数。\n\n```JS\nvar nums = [3, 1, 2, 100, 4, 200]\nnums.sort((num1, num2) => {\n\treturn num1 - num2\n})\nconsole.log(nums)\t//[ 1, 2, 3, 4, 100, 200 ]\n```\n\n# 迭代器方法\n\n这些方法对数组中的每个元素应用一个函数，可以返回一个值、一组值或者一个新数组\n\n## forEach()\n\n该方法接受一个函数作为参数，对数组中的每个元素使用该函数。\n\n```js\nvar nums = [1, 2, 3, 4, 5, 6, 7, 8]\nnums.forEach((item, index) => {\n\tconsole.log(item, item * item)\n})\n```\n\n输出\n\n```js\n1 1\n2 4\n3 9\n4 16\n5 25\n6 36\n7 49\n8 64\n```\n\n## every()\n\n该方法接受一个返回值为布尔类型的函数，对数组中的每个元素使用该函数。如果对于所有的元素该函数返回值均为`true`，则该方法返回`true`。\n\n```js\nvar nums = [2, 4, 6, 8]\nisEven = (num) => {\n\treturn num % 2 == 0\n}\n\nvar even = nums.every(isEven)\n\nif (even) {\n\tconsole.log('even is true')\n} else {\n\tconsole.log('even is false')\n}\n//even is true\n```\n\n```js\nvar nums = [1, 2, 4, 6, 8]\nisEven = (num) => {\n\treturn num % 2 == 0\n}\n\nvar even = nums.every(isEven)\n\nif (even) {\n\tconsole.log('even is true')\n} else {\n\tconsole.log('even is false')\n}\n//even is false\n```\n\n## some()\n\n`some()`方法也接受一个返回值为布尔类型的函数，只有有一个元素使得该函数返回`true`，该方法就返回`true`\n\n```js\nfunction isEven(num) {\n\treturn num % 2 == 0\n}\n\nvar nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nvar someEven = nums.some(isEven)\n\nif (someEven) {\n\tconsole.log('true')\n} else {\n\tconsole.log('false')\n}\n//true\n```\n\n## reduce()\n\n`reduce()`方法接受一个函数，返回一个值。该方法会从一个累加值开始，不断对累加值和数组中的后续元素调用该函数，直到数组中的最后一个元素，最后返回得到的累加值。\n\n```js\nfunction add(runningTotal, currentValue) {\n\treturn runningTotal + currentValue\n}\n\nvar nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nvar sum = nums.reduce(add)\nconsole.log(sum)\t//55\n```\n\n```js\nadd(1,2) --> 3\nadd(3,3) --> 6\nadd(6,4) --> 10\nadd(10,5) --> 15\nadd(15,6) --> 21\nadd(21,7) --> 28\nadd(28,8) --> 36\nadd(36,9) --> 45\nadd(45,10) --> 55\n```\n\n`reduceRight()`方法和`reduce()`方法不同，`reduceRight()`是从右到左执行\n\n## map()\n\n`map()`和`forEach()`有点儿像，对数组中的每个元素使用某个函数。两者区别是`map()`返回一个新的数组，该数组的元素是对原有元素应用某个函数得到的结果。\n\n```js\nfunction curve(grade) {\n\treturn grade += 5\n}\n\nvar grades = [77, 65, 81, 92, 83]\n\nvar newGrades = grades.map(curve)\nconsole.log(newGrades)\t//[ 82, 70, 86, 97, 88 ]\n```\n\n## filter()\n\n`filter()`和`every()`类似，传入一个返回值为布尔类型的函数。和`every()`方法不同的是，当对数组中的所有元素应用该函数，结果均为`true`时，该方法并不返回`true`，而是返回一个新数组，该数组包含应用该函数后的结果为`true`的元素。\n\n```js\nfunction isEven(num) {\n\treturn num % 2 == 0\n}\n\nvar nums = []\n\nfor (let i = 0; i < 20; i++) {\n\tnums[i] = i + 1\n}\n\nvar events = nums.filter(isEven)\nconsole.log(events)\t//[ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 ]\n```\n\n# 一行代码生成数组\n\n> 作者：SarjuHansaliya\n> 原文：[仅用一行生成[0, 1, ..., N-1]数列](http://www.jstips.co/zh_cn/javascript/create-range-0...n-easily-using-one-line/)\n\n使用下面一行代码，我们就可以生成0…(N-1)数列。\n\n## ES5\n\n```js\nArray.apply(null, {length: N}).map(Function.call, Number);\n```\n\n### 简要说明:\n\n1. Array.apply(null, {length: N}) 返回一个由undefined填充的长度为N的数组(例如 A = [undefined, undefined, ...])。\n2. A.map(Function.call, Number) 返回一个长度为N的数组，它的索引为I的元素为Function.call.call(Number, undefined, I, A)的结果。\n3. Function.call.call(Number, undefined, I, A)可转化为Number(I)，正好就是I。\n4. 结果为：[0, 1, ..., N-1]。\n\n## ES6\n\n这里用到了[Array.from](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n\n```js\nArray.from(new Array(N),(val,index)=>index);\n```\n\n### 简要说明:\n\n1. A = new Array(N) 返回一个有N个_小孔_的数组 (例如 A = [,,,...], 但是对于x in 0...N-1时A[x] = undefined)。\n2. F = (val,index)=>index 即 function F (val, index) { return index; }。\n3. Array.from(A, F) 返回一个长度为N的数组，它的索引为I的元素为F(A[I], I)的结果，也就是I。\n4. 结果为：[0, 1, ..., N-1]。\n\n## One More Thing\n\n如果你需要[1, 2, …, N]序列， [方法1](#ES5)可改为：\n\n```js\nArray.apply(null, {length: N}).map(function(value, index){\n  return index + 1;\n});\n```\n\n[方法2](#ES6)可改为：\n\n```js\nArray.from(new Array(N),(val,index)=>index+1);\n```\n","tags":["前端"],"categories":["前端"]},{"title":"mongoose参考手册","url":"/2017/02/28/mongoose参考手册/","content":"\n![](//blogimg.jakeyu.top/mongoose/mongoose.jpg)\n\n<!--more-->\n\n## Mongoose 是什么?\n\n一般我们不直接用MongoDB的函数来操作MongoDB数据库 Mongose就是一套操作MongoDB数据库的接口.\n\n### Schema\n\n一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力.可以说是数据属性模型(传统意义的表结构)，又或着是\"集合\"的模型骨架\n\n```js\n/* 定义一个 Schema */\nvar mongoose = require(\"mongoose\");\n\nvar TestSchema = new mongoose.Schema({\n    name : { type: String },//属性name,类型为String\n    age  : { type: Number, default: 0 },//属性age,类型为Number,默认为0\n    time : { type: Date, default: Date.now },\n    email: { type: String,default: ''}\n});\n```\n\n上面这个 TestSchema包含4个属性 [name, age, time, email]\n\n### Model\n\n由Schema构造生成的模型，除了Schema定义的数据库骨架以外，还具有数据库操作的行为，类似于管理数据库属性、行为的类\n\n```js\nvar db = mongoose.connect(\"mongodb://127.0.0.1:27017/test\");\n\n// 创建Model\nvar TestModel = db.model(\"test1\", TestSchema);\n```\n\ntest1 数据库中的集合名称, 不存在会创建.\n\n### Entity\n\n由Model创建的实体，使用save方法保存数据，Model和Entity都有能影响数据库的操作，但Model比Entity更具操作性\n\n```js\nvar TestEntity = new TestModel({\n       name : \"Lenka\",\n       age  : 36,\n       email: \"lenka@qq.com\"\n});\nconsole.log(TestEntity.name); // Lenka\nconsole.log(TestEntity.age); // 36\n```\n\n### 游标\n\nMongoDB 使用游标返回find的执行结果.客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果的数量，略过部分结果，根据任意键按任意顺序的组合对结果进行各种排序，或者是执行其他一些强的操作。\n\n### ObjectId\n\n存储在mongodb集合中的每个文档（document）都有一个默认的主键_id，这个主键名称是固定的，它可以是mongodb支持的任何数据类型，默认是ObjectId。\n\nObjectId是一个12字节的 BSON 类型字符串。按照字节顺序，依次代表：\n\n* 4字节：UNIX时间戳\n* 3字节：表示运行MongoDB的机器\n* 2字节：表示生成此_id的进程\n* 3字节：由一个随机数开始的计数器生成的值\n\n## Node.js 中\n\npackage.json 中加入\"mongoose\": \"\\*\" 字段\nnpm install 安装依赖.\n\n```js\nvar mongoose = require(\"mongoose\");\nmongoose.connect(\"mongodb://localhost:27017/test\");\n```\n\n然后引用\n\n```js\nmongoose.on('error',console.error.bind(console,'连接错误:'));\nmongoose.once('open',function(){\n  //一次打开记录\n});\n```\n\n### db - 数据库操作\n\n挂接数据库连接事件,参数1: 也可以是error.\n\n```js\nmongoose.connection.on('open', callback);\n```\n\n### Schema - 表结构\n#### 1.构造函数\n\n```js\n    var PersonSchema = new mongoose.Schema({\n      name:String   //定义一个属性name，类型为String\n    });\n```\n\n#### 2.添加属性\n\n```js\nSchema.add({\n\tname: 'String',\n\temail: 'String',\n\tage: 'Number'\n})\n```\n\n#### 3.有时候Schema不仅要为后面的Model和Entity提供公共的属性，还要提供公共的方法\n\n```js\nSchema.method('say', function() {\n\tconsole.log('hello');\n})\n//这样Model和Entity的实例就能使用这个方法了\n```\n\n#### 4.添加静态方法\n\n```js\nSchema.static('say', function() {\n\tconsole.log('hello');\n})\n//静态方法，只限于在Model层就能使用\n\n//批量添加\nSchema.statics = {\n  fetch: function(cb) {\n    return this\n      .find({})\n      .sort('meta.updateAt')\n      .exec(cb)\n  },\n\n  findById: function(id, cb) {\n    return this\n      .findOne({\n        _id: id\n      })\n      .exec(cb)\n  }\n}\n```\n\n#### 5.追加方法\n\n```js\nSchema.methods.say = function() {\n\tconsole.log('hello');\n};\n//静态方法，只限于在Model层就能使用\n```\n\n### model - 文档操作\n#### 1.构造函数, 参数1:集合名称, 参数2:Schema实例\n\n```js\nvar PersonModel = mongoose.model('Person',PersonSchema);\n    //如果该Model已经发布，则可以直接通过名字索引到，如下：\n    //var PersonModel = mongoose.model('Person');\n    //如果没有发布，上一段代码将会异常\n```\n\n#### 2.查询, 参数1忽略,或为空对象则返回所有集合文档\n\n```js\nmodel.find({}, callback);\n```\n\n```js\nmodel.find({},field,callback);\n//过滤查询,参数2: {'name':1, 'age':0} 查询文档的返回结果包含name , 不包含age.(_id默认是1)\n```\n\n```js\nmodel.find({},null,{limit:20},callback);\n//过滤查询,参数3: 游标操作 limit限制返回结果数量为20个,如不足20个则返回所有.\n```\n\n```js\nmodel.findOne({}, callback);\n//查询找到的第一个文档\n```\n\n```js\nmodel.findById('obj._id', callback);\n//查询找到的第一个文档,同上. 但是只接受 __id 的值查询\n```\n\n#### 3.创建, 在集合中创建一个文档\n\n```js\nModel.create(文档数据, callback))\n```\n\n#### 4.更新,参数1:查询条件, 参数2:更新对象,可以使用MondoDB的更新修改器\n\n```js\nModel.update(conditions, update, function(error){})\n```\n\n#### 5.删除, 参数1:查询条件\n\n```js\nModel.remove(conditions,callback);\n```\n\n### Entity - 文档操作\n\n#### 1.构造函数, 其实就是model的实例\n\n```js\nnew TestModel( { name:'xueyou', age:21 } );\n```\n\n#### 2.创建, 在集合中创建一个文档.\n\n```js\nEntity.save(callback);\n```\n\n### 更新修改器\n#### '$inc'增减修改器,只对数字有效.下面的实例: 找到 age=22的文档,修改文档的age值自增1\n\n```ja\n Model.update({\n    'age': 22\n}, {\n    '$inc': {\n        'age': 1\n    }\n});\n执行后: age=23\n```\n\n#### '$set' 指定一个键的值,这个键不存在就创建它.可以是任何MondoDB支持的类型.\n\n```js\n Model.update({\n    'age': 22\n}, {\n    '$set': {\n        'age': 'haha'\n    }\n});\n执行后: age='haha'\n```\n\n#### '$unset' 同上取反,删除一个键\n\n```js\n Model.update({\n    'age': 22\n}, {\n    '$unset': {\n        'age': 'haha'\n    }\n});\n执行后: age键不存在\n```\n\n### 数组修改器:\n\n#### '$push' 给一个键push一个数组成员,键不存在会创建\n\n```js\n Model.update({\n    'age': 22\n}, {\n    '$push': {\n        'array': 10\n    }\n});\n执行后: 增加一个 array 键,类型为数组, 有一个成员 10\n```\n\n#### '$addToSet' 向数组中添加一个元素,如果存在就不添加\n\n```js\n Model.update({\n     'age': 22\n }, {\n     '$addToSet': {\n         'array': 10\n     }\n });\n执行后: array中有10所以不会添加\n```\n\n#### '$each' 遍历数组, 和 $push 修改器配合可以插入多个值\n\n```js\n Model.update({\n    'age': 22\n}, {\n    '$push': {\n        'array': {\n            '$each': [1, 2, 3, 4, 5]\n        }\n    }\n});\n执行后: array : [10,1,2,3,4,5]\n```\n\n#### '$pop' 向数组中尾部删除一个元素\n\n```js\n Model.update({\n    'age': 22\n}, {\n    '$pop': {\n        'array': 1\n    }\n});\n执行后: array : [10,1,2,3,4]  tips: 将1改成-1可以删除数组首部元素\n```\n\n#### '$pull' 向数组中删除指定元素\n\n```js\n Model.update({\n    'age': 22\n}, {\n    '$pull': {\n        'array': 10\n    }\n});\n执行后: array : [1,2,3,4]  匹配到array中的10后将其删除\n```\n\n### 条件查询:\n\n* \"$lt\"\t小于\n* \"$lte\"\t小于等于\n* \"$gt\"\t大于\n* \"$gte\"\t大于等于\n* \"$ne\"\t不等于\n\n```js\n Model.find({\n \t\"age\": {\n \t\t\"$gte\": 18,\n\t\t\"$lte\": 30\n\t}\n});\n//查询 age 大于等于18并小于等于30的文档\n```\n\n### 或查询 OR:\n\n* '$in' 一个键对应多个值\n* '$nin' 同上取反, 一个键不对应指定值\n* \"$or\" 多个条件匹配, 可以嵌套 $in 使用\n* \"$not\"\t同上取反, 查询与特定模式不匹配的文档\n\n```js\nModel.find({\n\t\"age\": {\n\t\t\"$in\": [20, 21, 22.' haha']\n\t}\n});\n//查询 age等于20或21或21或'haha'的文档\n```\n\n```js\nModel.find({\n\t\"$or\": [{\n\t\t\"age\": 18\n\t}, {\n\t\t\"name\": \"xueyou\"\n\t}]\n});\n//查询 age等于18 或 name等于'xueyou' 的文档\n```\n\n### 类型查询:\n\nnull 能匹配自身和不存在的值, 想要匹配键的值 为null, 就要通过  \"$exists\" 条件判定键值已经存在\n\"$exists\" (表示是否存在的意思)\n\n```js\n Model.find(\"age\": {\n \t\"$in\": [null],\n\t\"exists\": true\n});\n//查询 age值为null的文档\n```\n\n```js\nModel.find({\n\tname: {\n\t\t$exists: true\n\t}\n}, function(error, docs) {\n//查询所有存在name属性的文档\n});\n```\n\n```js\nModel.find({\n\ttelephone: {\n\t\t$exists: false\n\t}\n}, function(error, docs) {\n//查询所有不存在telephone属性的文档\n});\n```\n\n### 正则表达式:\n\nMongoDb 使用 Prel兼容的正则表达式库来匹配正则表达式\n\n```js\n find({\n \t\"name\": /joe/i\n})\n//查询name为 joe 的文档, 并忽略大小写\n```\n\n```js\n find({\n \t\"name\": /joe?/i\n})\n//查询匹配各种大小写组合\n```\n\n### 查询数组:\n\n```js\nModel.find({\n\t\"array\": 10\n});\n//查询 array(数组类型)键中有10的文档,  array : [1,2,3,4,5,10]  会匹配到\n```\n\n```js\n Model.find({\n \t\"array[5]\": 10\n});\n//查询 array(数组类型)键中下标5对应的值是10,  array : [1,2,3,4,5,10]  会匹配到\n```\n\n#### '$all' 匹配数组中多个元素\n\n```js\n Model.find({\n \t\"array\": [5, 10]\n});\n//查询 匹配array数组中 既有5又有10的文档\n```\n\n#### '$size' 匹配数组长度\n\n```js\n Model.find({\n \t\"array\": {\n\t\t\"$size\": 3\n\t}\n});\n//查询 匹配array数组长度为3 的文档\n```\n\n#### '$slice' 查询子集合返回\n\n```js\n Model.find({\n \t\"array\": {\n\t\t\"$skice\": 10\n\t}\n});\n//查询 匹配array数组的前10个元素\n```\n\n```js\n Model.find({\n \t\"array\": {\n\t\t\"$skice\": [5, 10]\n\t}\n});\n//查询 匹配array数组的第5个到第10个元素\n```\n\n### where\n\n用它可以执行任意javacript语句作为查询的一部分,如果回调函数返回 true 文档就作为结果的一部分返回\n\n```js\nfind({\n\t\"$where\": function() {\n\t\tfor (var x in this) {\n\t\t\t//这个函数中的 this 就是文档\n\t\t}\n\n\t\tif (this.x !== null && this.y !== null) {\n\t\t\treturn this.x + this.y === 10 ? true : false;\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n})\n```\n\n简化版本\n\n```js\nfind({\n\t\"$where\": \"this.x + this.y === 10\"\n})\nfind({\n\t\"$where\": \" function(){ return this.x + this.y ===10; } \"\n})\n```\n\n### 游标:\n\n* limit(3)\t限制返回结果的数量,\n* skip(3)\t跳过前3个文档,返回其余的\n* sort( {\"username\":1 , \"age\":-1 } )\t排序 键对应文档的键名, 值代表排序方向, 1 升序, -1降序\n\n## 参考\n\n* [Mongoose 参考手册](https://cnodejs.org/topic/548e54d157fd3ae46b233502)\n* [Mongoose学习参考文档](https://cnodejs.org/topic/504b4924e2b84515770103dd)\n* [汇智网](http://cw.hubwiz.com/card/c/543b2e7788dba02718b5a4bd/1/1/1/)\n","tags":["mongoose","mongodb"],"categories":["Node"]},{"title":"centos7中firewall防火墙常用命令","url":"/2017/02/27/centos7中firewall防火墙常用命令/","content":"\n![](//blogimg.jakeyu.top/firewall/firewall%202.jpeg)\n\n<!--more-->\n\n最近在搭建小程序服务端的时候想远程连接服务器mongodb数据库，发现一直出错，原来是这货。\n\nfirewall是centos7的一大特性，最大的好处有两个：\n\n* 支持动态更新\n* 不用重启服务；\n\n## 开启、关闭firewall\n### 启动：\n\n\tsystemctl start firewalld\n\n### 查看状态：\n\n\tsystemctl status firewalld 或者 firewall-cmd –state\n\n### 停止：\n\n\tsystemctl disable firewalld\n\n### 禁用：\n\n\tsystemctl stop firewalld\n\n\n## 端口操作\n### 打开一个端口：\n\tfirewall-cmd --permanent --add-port=8080/tcp\n\n### 关闭一个端口：\n\tfirewall-cmd --permanent --remove-port=8080/tcp\n\n### 打开某项服务： \n\tfirewall-cmd --permanent --add-service=http\n\n### 关闭某项服务： \n\tfirewall-cmd --permanent --remove-service=http\n\n### 进行端口转发： \n\tfirewall-cmd --permanent --add-forward-port=port=80:proto=tcp:toport=8080:toaddr=192.0.2.55\n\n### 允许转发到其他地址：\n\tfirewall-cmd --permanent --add-masquerade\n\n### 重新加载防火墙：\n\tfirewall-cmd --reload\n\n## 配置firewall\n### 查看版本：\n\tfirewall-cmd –version\n\n### 查看帮助：\n\tfirewall-cmd –help\n\n### 查看设置：\n* 显示状态：$ firewall-cmd –state\n* 查看区域信息: $ firewall-cmd –get-active-zones\n* 查看指定接口所属区域：$ firewall-cmd –get-zone-of-interface=eth0\n\n### 拒绝所有包：\n\tfirewall-cmd –panic-on\n\n### 取消拒绝状态：\n\tfirewall-cmd –panic-off\n\n### 查看是否拒绝：\n\tfirewall-cmd –query-panic\n\n","tags":["服务器"],"categories":["服务器"]},{"title":"nodejs使用redis数据库缓存数据","url":"/2017/02/27/nodejs使用redis数据库缓存数据/","content":"\n![](//blogimg.jakeyu.top/redis/redis.jpg)\n\n<!--more-->\n\n## 运行redis\n\nRedis服务器默认使用6379端口\n\n> redis-server\n\n自定义端口\n\n> redis-server --port 6390\n\n客户端\n\n> redis-cli\n\n指定ip和端口连接\n\n> redis-cli -h 127.0.0.1 -p 6390\n\n测试客户端和服务器是否连通\n\n> ping\n\n![](//blogimg.jakeyu.top/nodejs%E4%BD%BF%E7%94%A8redis/Jietu20170227-102308.jpg)\n\n## Nodejs连接redis\n\n通过`redis.createClient(port,host,options)`来连接redis服务器\n\n```js\nvar redis = require(\"redis\")\nvar client = redis.createClient();\n```\n\n```js\n/*client.HMSET 保存哈希键值*/\nclient.HMSET(key,val,function(err,result){\n    if(err){\n        return callback({code:0,msg:err});\n    }\n    callback({code:1,msg:result});\n    /*设置过期时间为1天*/\n    client.EXPIRE(bottleId,86400);\n});\n```\n\n```js\n/*随机返回当前数据库的一个键*/\nclient.RANDOMKEY(function(err,key){\n    if(!key){\n        return callback({code:0,msg:'没有数据'});\n    }\n    /*根据key返回哈希对象*/\n    client.HGETALL(key,function(err,val){\n        if(err){\n            return callback({code:0,msg:err});\n        }\n        callback({code:1,msg:val});\n        /*根据key删除键值*/\n        client.DEL(key);\n    });\n});\n```\n\n## Redis常用命令\n\n[Redis命令参考手册](http://redisdoc.com/index.html)\n\n### 清空数据库\n> FLUSHALL\n\n### 删除key\n> DEL key\n\n### 检查key是否存在。\n> EXISTS key //字符串\n> HEXISTS key field \t//查看哈希表 key 中，指定的字段是否存在。\n\n### 返回key所储存的值的类型。\n> TYPE key \n\n### 获取key所存储的值\n#### 字符串\n> GET key \n\n#### 哈希\n> HGETALL key \t//获取在哈希表中指定 key 的所有字段和值\n\n\n\n\n","tags":["数据库"],"categories":["Node"]},{"title":"表单文件上传","url":"/2017/01/10/表单文件上传/","content":"`FormData`对象使用一些键值对来模拟一个完整的表单，然后使用ajax发送这个`FormData`对象，后端便可以拿到表单中上传的文件。\n\n## 前端处理\n### HTML代码\n\n```html\n<form>\n\t<input type=\"file\" id=\"uploadFile\" name=\"file\">\n</form>\n```\n\n如果只想上传图片：\n\n```html\n<input id=\"uploadFile\" type=\"file\" name=\"file\" accept=\"image/png,image/gif\"/>\n```\n\n可配置属性：\n\n* accept：表示可以选择的文件MIME类型，多个MIME类型用英文逗号分开，常用的MIME类型见下表。\n* multiple：是否可以选择多个文件，多个文件时其value值为第一个文件的虚拟路径。\n\n### 常用MIME类型\n\n|后缀名  |    MIME名称|\n|------|------|\n|*.3gpp |   audio/3gpp, video/3gpp|\n|*.ac3  |  audio/ac3|\n|*.asf  |     allpication/vnd.ms-asf|\n|*.au   |        audio/basic|\n|*.css  |         text/css|\n|*.csv  |         text/csv|\n|*.doc  |  application/msword|\n|*.dot  |  application/msword    |\n|*.dtd  |  application/xml-dtd    |\n|*.dwg  |  image/vnd.dwg    |\n|*.dxf  |    image/vnd.dxf|\n|*.gif  |          image/gif    |\n|*.htm  |  text/html    |\n|*.html  |  text/html    |\n|*.jp2  |          image/jp2    |\n|*.jpe  |     image/jpeg|\n|*.jpeg  |  image/jpeg|\n|*.jpg   |       image/jpeg    |\n|*.js    |   text/javascript, application/javascript    |\n|*.json  |  application/json    |\n|*.mp2  |  audio/mpeg, video/mpeg    |\n|*.mp3  |  audio/mpeg    |\n|*.mp4  |  audio/mp4, video/mp4    |\n|*.mpeg  |  video/mpeg    |\n|*.mpg  |  video/mpeg    |\n|*.mpp  |  application/vnd.ms-project    |\n|*.ogg  |  application/ogg, audio/ogg    |\n|*.pdf  |  application/pdf    |\n|*.png  |  image/png    |\n|*.pot  |  application/vnd.ms-powerpoint    |\n|*.pps   | application/vnd.ms-powerpoint    |\n|*.ppt  |  application/vnd.ms-powerpoint    |\n|*.pptx  |  application/vnd.openxmlformats-officedocument.presentationml.presentation    |\n|*.rtf  |          application/rtf, text/rtf    |\n|*.svf  |         image/vnd.svf    |\n|*.tif  |       image/tiff    |\n|*.tiff |      image/tiff    |\n|*.txt  |         text/plain    |\n|*.wdb  |  application/vnd.ms-works    |\n|*.wps  |  application/vnd.ms-works    |\n|*.xhtml |   application/xhtml+xml    |\n|*.xlc  |    application/vnd.ms-excel    |\n|*.xlm  |  application/vnd.ms-excel    |\n|*.xls  |         application/vnd.ms-excel    |\n|*.xlsx  |   application/vnd.openxmlformats-officedocument.spreadsheetml.sheet|\n|*.xlt  |    application/vnd.ms-excel    |\n|*.xlw   |   application/vnd.ms-excel    |\n|*.xml |   text/xml, application/xml    |\n|*.zip  |          aplication/zip    |\n\n### javascript代码\n\n```js\n$('#uploadFile').on('change',function(e){\n    var file = this.files[0];\n    \n    var formData = new FormData();\n    formData.append('file',file);\n    \n    $.ajax({\n        url: '/webgl/upload/zip',\n        type: 'post',\n        data: formData,\n        cache: false,\n        contentType: false,\n        processData: false,\n        success: function(res){\n           //\n        }\n    })\n})\n```\n\n这里我是在文件被选择上传后就会立即触发`ajax`上传文件事件，而表单中其他字段我没有使用`FormData`对象，所以`<form>`标签没有添加`enctype=\"multipart/form-data\"`属性。\n\n> 注：\n> * `processData`设置为`false`。因为`data`值是`FormData`对象，不需要对数据做处理。\n> * `cache`设置为`false`，上传文件不需要缓存。\n> * `contentType`设置为`false`。\n\n## nodejs代码\n### multer模块\n\n我使用了`multer`模块，[更多信息](https://www.npmjs.com/package/multer)。初始化`multer`模块配置\n\n```js\nvar storageZip = multer.diskStorage({\n    destination: function(req, file, cb) {\n      cb(null, 'public/uploads/zip')\t\t//文件存储路径\n    },\n    filename: function(req, file, cb) {\n      cb(null, file.fieldname + '-' + Date.now() + '.zip')\t//对文件重新命名，防止文件名冲突\n    }\n  })\n\n  var uploadZip = multer({\n    storage: storageZip\n  });\n```\n\n### 路由配置\n\n```js\napp.post('/webgl/upload/zip', uploadZip.single('file'), function(req, res) {\n    res.json(req.file)\n  })\n```\n\n* 这里`single()`参数名就是使用`FormData.append()`方法添加时的文件名，这里我用的是`file`。\n* 上传结束之后，会把`file`对象返回给前端，`file`对象会包含文件名等信息。","tags":["JS"],"categories":["前端"]},{"title":"Hexo博客部署到服务器","url":"/2016/12/06/Hexo博客搭建到服务器并自动部署/","content":"\n# 服务器环境配置\n\n我使用的是`root`执行，因为服务器只有我一个人用，不会出什么问题\n\n## 安装git和nginx\n\n请查看[CentOS7 + nodejs + nginx + MySQL搭建服务器](http://i.jakeyu.top/2016/10/17/centos+nodejs+nginx+mysql%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8)\n\n## 配置ssh\n\n执行：\n\n\tcat ~/.ssh/id_rsa.pub\n\n把拿到的公钥添加到`~/.ssh/authorized_keys`中\n\n如果你之前没有生成过公钥，则可能就没有 id_rsa.pub 文件,[查看这里](https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/)\n\n## 初始化仓库\n\n\tcd /home/jake\n\tsudo git init --bare m.git\n\n使用 `--bare` 参数，`Git` 就会创建一个裸仓库，裸仓库没有工作区，我们不会在裸仓库上进行操作，它只为共享而存在。\n\n## 配置git hooks\n\n我们这里要使用的是 `post-receive` 的 hook，这个 hook 会在整个 git 操作过程完结以后被运行。\n\n在 `m.git/hooks` 目录下新建一个 `post-receive` 文件：\n\n\tcd /home/jake/m.git/hooks\n\tvim post-receive\n\n在 `post-receive` 文件中写入如下内容：\n\n\t#!/bin/sh\n\tgit --work-tree=/home/jake/m --git-dir=/home/jake/m.git checkout -f\n\n`/home/jake/m` 要换成你自己的部署目录。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。\n\n设置这个文件的可执行权限：\n\n\tchmod +x post-receive\n\n## Nginx配置\n\n我用的是lnmp(如果是直接安装的Nginx，配置文件为`/etc/nginx/nginx.conf`)\n\n\tcd /usr/local/nginx/conf/vhost\n\tvim m.conf\n\n输入下面配置\n\n```sh\nserver\n{\n    listen 80;\n    #listen [::]:80;\n    server_name i.jakeyu.top;\n    index index.html index.htm index.php default.html default.htm default.php;\n    #这里要改成网站的根目录\n    root  /home/jake/m;  \n    \n    #error_page   404   /404.html;\n    location ~ .*\\.(ico|gif|jpg|jpeg|png|bmp|swf)$\n    {\n        access_log   off;\n        expires      1d;\n    }\n\n    location ~ .*\\.(js|css|txt|xml)?$\n    {\n        access_log   off;\n        expires      12h;\n    }\n\n    location / {\n        try_files $uri $uri/ =404;\n    }\n\n    access_log  /home/jake/m.log;\n}\n\n```\n\n测试nginx配置是否可以用\n\n\tnginx -t\n\n如果返回`successful`，就表示成功了。重启`Nginx`\n\n\tservice nginx restart\n\n# 本地配置\n\n修改博客根目录下`_config.yml`文件\n\n```\n deploy:\n   type: git\n   repo: \n     vps: root@115.159.2.254:/home/jake/m.git\n```\n\n然后执行:\n\n\thexo new 测试.md\n\thexo d -g\n\n访问刚刚的配置的域名就可以访问自己的网站了\n\n![](//blogimg.jakeyu.top/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/m.jpg)\n\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"sass用法","url":"/2016/12/04/sass用法/","content":"\n今天改一套模版，要用到sass，之前一直用的是less，索性就大概看看sass语法和编译。\n\n![](//blogimg.jakeyu.top/20170327149054550084076.jpg)\n\n<!--more-->\n\n# 什么是SASS\n\nSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。\n\n本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看[官方文档](http://sass-lang.com/documentation/file.SASS_REFERENCE.html)\n了。\n\n# 安装和使用\n## 安装\n\nSASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。\n\n假定你已经安装好了Ruby，接着在命令行输入下面的命令：\n\n> gem install sass\n\n## 使用\n\nSASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。\n\n下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。）\n\n> sass test.scss\n\n如果要将显示结果保存成文件，后面再跟一个.css文件名。\n\n> sass test.scss test.css\n\nSASS提供四个[编译风格](http://sass-lang.com/documentation/file.SASS_REFERENCE.html#output_style)的选项：\n\n> 1. nested：嵌套缩进的css代码，它是默认值。\n> 2. expanded：没有缩进的、扩展的css代码。\n> 3. compact：简洁格式的css代码。\n> 4. compressed：压缩后的css代码。\n\n生产环境当中，一般使用最后一个选项。\n\n> sass --style compressed test.sass test.css\n\n你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。\n\n> // watch a file\n> sass --watch input.scss:output.css\n> // watch a directory\n> sass --watch app/sass:public/stylesheets\n\nSASS的官方网站，提供了一个[在线转换器](http://sass-lang.com/try.html)。你可以在那里，试运行下面的各种例子。\n\n# 基本用法\n## 变量\n\nSASS允许使用变量，所有变量以$开头。\n\n```sass\n$blue : #1875e7;　\n　　div {\n　　　color : $blue;\n　　}\n```\n\n如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。\n\n```sass\n　$side : left;\n　　.rounded {\n　　　　border-#{$side}-radius: 5px;\n　　}\n```\n\n## 计算功能\n\nSASS允许在代码中使用算式：\n\n```sass\n　body {\n　　　　margin: (14px/2);\n　　　　top: 50px + 100px;\n　　　　right: $var * 10%;\n　　}\n```\n\n## 嵌套\n\nSASS允许选择器嵌套。比如，下面的CSS代码：\n\n```css\ndiv h1 {\n　　　　color : red;\n　　}\n```\n\n可以写成：\n\n```sass\n　div {\n　　　　hi {\n　　　　　　color:red;\n　　　　}\n　　}\n```\n\n属性也可以嵌套，比如border-color属性，可以写成：\n\n```sass\n　p {\n　　　　border: {\n　　　　　　color: red;\n　　　　}\n　　}\n```\n\n注意，border后面必须加上冒号。\n\n在嵌套的代码块内，可以使用&引用父元素。比如a:hover伪类，可以写成：\n\n```sass\n　　a {\n　　　　&:hover { color: #ffb3ff; }\n　　}\n```\n\n## 注释\n\nSASS共有两种注释风格。\n\n标准的CSS注释 /* comment */ ，会保留到编译后的文件。\n\n单行注释 // comment，只保留在SASS源文件中，编译后被省略。\n\n在/*后面加一个感叹号，表示这是\"重要注释\"。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。\n\n```sass\n　　/*! \n　　　　重要注释！\n　　*/\n```\n\n# 代码的重用\n## 继承\n\nSASS允许一个选择器，继承另一个选择器。比如，现有class1：\n\n```sass\n　　.class1 {\n　　　　border: 1px solid #ddd;\n　　}\n```\n\nclass2要继承class1，就要使用@extend命令：\n\n```sass\n　　.class2 {\n　　　　@extend .class1;\n　　　　font-size:120%;\n　　}\n```\n\n## Mixin\n\nMixin有点像C语言的宏（macro），是可以重用的代码块。\n\n使用@mixin命令，定义一个代码块。\n\n```sass\n　　@mixin left {\n　　　　float: left;\n　　　　margin-left: 10px;\n　　}\n```\n\n使用@include命令，调用这个mixin。\n\n```sass\n　　div {\n　　　　@include left;\n　　}\n```\n\nmixin的强大之处，在于可以指定参数和缺省值。\n\n```sass\n　　@mixin left($value: 10px) {\n　　　　float: left;\n　　　　margin-right: $value;\n　　}\n```\n\n使用的时候，根据需要加入参数：\n\n```sass\n　　div {\n　　　　@include left(20px);\n　　}\n```\n\n下面是一个mixin的实例，用来生成浏览器前缀。\n\n```sass\n　　@mixin rounded($vert, $horz, $radius: 10px) {\n　　　　border-#{$vert}-#{$horz}-radius: $radius;\n　　　　-moz-border-radius-#{$vert}#{$horz}: $radius;\n　　　　-webkit-border-#{$vert}-#{$horz}-radius: $radius;\n　　}\n```\n\n使用的时候，可以像下面这样调用：\n\n```sass\n　　#navbar li { @include rounded(top, left); }\n　　#footer { @include rounded(top, left, 5px); }\n```\n\n## 颜色函数\n\nSASS提供了一些内置的颜色函数，以便生成系列颜色。\n\n```sass\n　　lighten(#cc3, 10%) // #d6d65c\n　　darken(#cc3, 10%) // #a3a329\n　　grayscale(#cc3) // #808080\n　　complement(#cc3) // #33c\n```\n\n## 插入文件\n\n@import命令，用来插入外部文件。\n\n```sass\n@import \"path/filename.scss\";\n```\n\n如果插入的是.css文件，则等同于css的import命令。\n\n```sass\n　　@import \"foo.css\";\n```\n\n# 高级用法\n## 条件语句\n\n@if可以用来判断：\n\n```sass\n　　p {\n　　　　@if 1 + 1 == 2 { border: 1px solid; }\n　　　　@if 5 < 3 { border: 2px dotted; }\n　　}\n```\n\n配套的还有@else命令：\n\n```sass\n　　@if lightness($color) > 30% {\n　　　　background-color: #000;\n　　} @else {\n　　　　background-color: #fff;\n　　}\n```\n\n##  循环语句\n\nSASS支持for循环：\n\n```sass\n　　@for $i from 1 to 10 {\n　　　　.border-#{$i} {\n　　　　　　border: #{$i}px solid blue;\n　　　　}\n　　}\n```\n\n也支持while循环：\n\n```sass\n　　$i: 6;\n　　@while $i > 0 {\n　　　　.item-#{$i} { width: 2em * $i; }\n　　　　$i: $i - 2;\n　　}\n```\n\neach命令，作用与for类似：\n\n```sass\n　　@each $member in a, b, c, d {\n　　　　.#{$member} {\n　　　　　　background-image: url(\"/image/#{$member}.jpg\");\n　　　　}\n　　}\n```\n\n## 自定义函数\n\nSASS允许用户编写自己的函数。\n\n```sass\n　　@function double($n) {\n　　　　@return $n * 2;\n　　}\n　　#sidebar {\n　　　　width: double(5px);\n　　}\n```\n\n> 作者： 阮一峰\n> 日期： 2012年6月19日\n> 原文： [SASS用法指南](http://www.ruanyifeng.com/blog/2012/06/sass.html)","tags":["sass"],"categories":["前端"]},{"title":"前端解决跨域问题的8种方案","url":"/2016/12/02/前端解决跨域问题/","content":"\n> [原文](http://www.cnblogs.com/JChen666/p/3399951.html)\n\n## 同源策略\n\n| URL                                      | 说明         | 是否允许通信 |\n| ---------------------------------------- | ---------- | ------ |\n| http://www.a.com/a.js<br/>http://www.a.com/b.js | 同一域名下      | 允许     |\n| http://www.a.com/lab/a.js<br/>http://www.a.com/script/b.js | 同一域名下不同文件夹 | 允许     |\n| http://www.a.com:8000/a.js<br/>http://www.a.com/b.js | 同一域名，不同端口  | 不允许    |\n| http://www.a.com/a.js<br/>https://www.a.com/b.js | 同一域名，不同协议  | 不允许 |\n| http://www.a.com/a.js<br/>http://70.32.92.74/b.js | 域名和域名对应ip | 不允许 |\n| http://www.a.com/a.js<br/>http://script.a.com/b.js | 主域相同，子域不同 | 不允许 |\n| http://www.a.com/a.js<br/>http://a.com/b.js | 同一域名，不同二级域名（同上） | 不允许（cookie这种情况下也不允许访问） |\n| http://www.cnblogs.com/a.js<br/>http://www.a.com/b.js | 不同域名 | 不允许 |\n\n* 特别注意\n\t* 如果是协议和端口造成的跨域问题“前台”是无能为力的，\n\t* 在跨域问题上，域仅仅是通过“URL的首部”来识别而不会去尝试判断相同的ip地址对应着两个域或两个域是否在同一个ip上。\n\n“URL的首部”指`window.location.protocol +window.location.host`，也可以理解为“Domains, protocols and ports must match”。\n\n## 前端解决跨域问题\n\n### CORS\n\nCORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n\n#### IE中对CORS的实现是xdr\n\n```js\nvar xdr = new XDomainRequest();\nxdr.onload = function(){\n    console.log(xdr.responseText);\n}\nxdr.open('get', 'http://www.baidu.com');\n......\nxdr.send(null);\n```\n\n#### 其它浏览器中的实现就在xhr中\n\n```js\nvar xhr =  new XMLHttpRequest();\nxhr.onreadystatechange = function () {\n    if(xhr.readyState == 4){\n        if(xhr.status >= 200 && xhr.status < 304 || xhr.status == 304){\n            console.log(xhr.responseText);\n        }\n    }\n}\nxhr.open('get', 'http://www.baidu.com');\n......\nxhr.send(null);\n```\n\n#### 实现跨浏览器的CORS\n\n```js\nfunction createCORS(method, url){\n    var xhr = new XMLHttpRequest();\n    if('withCredentials' in xhr){\n        xhr.open(method, url, true);\n    }else if(typeof XDomainRequest != 'undefined'){\n        var xhr = new XDomainRequest();\n        xhr.open(method, url);\n    }else{\n        xhr = null;\n    }\n    return xhr;\n}\nvar request = createCORS('get', 'http://www.baidu.com');\nif(request){\n    request.onload = function(){\n        ......\n    };\n    request.send();\n}\n```\n\n#### 关于更详细的CORS讲解\n\n* [跨域资源共享 CORS 详解--阮一峰](http://www.ruanyifeng.com/blog/2016/04/cors)\n* [前端跨域的整理](https://qiutc.me/post/cross-domain-collections.html)\n\n### document.domain + iframe(只有在主域相同的时候才能使用该方法)\n\n在www.a.com/a.html中\n\n```js\ndocument.domain = 'a.com';\nvar ifr = document.createElement('iframe');\nifr.src = 'http://www.script.a.com/b.html';\nifr.display = none;\ndocument.body.appendChild(ifr);\nifr.onload = function(){\n    var doc = ifr.contentDocument || ifr.contentWindow.document;\n    //在这里操作doc，也就是b.html\n    ifr.onload = null;\n};\n```\n\n在www.script.a.com/b.html中：\n\n```js\ndocument.domain = 'a.com';\n```\n\n### 动态创建script\n\n这个没什么好说的，因为script标签不受同源策略的限制。\n\n```js\nfunction loadScript(url, func) {\n  var head = document.head || document.getElementByTagName('head')[0];\n  var script = document.createElement('script');\n  script.src = url;\n\n  script.onload = script.onreadystatechange = function(){\n    if(!this.readyState || this.readyState=='loaded' || this.readyState=='complete'){\n      func();\n      script.onload = script.onreadystatechange = null;\n    }\n  };\n\n  head.insertBefore(script, 0);\n}\nwindow.baidu = {\n  sug: function(data){\n    console.log(data);\n  }\n}\nloadScript('http://suggestion.baidu.com/su?wd=w',function(){console.log('loaded')});\n//我们请求的内容在哪里？\n//我们可以在chorme调试面板的source中看到script引入的内容\n```\n\n### location.hash + iframe\n\n原理是利用location.hash来进行传值。\n\n假设域名a.com下的文件cs1.html要和cnblogs.com域名下的cs2.html传递信息。\n1. cs1.html首先创建自动创建一个隐藏的iframe，iframe的src指向cnblogs.com域名下的cs2.html页面\n2. cs2.html响应请求后再将通过修改cs1.html的hash值来传递数据\n3. 同时在cs1.html上加一个定时器，隔一段时间来判断location.hash的值有没有变化，一旦有变化则获取获取hash值\n\n> 注：由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于a.com域名下的一个代理iframe\n\n代码如下：\n\n先是a.com下的文件cs1.html文件：\n\n```js\nfunction startRequest(){\n    var ifr = document.createElement('iframe');\n    ifr.style.display = 'none';\n    ifr.src = 'http://www.cnblogs.com/lab/cscript/cs2.html#paramdo';\n    document.body.appendChild(ifr);\n}\n\nfunction checkHash() {\n    try {\n        var data = location.hash ? location.hash.substring(1) : '';\n        if (console.log) {\n            console.log('Now the data is '+data);\n        }\n    } catch(e) {};\n}\nsetInterval(checkHash, 2000);\n```\n\ncnblogs.com域名下的cs2.html:\n\n```js\n//模拟一个简单的参数处理操作\nswitch(location.hash){\n    case '#paramdo':\n        callBack();\n        break;\n    case '#paramset':\n        //do something……\n        break;\n}\n\nfunction callBack(){\n    try {\n        parent.location.hash = 'somedata';\n    } catch (e) {\n        // ie、chrome的安全机制无法修改parent.location.hash，\n        // 所以要利用一个中间的cnblogs域下的代理iframe\n        var ifrproxy = document.createElement('iframe');\n        ifrproxy.style.display = 'none';\n        ifrproxy.src = 'http://a.com/test/cscript/cs3.html#somedata';    // 注意该文件在\"a.com\"域下\n        document.body.appendChild(ifrproxy);\n    }\n}\n```\n\na.com下的域名cs3.html\n\n```js\n//因为parent.parent和自身属于同一个域，所以可以改变其location.hash的值\nparent.parent.location.hash = self.location.hash.substring(1);\n```\n\n### window.name + iframe\n\n`window.name` 的美妙之处：`name` 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。\n\n1. 创建a.com/cs1.html\n2. 创建a.com/proxy.html，并加入如下代码:\n\n```js\n<head>\n  <script>\n  function proxy(url, func){\n    var isFirst = true,\n        ifr = document.createElement('iframe'),\n        loadFunc = function(){\n          if(isFirst){\n            ifr.contentWindow.location = 'http://a.com/cs1.html';\n            isFirst = false;\n          }else{\n            func(ifr.contentWindow.name);\n            ifr.contentWindow.close();\n            document.body.removeChild(ifr);\n            ifr.src = '';\n            ifr = null;\n          }\n        };\n\n    ifr.src = url;\n    ifr.style.display = 'none';\n    if(ifr.attachEvent) ifr.attachEvent('onload', loadFunc);\n    else ifr.onload = loadFunc;\n\n    document.body.appendChild(iframe);\n  }\n</script>\n</head>\n<body>\n  <script>\n    proxy('http://www.baidu.com/', function(data){\n      console.log(data);\n    });\n  </script>\n</body>\n```\n\n在b.com/cs1.html中包含：\n\n```js\n<script>\n    window.name = '要传送的内容';\n</script>\n```\n\n### postMessage（HTML5中的XMLHttpRequest Level 2中的API）\n\na.com/index.html中的代码：\n\n```js\n<iframe id=\"ifr\" src=\"b.com/index.html\"></iframe>\n<script type=\"text/javascript\">\nwindow.onload = function() {\n    var ifr = document.getElementById('ifr');\n    var targetOrigin = 'http://b.com';  // 若写成'http://b.com/c/proxy.html'效果一样\n                                        // 若写成'http://c.com'就不会执行postMessage了\n    ifr.contentWindow.postMessage('I was there!', targetOrigin);\n};\n</script>\n```\n\nb.com/index.html中的代码：\n\n```js\n<script type=\"text/javascript\">\n    window.addEventListener('message', function(event){\n        // 通过origin属性判断消息来源地址\n        if (event.origin == 'http://a.com') {\n            alert(event.data);    // 弹出\"I was there!\"\n            alert(event.source);  // 对a.com、index.html中window对象的引用\n                                  // 但由于同源策略，这里event.source不可以访问window对象\n        }\n    }, false);\n</script>\n```\n\n### JSONP\n\nJSONP包含两部分：`回调函数`和`数据`。\n\n回调函数是当响应到来时要放在当前页面被调用的函数。\n\n数据就是传入回调函数中的json数据，也就是回调函数的参数了。\n\n```js\nfunction handleResponse(response){\n    console.log('The responsed data is: '+response.data);\n}\nvar script = document.createElement('script');\nscript.src = 'http://www.baidu.com/json/?callback=handleResponse';\ndocument.body.insertBefore(script, document.body.firstChild);\n/*handleResonse({\"data\": \"zhe\"})*/\n//原理如下：\n//当我们通过script标签请求时\n//后台就会根据相应的参数(json,handleResponse)\n//来生成相应的json数据(handleResponse({\"data\": \"zhe\"}))\n//最后这个返回的json数据(代码)就会被放在当前js文件中被执行\n//至此跨域通信完成\n```\n\n jsonp虽然很简单，但是有如下缺点：\n\n* 安全问题(请求代码中可能存在安全隐患)\n* 要确定jsonp请求是否失败并不容易\n\n### web sockets\n\nweb sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)\n\nweb sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。\n\n只有在支持web socket协议的服务器上才能正常工作。\n\n```js\nvar socket = new WebSockt('ws://www.baidu.com');//http->ws; https->wss\nsocket.send('hello WebSockt');\nsocket.onmessage = function(event){\n    var data = event.data;\n}\n```","tags":["方案"],"categories":["前端"]},{"title":"利用CSS、JavaScript及Ajax实现图片预加载","url":"/2016/11/28/图片预加载/","content":"\n> 原文：[3 Ways to Preload Images with CSS, JavaScript, or Ajax](https://perishablepress.com/3-ways-preload-images-css-javascript-ajax/) \n\n预加载图片是提高用户体验的一个很好方法。图片预先加载到浏览器中，访问者便可顺利地在你的网站上冲浪，并享受到极快的加载速度。这对图片画廊及图片占据很大比例的网站来说十分有利，它保证了图片快速、无缝地发布，也可帮助用户在浏览你网站内容时获得更好的用户体验。本文将分享三个不同的预加载技术，来增强网站的性能与可用性。\n\n## 用CSS和JavaScript实现预加载\n\n单纯的使用css可以将图片加载到页面元素的背景上，这种方法简单、高效：\n\n```css\n#preload-01 { background: url(http://domain.tld/image-01.png) no-repeat -9999px -9999px; }\n#preload-02 { background: url(http://domain.tld/image-02.png) no-repeat -9999px -9999px; }\n#preload-03 { background: url(http://domain.tld/image-03.png) no-repeat -9999px -9999px; }\n```\n\n将这三个ID选择器应用到(X)HTML元素中，我们便可通过CSS的background属性将图片预加载到屏幕外的背景上。只要这些图片的路径保持不变，当它们在Web页面的其他地方被调用时，浏览器就会在渲染过程中使用预加载（缓存）的图片。简单、高效，不需要任何JavaScript。\n\n> 弊端：该方法虽然高效，但仍有改进余地。使用该法加载的图片会同页面的其他内容一起加载，增加了页面的整体加载时间。为了解决这个问题，我们增加了一些JavaScript代码，来推迟预加载的时间，直到页面加载完毕。代码如下：\n\n```js\nfunction preloader() {\n    if (document.getElementById) {\n        document.getElementById(\"preload-01\").style.background = \"url(http://domain.tld/image-01.png) no-repeat -9999px -9999px\";\n        document.getElementById(\"preload-02\").style.background = \"url(http://domain.tld/image-02.png) no-repeat -9999px -9999px\";\n        document.getElementById(\"preload-03\").style.background = \"url(http://domain.tld/image-03.png) no-repeat -9999px -9999px\";\n    }\n}\nfunction addLoadEvent(func) {\n    var oldonload = window.onload;\n    if (typeof window.onload != 'function') {\n        window.onload = func;\n    } else {\n        window.onload = function() {\n            if (oldonload) {\n                oldonload();\n            }\n            func();\n        }\n    }\n}\naddLoadEvent(preloader);\n```\n\n在该脚本的第一部分，我们获取使用类选择器的元素，并为其设置了background属性，以预加载不同的图片。\n\n该脚本的第二部分，我们使用addLoadEvent()函数来延迟preloader()函数的加载时间，直到页面加载完毕。\n\n如果JavaScript无法在用户的浏览器中正常运行，会发生什么？很简单，图片不会被预加载，当页面调用图片时，正常显示即可。\n\n## 使用JavaScript实现\n\n上述方法有时确实很高效，但我们逐渐发现它在实际实现过程中会耗费太多时间。相反，我更喜欢使用纯JavaScript来实现图片的预加载。下面将提供两种这样的预加载方法，它们可以很漂亮地工作于所有现代浏览器之上。\n\n### 方法一\n\n只需简单编辑、加载所需要图片的路径与名称即可，很容易实现：\n\n```js\n<div class=\"hidden\">\n    <script type=\"text/javascript\">\n            var images = new Array()\n            function preload() {\n                for (i = 0; i < preload.arguments.length; i++) {\n                    images[i] = new Image()\n                    images[i].src = preload.arguments[i]\n                }\n            }\n            preload(\n                \"http://domain.tld/gallery/image-001.jpg\",\n                \"http://domain.tld/gallery/image-002.jpg\",\n                \"http://domain.tld/gallery/image-003.jpg\"\n            )\n    </script>\n</div>\n```\n\n该方法尤其适用预加载大量的图片。我的画廊网站使用该技术，预加载图片数量达50多张。将该脚本应用到登录页面，只要用户输入登录帐号，大部分画廊图片将被预加载。 \n\n### 方法二\n\n该方法与上面的方法类似，也可以预加载任意数量的图片。将下面的脚本添加入任何Web页中，根据程序指令进行编辑即可。\n\n```js\n<div class=\"hidden\">\n    <script type=\"text/javascript\">\n            if (document.images) {\n                img1 = new Image();\n                img2 = new Image();\n                img3 = new Image();\n                img1.src = \"http://domain.tld/path/to/image-001.gif\";\n                img2.src = \"http://domain.tld/path/to/image-002.gif\";\n                img3.src = \"http://domain.tld/path/to/image-003.gif\";\n            }\n    </script>\n</div>\n```\n\n正如所看见，每加载一个图片都需要创建一个变量，如“img1 = new Image();”，及图片源地址声明，如“img3.src = \"../path/to/image-003.gif\";”。参考该模式，你可根据需要加载任意多的图片。\n\n我们又对该方法进行了改进。将该脚本封装入一个函数中，并使用 addLoadEvent（），延迟预加载时间，直到页面加载完毕。\n\n```js\nfunction preloader() {\n    if (document.images) {\n        var img1 = new Image();\n        var img2 = new Image();\n        var img3 = new Image();\n        img1.src = \"http://domain.tld/path/to/image-001.gif\";\n        img2.src = \"http://domain.tld/path/to/image-002.gif\";\n        img3.src = \"http://domain.tld/path/to/image-003.gif\";\n    }\n}\nfunction addLoadEvent(func) {\n    var oldonload = window.onload;\n    if (typeof window.onload != 'function') {\n        window.onload = func;\n    } else {\n        window.onload = function() {\n            if (oldonload) {\n                oldonload();\n            }\n            func();\n        }\n    }\n}\naddLoadEvent(preloader);\n```\n\n## 使用Ajax\n\n上面所给出的方法似乎不够酷，那现在来看一个使用Ajax实现图片预加载的方法。该方法利用DOM，不仅仅预加载图片，还会预加载CSS、JavaScript等相关的东西。使用Ajax，比直接使用JavaScript，优越之处在于JavaScript和CSS的加载不会影响到当前页面。该方法简洁、高效。\n\n```js\nwindow.onload = function() {\n    setTimeout(function() {\n        // XHR to request a JS and a CSS\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', 'http://domain.tld/preload.js');\n        xhr.send('');\n        xhr = new XMLHttpRequest();\n        xhr.open('GET', 'http://domain.tld/preload.css');\n        xhr.send('');\n        // preload image\n        new Image().src = \"http://domain.tld/preload.png\";\n    }, 1000);\n};\n```\n\n上面代码预加载了“preload.js”、“preload.css”和“preload.png”。1000毫秒的超时是为了防止脚本挂起，而导致正常页面出现功能问题。\n\n下面，我们看看如何用JavaScript来实现该加载过程：\n\n```js\nwindow.onload = function() {\n \n    setTimeout(function() {\n \n        // reference to <head>\n        var head = document.getElementsByTagName('head')[0];\n \n        // a new CSS\n        var css = document.createElement('link');\n        css.type = \"text/css\";\n        css.rel  = \"stylesheet\";\n        css.href = \"http://domain.tld/preload.css\";\n \n        // a new JS\n        var js  = document.createElement(\"script\");\n        js.type = \"text/javascript\";\n        js.src  = \"http://domain.tld/preload.js\";\n \n        // preload JS and CSS\n        head.appendChild(css);\n        head.appendChild(js);\n \n        // preload image\n        new Image().src = \"http://domain.tld/preload.png\";\n \n    }, 1000);\n \n};\n```\n\n这里，我们通过DOM创建三个元素来实现三个文件的预加载。正如上面提到的那样，使用Ajax，加载文件不会应用到加载页面上。从这点上看，Ajax方法优越于JavaScript。\n","tags":["方案"],"categories":["前端"]},{"title":"实现图片懒加载(lazyload)","url":"/2016/11/26/实现图片懒加载/","content":"\n对于图片较多的页面，使用懒加载可以大幅提高页面加载速度，提高用户体验。\n\n![](//blogimg.jakeyu.top/20170321149008892238857.jpg)\n\n<!--more-->\n\n## 懒加载的意义（为什么要使用懒加载）\n\n对页面加载速度影响最大的就是图片，一张普通的图片可以达到几M的大小，而代码也许就只有几十KB。当页面图片很多时，页面的加载速度缓慢，几S钟内页面没有加载完成，也许会失去很多的用户。\n\n所以，对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样子对于页面加载性能上会有很大的提升，也提高了用户体验。\n\n## 原理\n\n将页面中的img标签src指向一张小图片或者src为空，然后定义`data-src`（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。`src`指向一张默认的图片，否则当`src`为空时也会向服务器发送一次请求。可以指向`loading`的地址。\n\n> 注：图片要指定宽高\n\n```html\n<img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" />\n```\n\n当载入页面时，先把可视区域内的img标签的`data-src`属性值负给`src`，然后监听滚动事件，把用户即将看到的图片加载。这样便实现了懒加载。\n\n## 代码\n\n在写代码前，需要了解各种高度。先看这篇文章[scrollTop,offsetTop,scrollLeft,offsetLeft](http://i.jakeyu.top/2016/09/04/scrollTop-offsetTop-scrollLeft-offsetLeft/)\n\n```html\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n        img {\n            display: block;\n            margin-bottom: 50px;\n            width: 400px;\n            height: 400px;\n        }\n    </style>\n</head>\n\n<body>\n\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n    <img src=\"default.jpg\" data-src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\" alt=\"\">\n\n</body>\n```\n\n### JavaScript\n\n```js\n<script>\n    var num = document.getElementsByTagName('img').length;\n    var img = document.getElementsByTagName(\"img\");\n    var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历\n\n    lazyload(); //页面载入完毕加载可是区域内的图片\n\n    window.onscroll = lazyload;\n\n    function lazyload() { //监听页面滚动事件\n        var seeHeight = document.documentElement.clientHeight; //可见区域高度\n        var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度\n        for (var i = n; i < num; i++) {\n            if (img[i].offsetTop < seeHeight + scrollTop) {\n                if (img[i].getAttribute(\"src\") == \"default.jpg\") {\n                    img[i].src = img[i].getAttribute(\"data-src\");\n                }\n                n = i + 1;\n            }\n        }\n    }\n</script>\n```\n\n### jQuery\n\n```js\n<script>\n    var n = 0,\n        imgNum = $(\"img\").length,\n        img = $('img');\n\n    lazyload();\n\n    $(window).scroll(lazyload);\n\n    function lazyload(event) {\n        for (var i = n; i < imgNum; i++) {\n            if (img.eq(i).offset().top < parseInt($(window).height()) + parseInt($(window).scrollTop())) {\n                if (img.eq(i).attr(\"src\") == \"default.jpg\") {\n                    var src = img.eq(i).attr(\"data-src\");\n                    img.eq(i).attr(\"src\", src);\n\n                    n = i + 1;\n                }\n            }\n        }\n    }\n</script>\n```\n\n## 使用节流函数进行性能优化\n\n如果直接将函数绑定在`scroll`事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。\n\n我想实现限制触发频率，来优化性能。\n\n节流函数：只允许一个函数在N秒内执行一次。下面是一个简单的节流函数：\n\n```js\n// 简单的节流函数\n//fun 要执行的函数\n//delay 延迟\n//time  在time时间内必须执行一次\nfunction throttle (fun, delay, time) {\n  let timeout\n\n  let startTime = new Date()\n\n  return function () {\n    let context = this\n\n    let args = Array.prototype.slice.call(arguments)\n\n    let curTime = new Date()\n\n    clearTimeout(timeout)\n    if (curTime - startTime >= time) {\n      // 如果达到了规定的触发时间间隔，触发 handler\n      fun.apply(context, args)\n      startTime = curTime\n    } else {\n      // 没达到触发间隔，重新设定定时器\n      timeout = setTimeout(function () {\n        fun.apply(context, args)\n      }, delay)\n    }\n  }\n};\n// 实际想绑定在 scroll 事件上的 handler\nfunction lazyload(event) {}\n// 采用了节流函数\nwindow.addEventListener('scroll',throttle(lazyload,500,1000));\n```\n\n## 使用去抖函数进行性能优化\n\n去抖相比较节流函数要稍微简单一点，去抖是让函数延迟执行，而节流比去抖多了一个在一定时间内必须要执行一次。\n\n```js\n// debounce函数用来包裹我们的事件\nfunction debounce (fn, delay) {\n  // 持久化一个定时器 timer\n  let timer = null\n  // 闭包函数可以访问 timer\n  return function () {\n    // 通过 'this' 和 'arguments'\n    // 获得函数的作用域和参数\n    let context = this\n    let args = Array.prototype.slice.call(arguments)\n    // 如果事件被触发，清除 timer 并重新开始计时\n    clearTimeout(timer)\n    timer = setTimeout(function () {\n      fn.apply(context, args)\n    }, delay)\n  }\n}\n\n// 实际想绑定在 scroll 事件上的 handler\nfunction lazyload(event) {}\n// 采用了去抖函数\nwindow.addEventListener('scroll',throttle(lazyload,500));\n```\n","tags":["方案"],"categories":["前端"]},{"title":"img加载图片失败时，使用默认图片","url":"/2016/11/26/img加载图片失败时，使用默认图片/","content":"\n### onError属性\n\n`img`标签自带`onError`属性，当图片加载失败时，触发`error`事件：\n\n```html\n<img src=\"image.png\" onError='this.src=\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\"' />\n```\n\n### jQuery的error事件\n\n```js\n$('img').error(function(){\n    $(this).attr('src',\"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\");\n});\n```\n\n### jQuery的one绑定\n\n使用onerror或者jQuery的error事件时，如果默认图片也发生加载失败，则会形成死循环，最好的办法是使用one绑定事件，只执行一次\n\n```js\n$(\"img\").one(\"error\", function(e){\n     $(this).attr(\"src\", \"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg\");\n});\n```\n\n### 注：\n\n* 另外error事件，不支持冒泡，jquery.delegate函数捕捉不到error事件。\n","tags":["方案"],"categories":["前端"]},{"title":"理解this","url":"/2016/11/21/理解this/","content":"\nJavaScript中this和其它语言中的不同。在下面这些情况中，分别有不同的指向\n\n## 函数调用\n\n```js\nfunction foo() {\n    console.log(this);  //window\n}\n\nfoo();\n```\n\n这里this指向全局对象，浏览器中的全局对象为window\n\n## 方法调用\n\n```js\n        var foo = {\n            method: function() {\n                console.log(this);\n            }\n        }\n\n        foo.method(); //返回foo\n```\n\n假如我们把这个方法负值给一个变量再调用会怎么样，我们试试：\n\n```js\n var foo = {\n    method: function() {\n        console.log(this);\n    }\n}\n\nfoo.method(); //返回foo\nvar abc = foo.method;\nabc();\t//window\n```\n\n是不是很神奇，一会我会说一个简便的理解方法。\n\n## 构造函数\n\n```js\nnew foo(); \n```\n\n这种形式我们称之为构造函数，这时this指向新创建的对象\n\n## 主动设置this\n\n```js\nfunction foo(name) {\n    console.log(this);\n};\n\nfunction obj() {};\n\nfoo.call(this, 'jake'); //window\nfoo.call(obj, 'Jake'); //obj\n```\n\n当时我们使用call或者apply时，传入的第一个参数即位this\n\n## 简便理解\n\n我们可以将函数调用转化为call的形式，call中第一个参数即位调用的函数前面的部分。\n\n### 直接调用\n\n我们可以将\n\n```js\nfoo();\n```\n转化为\n\n```js\nfoo.call();\n```\n\n此时foo前面没有对象，没有给call传入this参数，此时默认为全局对象，即window\n\n### 方法调用\n\n方法调用时，我们可以将\n\n```js\nfoo.method();\n```\n\n转化为\n\n```js\nfoo.method.call(foo);\n```\n\nmethod前面的对象为foo，则此时前面的this指向foo对象。\n\n","tags":["JS"],"categories":["前端"]},{"title":"移动端头部整理","url":"/2016/11/03/移动端头部整理/","content":"移动端的头部标签和meta\n \n<!--more-->\n\n```html\n<!-- iOS 设备 begin -->\n<meta name=\"apple-mobile-web-app-title\" content=\"标题\">\n<!-- 添加到主屏后的标题（iOS 6 新增） -->\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\"/>\n<!-- 是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏 -->\n<!--设置屏幕缩放-->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\">\n\n<meta name=\"apple-itunes-app\" content=\"app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL\">\n<!-- 添加智能 App 广告条 Smart App Banner（iOS 6+ Safari） -->\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"/>\n<!-- 设置苹果工具栏颜色 -->\n<meta name=\"format-detection\" content=\"telphone=no, email=no\"/>\n<!-- 忽略页面中的数字识别为电话，忽略email识别 -->\n<!-- 启用360浏览器的极速模式(webkit) -->\n<meta name=\"renderer\" content=\"webkit\">\n<!-- 避免IE使用兼容模式 -->\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge, chrome=1\">\n<!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->\n<meta name=\"HandheldFriendly\" content=\"true\">\n<!-- 微软的老式浏览器 -->\n<meta name=\"MobileOptimized\" content=\"320\">\n<!-- uc强制竖屏 -->\n<meta name=\"screen-orientation\" content=\"portrait\">\n<!-- QQ强制竖屏 -->\n<meta name=\"x5-orientation\" content=\"portrait\">\n<!-- UC强制全屏 -->\n<meta name=\"full-screen\" content=\"yes\">\n<!-- QQ强制全屏 -->\n<meta name=\"x5-fullscreen\" content=\"true\">\n<!-- UC应用模式 -->\n<meta name=\"browsermode\" content=\"application\">\n<!-- QQ应用模式 -->\n<meta name=\"x5-page-mode\" content=\"app\">\n<!-- windows phone 点击无高光 -->\n<meta name=\"msapplication-tap-highlight\" content=\"no\">\n<!-- iOS 图标 begin -->\n<link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"/>\n<!-- iPhone 和 iTouch，默认 57x57 像素，必须有 -->\n<link rel=\"apple-touch-icon-precomposed\" sizes=\"114x114\" href=\"/apple-touch-icon-114x114-precomposed.png\"/>\n<!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 -->\n<link rel=\"apple-touch-icon-precomposed\" sizes=\"144x144\" href=\"/apple-touch-icon-144x144-precomposed.png\"/>\n<!-- Retina iPad，144x144 像素，可以没有，但推荐有 -->\n<!-- iOS 图标 end -->\n\n<!-- iOS 启动画面 begin -->\n<link rel=\"apple-touch-startup-image\" sizes=\"768x1004\" href=\"/splash-screen-768x1004.png\"/>\n<!-- iPad 竖屏 768 x 1004（标准分辨率） -->\n<link rel=\"apple-touch-startup-image\" sizes=\"1536x2008\" href=\"/splash-screen-1536x2008.png\"/>\n<!-- iPad 竖屏 1536x2008（Retina） -->\n<link rel=\"apple-touch-startup-image\" sizes=\"1024x748\" href=\"/Default-Portrait-1024x748.png\"/>\n<!-- iPad 横屏 1024x748（标准分辨率） -->\n<link rel=\"apple-touch-startup-image\" sizes=\"2048x1496\" href=\"/splash-screen-2048x1496.png\"/>\n<!-- iPad 横屏 2048x1496（Retina） -->\n\n<link rel=\"apple-touch-startup-image\" href=\"/splash-screen-320x480.png\"/>\n<!-- iPhone/iPod Touch 竖屏 320x480 (标准分辨率) -->\n<link rel=\"apple-touch-startup-image\" sizes=\"640x960\" href=\"/splash-screen-640x960.png\"/>\n<!-- iPhone/iPod Touch 竖屏 640x960 (Retina) -->\n<link rel=\"apple-touch-startup-image\" sizes=\"640x1136\" href=\"/splash-screen-640x1136.png\"/>\n<!-- iPhone 5/iPod Touch 5 竖屏 640x1136 (Retina) -->\n<!-- iOS 启动画面 end -->\n\n<!-- iOS 设备 end -->\n<meta name=\"msapplication-TileColor\" content=\"#000\"/>\n<!-- Windows 8 磁贴颜色 -->\n<meta name=\"msapplication-TileImage\" content=\"icon.png\"/>\n<!-- Windows 8 磁贴图标 -->\n\n<link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\"/>\n<!-- 添加 RSS 订阅 -->\n<link rel=\"shortcut icon\" type=\"image/ico\" href=\"/favicon.ico\"/>\n<!-- 添加 favicon icon -->\n\n<title>标题</title>\n```\n\n    ","tags":["HTML","移动端"],"categories":["移动端"]},{"title":"6个字符的JavaScript之旅","url":"/2016/10/27/6个字符的JavaScript之旅/","content":"\n# 探秘JavaScript中的六个字符\n\n> 本文转载自：[众成翻译](http://www.zcfy.cc)\n> 译者：[小青年](http://www.zcfy.cc/@zhaomenghuan)\n> 链接：[http://www.zcfy.cc/article/1370](http://www.zcfy.cc/article/1370)\n> 原文：[http://jazcash.com/a-javascript-journey-with-only-six-characters/](http://jazcash.com/a-javascript-journey-with-only-six-characters/)\n\nJavaScript 是一个奇怪而有趣的语言，我们可以写一些疯狂却仍然有效的代码。它试图帮助我们把事情转换到基于我们如何对待他们的特定类型。\n\n如果我们添加一个字符串,JavaScript会假定我们希望为文本形式表示,所以将它转换为一个字符串。如果我们添加一个正负前缀符号,JavaScript会假定我们希望为数值形式表示,如果可能的话,对我们来说并将字符串转换为一个数字。如果我们添加一个否定符号，JavaScript会将将字符串转换为一个布尔值。\n\n我们可以使用Javascript中`[`,`]`,`(`,`)`,`!` and `+`这六个符号写一些神奇的代码。如果你现在不是在手机，你可以打开浏览器的控制台，你可以将任何代码示例粘贴到控制台，并且代码值为true。\n\n让我们从最基本的开始，要记住一些黄金规则:\n\n`!`后面跟的字符会被转换成布尔值\n\n`+`后面跟的字符会被转换成数值\n\n`[]`后面跟的字符会被转换成字符串\n\n来看下面的例子：\n\n```js\n![] === false\n+[] === 0\n[]+[] === \"\" \n```\n\n另一件事你应该知道的是,它可以从字符串使用方括号检索特定的字母，像这样：\n\n```js\n\"hello\"[0] === \"h\"\n```\n\n还记得可以使多个数字号码通过添加字符串表示在一起,然后把整个表达式转换成一个数字：\n\n```js\n+(\"1\" + \"1\") === 11 \n```\n\n我们们继续把一些东西结合在一起得到字母`a`\n\n```js\n![] === false\n![]+[] === \"false\"\n+!![] === 1\n------------------------\n(![]+[])[+!![]] === \"a\"  // same as \"false\"[1] \n```\n\n举一反三！\n\n我们可以通过`true` 和 `false`得到相似的字母`a`,`e`,`f`,`l`,`r`,`s`,`t`,`u`，那么我们可以从其他地方得到的字母吗？\n\n我们可以通过一些特别的式子如`[][[]]`得到`undefined`，利用我们上面讲到的黄金法则得到另外的字母`d`,`i` 和 `n`。\n\n```js\n`[][[]] + [] === \"undefined\"` \n```\n\n到目前为止，利用我们已经获得的所有字母,我们可以拼`fill`, `filter` 和 `find`。当然也有一些其他的单词，我们也可以拼写，但这些单词最重要的是,他们都是[数组的方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)。这意味着他们是数组对象的一部分,可以直接调用数组实例，如：`[2,1].sort()`。\n\n现在，了解JavaScript的另一件重要的特性是一个对象的属性可以通过[点符号`.`或方括号`[]`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors)访问。上述数组方法是数组对象本身的属性，我们可以使用方括号代替点符号调用这些方法。\n\n所以`[2,1][\"sort\"]()` 等效于 `[2,1].sort()`.\n\n我们继续看看,当我们试图使用一个数组的方法会发生什么,我们可以使用到目前为止我们拼写的但没有调用的字母。\n\n```js\n[][\"fill\"]\n```\n\n这会得到`function fill() { [native code] }`，我们可以把这个方法头作为一个字符串再次使用我们的黄金法则：\n\n```js\n[][\"fill\"]+[] === \"function fill() { [native code] }\"\n```\n\n所以现在我们又得到其他的字符：`c`,`o`,`v`,`(`,`)`,`{`,`[`,`]`,`}`。\n\n随着我们新得到的`c`和`o`，我们现在可以形成`constructor`这个单词。构造函数是一个方法,所有JS对象仅返回自己的构造函数。\n\n到目前为止我们已经处理的对象，我们可以得到它用字符串表示的构造器函数：\n\n```js\ntrue[\"constructor\"] + [] === \"function Boolean() { [native code] }\"  \n0[\"constructor\"] + []    === \"function Number() { [native code] }\"  \n\"\"[\"constructor\"] + []   === \"function String() { [native code] }\"\n[][\"constructor\"] + []   === \"function Array() { [native code] }\"\n({})[\"constructor\"] + [] === \"function Object() { [native code] }\" \n```\n\n通过这些式子，我们可以将下面的字符加入到我们的库中：\n`B`,`N`,`S`,`A`,`O`,`m`,`b`,`g`,`y`,`j`。\n\n现在我们可以构造一个我们可以使用方括号的函数\"toString\"`,我们可以这样调用：\n\n```js\n(10)[\"toString\"]() === \"10\"\n```\n\n使用我们的黄金法则，我们已经可以将任何我们想要转换成一个字符串，但是上面这个式子怎么用呢？\n\n好吧，我告诉你，`Number`类型的`toString`方法有一个称为`radix`(“基数”)的[秘密的论点](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toString)。它可以将数值在转换为一个字符串之前先经过基数换算，像这样：\n\n```js\n(12)[\"toString\"](10) === \"12\"  // 十进制\n(12)[\"toString\"](2) === \"1100\" // 二进制\n(12)[\"toString\"](8) === \"14\"   // 八进制\n(12)[\"toString\"](16) === \"c\"   // 十六进制 \n```\n\n但是为什么基数只写到16？最大值是36，包括所有的字符`0`-`9` 和 `a`-`z`，所以现在我们可以得到任何我们想要的字母数字：\n\n```js\n(10)[\"toString\"](36) === \"a\"\n(35)[\"toString\"](36) === \"z\" \n```\n\n太棒了!但是其它符号如标点符号和大写字母呢？我们接着深入探索。\n\n这取决于你的JS执行时，它可能会或可能不会访问特定的预定义的对象或数据。如果你在浏览器中运行它,那么你可以访问一些存在的[HTML包装器方法](https://developer.mozilla.org/en-US/docs/tag/HTML%20wrapper%20methods)。\n\n例如，`bold`是一个包装在`<>`标签中的字符串方法。\n\n```js\n\"test\"[\"bold\"]() === \"<b>test</b>\" \n```\n\n通过这个我们得到`<>`和`/`两个字符。\n\n你可能听说过`escape`方法，它主要将字符串转换为一个URI友好的格式，可以让简单的浏览器解释。如果我们传递一个空格字符，我们得到的\"%20\"。\n\n这里有一个工具可以自动将每个字符自动转换。\n工具地址：http://www.jsfuck.com/\n源代码地址：https://raw.githubusercontent.com/aemkei/jsfuck/master/jsfuck.js\n\n## 为什么这几个字符有用？\n\n它不是易趣网做的一些不好的事情,不久前允许卖家将执行JS在页面中使用只能使用这些字符，但它是一个相当罕见的攻击向量。有些人说混淆，但事实上，有更好的方法混淆。\n\n最后，希望你会喜欢本次探秘之旅。\n\n* * *\n\n资源：\n\n*   [https://en.wikipedia.org/wiki/JSFuck](https://en.wikipedia.org/wiki/JSFuck)\n\n*   [https://esolangs.org/wiki/JSFuck](https://esolangs.org/wiki/JSFuck)\n\n*   [http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html](http://patriciopalladino.com/blog/2012/08/09/non-alphanumeric-javascript.html)\n\n*   [https://raw.githubusercontent.com/aemkei/jsfuck/master/jsfuck.js](https://raw.githubusercontent.com/aemkei/jsfuck/master/jsfuck.js)","tags":["JS"],"categories":["前端"]},{"title":"CentOS安装mongodb数据库","url":"/2016/10/21/CentOS安装mongodb数据库/","content":"mongodb是非关系数据库，存储json格式，所以特别适合使用js操作数据库。\n\n![](//blogimg.jakeyu.top/20170327149054574361411.png)\n\n<!--more-->\n\n### 安装 mongodb\n\n#### yum 仓库配置\n> vi /etc/yum.repos.d/mongodb.repo\n\n内容为：\n\n> [mongodb-org-3.2]\n> name=MongoDB Repository\n> baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.2/x86_64/\n> gpgcheck=0\n> enabled=1\n\n#### 安装mongodb:\n\n> yum install -y mongodb-org\n\n#### 使用mongodb:\n\n启动:\n> service mongod start\n\n停止:\n\n> service mongod stop\n\n重启：\n\n> service mongod restart\n\n客户端:\n\n> mongo\n\n### 配置远程连接\n\n#### 添加用户\n\n执行\n> mongo\n> use admin\n\n接着我们创建一个用户，Mongodb在3.0版本时候去除了addUser这个方法，我们需要这样来创建用户\n\n~~~js\ndb.createUser(\n   {\n     user: \"<username>\",\n     pwd: \"<password>\",\n     roles: [ \"readWrite\", \"dbAdmin\" ]\n   }\n)\n//<username> 用户名\n//<password> 密码\n~~~\n\n#### 配置mongodb.conf\n\n> vim /etc/mongod.conf\n\n修改下面配置\n\n> #bindIp = 127.0.0.1   //注释此行\n\n重启mongodb\n\n> service mongod restart\n\n#### 测试连接\n打开本地命令\n\n> mongo 你的服务器ip地址:27017/admin -u <用户> -p <密码>\n\n\n### 卸载\n\n#### 停止服务\n\n> service mongod stop\n\n#### 移除包\n\n> yum erase $(rpm -qa | grep mongodb-org)\n\n#### 移除数据和日志文件\n\n> rm -r /var/log/mongodb   \n> rm -r /var/lib/mongo\n\n### 关于更多mongodb操作，请查看\n[菜鸟教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n","tags":["服务器"],"categories":["服务器"]},{"title":"CentOS7 + nodejs + nginx + MySQL搭建服务器","url":"/2016/10/17/centos+nodejs+nginx+mysql搭建服务器/","content":"最近项目要求，需要一台服务器，阿里和腾讯都不错，我选择了腾讯云，系统为CentOS 7（linux）。记录搭建服务器的过程，方便以后再次搭建是借鉴和给第一次搭建服务器的朋友借鉴之用。\n\n![](//blogimg.jakeyu.top/20170327149054583559344.png)\n\n<!--more-->\n\n# 安装git\n执行：\n> sudo yum install git\n\n# 安装nodejs\n## 使用EPEL安装\nEPEL（Extra Packages for Enterprise Linux）企业版Linux的额外软件包，是Fedora小组维护的一个软件仓库项目，为RHEL/CentOS提供他们默认不提供的软件包。\n先安装epel-release包：\n\n> sudo yum install epel-release\n\n安装完后，就可以使用yum命令安装nodejs了，安装的一般会是较新的版本，并且会将npm作为依赖包一起安装\n\n> sudo yum install nodejs\n\n安装完成后，验证是否正确的安装\n\n> node -v\n> v6.9.4\n\n## 源码安装\n[官网](https://nodejs.org/zh-cn/)查看最新版本\n\n### 下载\n先进入/usr/src文件夹，这个文件夹通常用来存放软件源代码:\n\n> cd /usr/local/src/\n> wget https://nodejs.org/dist/v4.6.0/node-v4.6.0.tar.gz\n\n版本自己替换\n\n### 解压\n\n> tar zxvf node-v4.6.0.tar.gz\n\n### 编译安装\n\n> cd node-v4.6.0/\n> ./configure    // 执行 Node.js 安装包自带的脚本，修改相关的系统配置文件\n\n发现报错了，提示系统中没有安装C编译器，接下来先安装C编译器\n\n安装gcc\n> yum install gcc\n\n安装g++\n> yum install gcc-c++\n\n安装gfortran\n> yum install gcc-gfortran\n\n重新执行：\n\n```sh\ncd node-v4.6.0/\n./configure    // 执行 Node.js 安装包自带的脚本，修改相关的系统配置文件\nmake          //编译 C源代码为 可执行的 Linux程序\n```\n\n好慢啊。。。。。。难道是我买的最低配置的原因么。。。。。。\n\n终于跑完了😂，全程大约十几分钟，所以大家要耐心等待哦。。。。。。\n\n```sh\nsudo make install\t\t\t//\t安装文件\nnode --version\t\t\t\t//查看安装node的版本\nnpm -v\t\t\t\t\t\t//查看npm的版本\n```\n\n现在已经安装了Node.js, 可以开始部署应用程序, 首先要使用Node.js的模块管理器npm安装Express middleware 和forever（一个用来确保应用程序启动并且在需要时重启的非常有用的模块）,其中g参数是把express安装到NodeJS的lib目录，d参数表示同时安装依赖模块包：\n\n```sh\nnpm install -gd express-generator forever\n```\n\n## 建立测试项目并执行\n\n在`/home`文件夹下执行：\n\n```sh\nexpress testapp\ncd testapp\nnpm install\nnpm start\n```\n\n上面，第一条命令是创建express框架通用项目，第三条命令是安装依赖包，第四条是执行。\n执行：\n\n```sh\ncat package.json\n```\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%88%AA%E5%9B%BE%202016-10-17.jpg)\n\n第四条命令就相当于执行了`node ./bin/www`。\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/QQ20161017-1.png)\n\n这样就运行成功了。\n但是当我们关闭终端之后，进程就将结束，现在刚安装的`forever`就派上用场了,`forever`可以让进程在终端关闭之后继续运行：\n\n```sh\nforever start ./bin/www\n```\n\n我们可以使用下面命令查看`forever`运行的程序：\n\n```sh\nforever list\n```\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/QQ20161017-2.png)\n\n现在我们就可以在浏览器中输入：公网IP + :3000，来访问我们的程序。\n如果要修改`3000`端口，我们可以修改`./bin/www`文件中关于监听3000端口的字段。\n\n停止运行：\n\n```sh\nforever stop 0\t\t//0代表前面[0],这是当前进程的ID\n```\n\n停止所有:\n\n```sh\nforever stopall\n```\n\n# 安装Nginx\n\nHTTP请求是80端口，但是在Linux上非root权限是无法使用1024以下端口的，并且因为安全原因，最好不要使用root权限登录服务器，所以无法直接用node.js程序监听80端口。因此我们需要使用Nginx给node.js做反向代理，将80端口指向应用程序监听的端口(如node.js默认的3000端口)。\n\n## 添加Nginx仓库\n\n```sh\nyum install epel-release\n```\n\n## 下载Nginx\n\n```sh\nyum install nginx\n```\n\n\n## 启用nginx服务\n\n```sh\nservice nginx start\n```\n\n## 添加开机启动\n\n```sh\nsystemctl enable nginx\n```\n\n## 修改Nginx配置文件\n\n```sh\nvim /etc/nginx/nginx.conf\t//使用lnpm意见安装，Nginx 目录: /usr/local/nginx/\n```\n\n添加：\n~~~sh\nserver {\n    listen       80;\n    server_name jakexin.top,www.jakexin.top;             #绑定的域名\n\t# 开启gzip\n\tgzip on;\n\t# 启用gzip压缩的最小文件，小于设置值的文件将不会压缩\n\tgzip_min_length 1k;\n\t# gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明\n\tgzip_comp_level 2;\n\t# 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。\n\tgzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;\n\t# 是否在http header中添加Vary: Accept-Encoding，建议开启\n\tgzip_vary on;\n\t# 禁用IE 6 gzip\n\tgzip_disable \"MSIE [1-6]\\.\";\n\t\n\t#配置缓存\n\tlocation ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ { \n        access_log   off; \n        expires      30d;\n\t}\n\tlocation ~* ^.+\\.(css|js|txt|xml|swf|wav)$ {\n\t    access_log   off;\n\t    expires      24h;\n\t}\n\tlocation ~* ^.+\\.(html|htm)$ {\n\t        expires      1h;\n\t}\n\t\n\t\n    location /\n    {\n      proxy_set_header   X-Real-IP            $remote_addr;\n      proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;\n      proxy_set_header   Host                   $http_host;\n      proxy_set_header   X-NginX-Proxy    true;\n      proxy_set_header   Connection \"\";\n      proxy_http_version 1.1;\n      proxy_pass http://127.0.0.1:3000;              #对应该的Nodejs程序端口\n    }\n    access_log  /mnt/log/www/jakexin_access.log;    #网站访问日志\n}\n~~~\n\n## 测试配置文件是否能够正确运行\n\n```sh\nnginx -t\n```\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/QQ20161017-0.png)\n\n这样就是配置成功\n## 重启nginx\n\n```sh\nservice nginx restart\n```\n\n现在直接在浏览器中输入我们配置的域名就可以访问我们的项目了。\n\n# 安装MySQL\n查看可用版本\n\n```sh\nyum list | grep mysql\n```\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/QQ20161014-0.png)\n\n在centOS 7中不能使用`yum -y install mysql mysql-server mysql-devel`安装，这样会默认安装mysql的分支mariadb。\n> MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的\n> 的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。\n\n## 正确的安装方法\n众所周知，Linux系统自带的repo是不会自动更新每个软件的最新版本（基本都是比较靠后的稳定版），所以无法通过yum方式安装MySQL的高级版本。所以我们需要先安装带有当前可用的mysql5系列社区版资源的rpm包。\n\n```sh\nrpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm\nyum repolist enabled | grep \"mysql.*-community.*\"   //查看当前可用资源\n```\n \n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/QQ20161014-2.png)\n从上面的列表可以看出， mysql56-community/x86_64 和 MySQL 5.6 Community Server 可以使用。\n\n因此，我们就可以直接用yum方式安装了MySQL5.6版本了。\n\n```sh\nyum -y install mysql-community-server\n```\n\n## MySQL基础配置\n\n```sh\nsystemctl enable mysqld\t\t//添加到开机启动\nsystemctl start mysqld\t\t//启用进程\nmysql_secure_installation\n```\n\n~~~sh\nNOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL\n      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!\nIn order to log into MySQL to secure it, we'll need the current\npassword for the root user.  If you've just installed MySQL, and\nyou haven't set the root password yet, the password will be blank,\nso you should just press enter here.\nEnter current password for root (enter for none): \nOK, successfully used password, moving on...\nSetting the root password ensures that nobody can log into the MySQL\nroot user without the proper authorisation.\nSet root password? [Y/n] y                  [设置root用户密码]\nNew password: \nRe-enter new password: \nPassword updated successfully!\nReloading privilege tables..\n ... Success!\nBy default, a MySQL installation has an anonymous user, allowing anyone\nto log into MySQL without having to have a user account created for\nthem.  This is intended only for testing, and to make the installation\ngo a bit smoother.  You should remove them before moving into a\nproduction environment.\nRemove anonymous users? [Y/n] y                 [删除匿名用户]\n ... Success!\nNormally, root should only be allowed to connect from 'localhost'.  This\nensures that someone cannot guess at the root password from the network.\nDisallow root login remotely? [Y/n] y       [禁止root远程登录]\n ... Success!\nBy default, MySQL comes with a database named 'test' that anyone can\naccess.  This is also intended only for testing, and should be removed\nbefore moving into a production environment.\nRemove test database and access to it? [Y/n] y          [删除test数据库]\n - Dropping test database...\nERROR 1008 (HY000) at line 1: Can't drop database 'test'; database doesn't exist\n ... Failed!  Not critical, keep moving...\n - Removing privileges on test database...\n ... Success!\nReloading the privilege tables will ensure that all changes made so far\nwill take effect immediately.\nReload privilege tables now? [Y/n] y            [刷新权限]\n ... Success!\n \nAll done!  If you've completed all of the above steps, your MySQL\ninstallation should now be secure.\n\nThanks for using MySQL! \n\nCleaning up...\n~~~\n\n# 操作MySQL\n\n## 配置远程连接\n\n```sh\ngrant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;\t\t\n##添加授权的用户 \n##root是用户名，%代表任意主机，'123456'指定的登录密码（这个和本地的root密码可以设置不同的，互不影响）\nflush privileges;\t//刷新数据库\n```\n\n## 检测是否开启3306端口\n\n> netstat -tunlp\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/QQ20161015-0.png)\n\n看到3306端口被开启之后，我们就可以使用本地客户端远程访问数据库了\n\n![](//blogimg.jakeyu.top//nodejs+MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/%E6%88%AA%E5%9B%BE%202016-10-15%2011%E6%97%B638%E5%88%8609%E7%A7%92.jpg)\n\n## 数据库备份与还原\n### 备份\n\n连接数据库\n\n```sh\nmysql -u root -p\n```\n\n查看数据库\n\n```sh\nshow databases; \n```\n\n![](//blogimg.jakeyu.top/20170628149862866369896.jpg)\n\n退出数据库进行备份\n\n```sh\nmysqldump -u root -p rap_db > rap.sql\n```\n备份完成\n\n### 还原数据库\n\n```sh\nmysqldump -u root -p rap_db < rap.sql\n```","tags":["服务器"],"categories":["服务器"]},{"title":"JS继承方法","url":"/2016/09/09/JS继承方法/","content":"\n![](//blogimg.jakeyu.top/20170327149054592270732.png)\n\n<!--more-->\n## 组合继承\n组合继承，指将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后思路使用用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。\n### 下面来看一个例子\n```js\n\tfunction SuperType(name) {\n\t    this.name = name;\n\t    this.color = ['red', 'blue', 'green'];\n\t};\n\t//\n\tSuperType.prototype.sayName = function() {\n\t    console.log(this.name);\n\t};\n\t//\n\tfunction SubType(name, age) {\n\t    //继承属性\n\t    SuperType.call(this, name);\t\t// 第二次调用SuperType\n\t//\n\t    this.age = age;\n\t};\n\t//继承方法\n\tSubType.prototype = new SuperType();\t// 第一次调用SuperType\n\tconsole.log(SubType.prototype.constructor); //输出SuperType函数的源码,即此时SubType.prototype.constructor指向SuperType函数\n\tSubType.prototype.constructor = SubType; //将SubType.prototype.constructor指针指回SubType函数\n\tSubType.prototype.sayAge = function() {\n\t    console.log(this.age);\n\t};\n\t//\n\tvar instance1 = new SubType('Jake', 20)\n\tinstance1.color.push('black');\n\tconsole.log(instance1.color); //'red,blue,green,black'\n\tinstance1.sayName(); //'Jake'\n\tinstance1.sayAge(); //20\n\t//\n\tvar instance2 = new SubType('Greg', 21);\n\tconsole.log(instance2.color); //'red,blue,green'\n\tinstance2.sayName(); //'Greg';\n\tinstance2.sayAge(); //21\n```\n\n观察输出结果，便可以发现：两个SubType实例（`instance1`和`instance2`）既分别有自己的属性，又可以使用相同的方法。\n\n### 优点\n\n组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，所以是JS中最常用的继承模式。而且，`instanceof`和`isPrototypeOf()`也能够用于识别基于组合继承创建的对象。\n\n### 缺点\n\n* 调用两次SuperType构造函数\n* 在SubType.prototype上创建了不必要的属性\n\n## 寄生组合继承\n\n寄生组合继承\n\n```js\nfunction SuperType (name) {\n  this.name = name\n  this.colors = ['red', 'blue', 'yellow']\n}\n\nSuperType.prototype.sayName = function () {\n  console.log(this.name)\n}\n\nfunction SubType (name, age) {\n  SuperType.call(this, name) // 通过构造函数继承实例属性\n  this.age = age\n}\n\nSubType.prototype = Object.create(SuperType.prototype)\t//继承父类共享方法\nSubType.prototype.constructor = SubType\t//将SubType.prototype.constructor指针指回SubType函数\n\nSubType.prototype.sayAge = function () {\n  console.log(this.age)\n}\n\nlet obj = new SubType('jake', 22)\nobj.sayName()\t// jake\nobj.sayAge()\t// 22\nconsole.log(obj instanceof SubType)\t// true\nconsole.log(obj instanceof SuperType)\t// true\n```\n### 优点\n\n* 寄生组合继承只调用了一次SuperType，所以更高效\n* 避免了在SubType.prototype上创建了不必要的属性\n\n## 下面说说原型链和构造函数的缺点\n### 原型链\n\n缺点：当原型链中包含引用类型值时，原型属性会被所有实例共享；\n\n#### 下面看一个例子\n\n~~~js\nfunction SuperType() {\n    this.color = ['red', 'blue', 'green'];\n}\n//\nfunction SubType() {};\n//\nSubType.prototype = new SuperType(); //继承了SuperType\n//\nvar instance1 = new SubType();\ninstance1.color.push('black');\nconsole.log(instance1.color);   //'red,blue,green,black'\n//\nvar instance2 = new SubType();\nconsole.log(instance2.color);   //'red,blue,green,black'\n~~~\n\n### 借用构造函数\n\n缺点：如果仅仅使用构造函数，方法都在构造函数中定义，因此函数就无法实现复用了。而且，在超类型的原型中定义的方法，对于子类型而言也是不可见的。\n","tags":["JS"],"categories":["前端"]},{"title":"scrollTop等元素距离","url":"/2016/09/04/scrollTop-offsetTop-scrollLeft-offsetLeft/","content":"\n### 关于scrollTop,offsetTop,scrollLeft,offsetLeft用法介绍\n\n<!--more-->\n~~~js\n\t页可见区域宽： document.body.clientWidth;\n\t网页可见区域高： document.body.clientHeight;\n\t网页可见区域宽： document.body.offsetWidth (包括边线的宽);\n\t网页可见区域高： document.body.offsetHeight (包括边线的宽);\n\t网页正文全文宽： document.body.scrollWidth;\n\t网页正文全文高： document.body.scrollHeight;\n\t网页被卷去的高： document.body.scrollTop;\n\t网页被卷去的左： document.body.scrollLeft;\n\t网页正文部分上： window.screenTop;\n\t网页正文部分左： window.screenLeft;\n\t屏幕分辨率的高： window.screen.height;\n\t屏幕分辨率的宽： window.screen.width;\n\t屏幕可用工作区高度： window.screen.availHeight;\n~~~\n\n![](//blogimg.jakeyu.top//ScrollTop/1.jpeg)\n\n\n&nbsp;&nbsp;`offsetTop`, `offsetLeft`：只读属性。要确定的这两个属性的值，首先得确定元素的`offsetParent`。`offsetParent`指的是距该元素最近的`position`不为`static`的祖先元素，如果没有则指向body元素。确定了`offsetParent`，`offsetLeft`指的是元素左侧偏移`offsetParent`的距离，同理`offsetTop`指的是上侧偏移的距离。<br>\n&nbsp;&nbsp;`offsetHeight`, `offsetWidth`：只读属性。这两个属性返回的是元素的高度或宽度，包括元素的边框、内边距和滚动条。返回值是一个经过四舍五入的整数。如下图：<br>\n\n![](//blogimg.jakeyu.top//ScrollTop/2.png)\n\n&nbsp;&nbsp;`scrollHeight`, `scrollWidth`：只读属性。返回元素内容的整体尺寸，包括元素看不见的部分（需要滚动才能看见的）。返回值包括`padding`，但不包括`margin`和`border`。如下图：<br>\n\n![](//blogimg.jakeyu.top//ScrollTop/3.png)\n\n&nbsp;&nbsp;`scrollTop`, `scrollLeft`：图中已经表示的很明白了。如果元素不能被滚动，则为0。<br>\n\n&nbsp;&nbsp;`window.innerWidth`, `window.innerHeight`：只读。视口（viewport）的尺寸，包含滚动条<br>\n\n&nbsp;&nbsp;`clientHeight`, `clientWidth`：包括padding，但不包括border, margin和滚动条。如下图<br>\n\n![](//blogimg.jakeyu.top//ScrollTop/4.png)\n\n&nbsp;&nbsp;`Element.getBoundingClientRect()`：只读，返回浮点值。这个方法非常有用，常用于确定元素相对于视口的位置。该方法会返回一个DOMRect对象，包含`left`, `top`, `width`, `height`, `bottom`, `right`六个属性：<br>\n\n&nbsp;&nbsp;`left`, `right`, `top`, `bottom`：都是元素（不包括margin）相对于视口的原点（视口的上边界和左边界）的距离。<br>\n\n&nbsp;&nbsp;`height`, `width`：元素的整体尺寸，包括被滚动隐藏的部分；`padding`和`border`参与计算。另外，heigth=bottom-top, width=right-left。<br>\n\n### jQuery常用监听页面滚动\n\n#### 当前滚动的地方的窗口顶端到整个页面顶端的距离：\n~~~js\nvar winPos = $(window).scrollTop();\n~~~\n\n#### 获取指定元素的页面位置\n~~~js\n$(val).offset().top;\n~~~\n\n#### 对页面滚动条滚动的监听：要放在页面加载的时候\n~~~js\n$(window).scroll(function(event){});\n~~~\n\n#### 设置滚动条到指定位置\n~~~js\n$(window).scrollTop(offset)\n~~~\n","tags":["JS"],"categories":["前端"]},{"title":"mockjs让前端开发独立于后端","url":"/2016/08/19/mockjs让前端开发不依赖后端/","content":"\n![](//blogimg.jakeyu.top/20170327149054604067872.png)\n\nmock.js 可以模拟ajax数据，拦截ajax请求，返回模拟数据，无需后端返回就可以测试前端程序\n\n[mockjs官网](http://mockjs.com/)\n<!--more-->\n\n首先要感谢凯伦[Kieran](http://go.kieran.top)大神的帮助\n\n话不多说直接进入主题\n\n### 引入文件\n\n首先在head头中引入我们需要的mockjs文件\n\n~~~js   \n    <script src=\"http://mockjs.com/dist/mock.js\"></script>\n~~~\n\n### 定义数据\n\n在ajax请求之前，用mack定义返回数据\n\n~~~js\n    Mock.mock('http://laoyu', {\n     \"errorcode\": 0,//0表示成功，1表示错误\n     \"message\": \"xx信息不完整\", //弹出错误信息\n    });\n~~~\n\n### 创建请求\n\n在ajax中,open()的url要与mock中的相同，比如我这里是`http://laoyu`,那么\n\n~~~js\n    XHR.open（\"post/get\",\"http://laoyu\",true/false）\n~~~\n\n### 测试\n\n好了，说到这里，我们进行测试一下\n\n~~~js\n<script>\n\n//调用mock方法模拟数据\nMock.mock('http://laoyu', {\n  \"errorcode\": 0,//0表示成功，1表示错误\n  \"message\": \"xx信息不完整\", //弹出错误信息\n});\n\n//使用ajax进行测试\nvar xhr = new XMLHttpRequest();\nxhr.open(\"post\",\"http://laoyu\",true);\nxhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\nxhr.send(null);\nxhr.onreadystatechange = function(){\n\tif(xhr.readyState == 4){\n\t\tif((xhr.status>=200 && xhr.status<300) || xhr.status== 304){\n\t\t\tvar data = JSON.parse(xhr.responseText);\t//因为reponseText返回的是字符串，将字符串转换成我们想要的JSON数据，这样就可以调用了\n\n\t\t\tconsole.log(data);  //在控制台中打印出返回的内容\n\t\t}else{\n\t\t\talert(\"Request was unsuccessful: \" + xhr.status);\n\t\t}\n\t}\n}\n</script>\n~~~\n\n![](//blogimg.jakeyu.top//mockjs%E8%AE%A9%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8B%AC%E7%AB%8B%E4%BA%8E%E5%90%8E%E7%AB%AF/312896762343287.jpg)\n\n看到没，返回了我们使用mock模拟的数据，这样就可以无需后台，直接进行自己的测试了\n\n### xhr.readyState的五种状态\n\n    0 － （未初始化）还没有调用open()方法\n    1 － （服务器连接已经建立）已调用open()方法，正在发送请求\n    2 － （请求已接收）send()方法执行完成，已经接收到全部响应内容\n    3 － （请求处理中）正在解析响应内容\n    4 － （请求已完成）响应内容解析完成，可以在客户端调用了\n","tags":["JS"],"categories":["前端"]},{"title":"理解JavaScript闭包","url":"/2016/07/07/理解JavaScript闭包/","content":"理解JavaScript闭包\n<!--more-->\n## 变量的作用域\n\n要理解闭包，必须先理解JavaScript特殊变量的作用域\n\n变量的作用域无非就是两种：**全局变量**、**局部变量**。\n\nJavaScript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n\n~~~js\nvar n = 10;\nfunction f1(){\n\talert(n);\n};\nf1(); //10\n~~~\n\n在函数的外部无法读取函数内部的局部变量\n\n~~~js\nfunction f1(){\n\tvar n = 10;\n};\nf1();\nalert(n); //error:n is not defined\n~~~\n\n注意：在函数内部声明变量的时候，一定要用var。如果不用的话，会声明一个全局变量\n\n~~~js\nfunction f1(){\n\tn = 10;\n};\nf1();\nalert(n); //10\n~~~\n\n## 如何从外部读取局部变量？\n\n有时候，我们需要得到函数内部的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现，那就是在函数内部定义一个函数\n\n~~~js\nfunction f1(){\n\tvar n = 10;\n\tfunction f2(){\n\t\talert(n);\t//10\n\t}\n}\n~~~\n\n在上面的代码中，函数f2就被包括在函数f1内部，这是f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的“链式作用域”结构，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量\n\n~~~js\nfunction f1(){\n\tvar n = 10;\n\tfunction f2(){\n\t\talert(n);\n\t}\n\treturn f2;\n}\nvar result = f1();\nresult();\t//10\n~~~\n\n## 闭包的概念\n\n上面所讲的f2函数，就是闭包\n\n闭包就是能够读取其它函数内部局部变量的函数。\n\n由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。\n\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n## 闭包的用途\n\n闭包可以用在许多地方。它的最大用处有两个：**一个是前面提到的可以读取函数内部的变量**，**另一个就是让这些变量的值始终保存在内存中**\n\n什么意思呢？请看下面的例子\n\n~~~js\nfunction f1(){\n\tvar n = 10;\n\tadd = function(){n+=1;}\n\tfunction f2(){\n\t\talert(n);\n\t}\n\treturn f2;\n} \n\nvar result = f1();\nresult();\t//10\nadd();\nresult();\t//11\n~~~\n\n这段代码中，result实际上就是闭包f2函数。它一共运行两次，第一次值是10，第二次值是11。这说明**函数f1中的局部变量n并没有在f1被调用后被删除，说明n一直保存在内存中**\n\n原因就在于f1是f2的父函数，而f2被赋予了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制回收。\n\n这段代码中另一个值得注意的地方，就是“nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此 nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。\n\n## for循环中的闭包\n\n```js\nfor (var i = 1; i <= 5; i++) {\n    (function(i) {\n        setTimeout( function timer() {\n            console.log(j);\n        },i*1000 ); //这一行将i*1000改为j*1000也行，并不影响\n    })(i);\n}\n```\n\n或者下面写法\n\n```js\nfor (var i = 1; i <= 5; i++) {\n    let j = i;\n    setTimeout(function timer() {\n        console.log(j);\n    },j*1000);\n}\n```\n\n## 如果你能理解下面代码的运行结果，应该就理解闭包的运行机制了\n\n~~~js\nvar name = \"Jake\";\nobj = {\n    name:\"laoyu\",\n    getName: function(){\n        alert(this.name);\n        return function(){\n            alert(this.name);\n        }\n    }\n}\nobj.getName()();  //laoyu   jake\n~~~","tags":["JS"],"categories":["前端"]},{"title":"JavaScript实现继承的几种方式","url":"/2016/06/20/JavaScript实现继承的几种方式/","content":"\n![](//blogimg.jakeyu.top/20170327149054592270732.png)\n\n<!--more-->\n# 原型链继承：\n```js\n    var Base = function() {\n        this.level = 1;  \n        this.name = \"base\";  \n        this.toString = function() {  \n            return \"base\";  \n        };  \n    };  \n    Base.CONSTANT = \"constant\";  \n\n    var Sub = function() {};\n    Sub.prototype = new Base();  \n    Sub.prototype.name = \"sub\";  \n```\n优点：从`instanceof`关键字来看，实例既是父类的实例，又是子类的实例，看起来似乎是最纯粹的继承。\n缺点：子类区别于父类的属性和方法，必须在`Sub.prototype = new Base()`这样的语句之后分别执行，无法被包装到`Sub`这个构造器里面去。例如：`Sub.prototype.name = \"sub\"`无法实现多重继承。\n\n\n# 构造继承：\n```js\n    var Base = function() {\n        this.level = 1;  \n        this.name = \"base\";  \n        this.toString = function() {  \n            return \"base\";  \n        };  \n    };  \n    Base.CONSTANT = \"constant\";  \n\n    var Sub = function() {\n        Base.call(this);  \n        this.name = \"sub\";  \n    };\n```\n优点：可以实现多重继承，可以把子类特有的属性设置放在构造器内部。\n缺点：使用`instanceof`发现，对象不是父类的实例。\n\n\n# 实例继承：\n```js\n    var Base = function() {\n        this.level = 1;  \n        this.name = \"base\";  \n        this.toString = function() {  \n            return \"base\";  \n        };  \n    };  \n    Base.CONSTANT = \"constant\";  \n\n    var Sub = function() {\n        var instance = new Base();  \n        instance.name = \"sub\";  \n        return instance;  \n    };\n```\n优点：是父类的对象，并且使用new构造对象和不使用`new`构造对象，都可以获得相同的效果。\n缺点：生成的对象实质仅仅是父类的实例，并非子类的对象；不支持多继承。\n\n\n# 拷贝继承：\n```js\n    var Base = function() {\n        this.level = 1;  \n        this.name = \"base\";  \n        this.toString = function() {  \n            return \"base\";  \n        };  \n    };  \n    Base.CONSTANT = \"constant\";  \n\n    var Sub = function() {\n        var base = new Base();  \n        for(var i in base)  \n            Sub.prototype[i] = base[i];  \n        Sub.prototype[\"name\"] = \"sub\";  \n    };  \n```\n优点：支持多继承。\n缺点：效率较低；无法获取父类不可枚举的方法。\n\n\n```js\n var Scope = function() {\n\tthis.$clone = function() {\n\t\tvar f = function() {}; //创建一个新的构造函数\n\t\tf.prototype = this; //将它的原型指向 当前的这个Scope 实例\n\t\treturn new f(); //返回 新创建的这个对象的实例\n\t}\n};\n\nvar scopeA = new Scope();\nscopeA.title = 'My title';\n\nvar scopeB = scopeA.$clone();\n//实例有$clone方法用创建一个对象克隆，表现如下\nconsole.log(scopeB.title === 'My title'); //输出true\nscopeA.title = 'Home title';\nconsole.log(scopeB.title === 'Home title'); //输出true\n//但是一旦scopeB主动修改它的属性，scopeA并不受影响\nscopeB.title = 'scopeB title';\nconsole.log(scopeA.title === 'Home title') //输出true\nconsole.log(scopeB.title) //输出 scopeB title\n```\n\n这几种形式各有特点，仅就我提供的代码而言，满足下面的表格：\n\n|            | instanceof父类 | instanceof子类 | 子类constructor | 不可枚举方法的继承 | 多继承可实现 |\n|:---------- |:-------------- | -------------- | --------------- | ------------------ | ------------ |\n| 原型链继承 | TRUE           | TRUE           | FALSE           | TRUE               | FALSE        |\n| 构造继承   | FALSE          | TRUE           | TRUE            | TRUE               | TRUE         |\n| 实例继承   | TRUE           | FALSE          | FALSE           | TRUE               | FALSE        |\n| 拷贝继承   | FALSE          | TRUE           | TRUE            | FALSE              | TRUE         |\n\n\n---------------------------------------------------------------------------------------------------------------------------\n\n##### 补充，如果我们不需要类继承，只需要对象继承，对于支持 ECMAScript 5 的浏览器来说，还可以用Object.create方法来实现：\n```js\n    var Base = function() {\n        this.level = 1;  \n        this.name = \"base\";  \n        this.toString = function() {\n            return \"base\";  \n        };  \n    };  \n    Base.CONSTANT = \"constant\";  \n\n    var sub = Object.create(new Base());  \n    sub.name = \"sub\";  \n```\n\n转载自：<http://raychase.iteye.com/blog/1337415>\n","tags":["JS"],"categories":["前端"]},{"title":"多行文本溢出显示省略号","url":"/2016/05/27/多行文本溢出显示省略号/","content":"\n大家都知道`text-overflow:ellipses`属性用来实现单行文本的溢出显示省略号(...)。当然部分浏览器还需要加`width`属性\n\n```css\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n```\n但这个属性并不支持多行文本溢出显示省略号，下面根据应用场景介绍几个方法来实现多行溢出显示省略号的效果\n\n<!--more-->\n\n### WebKit浏览器或移动端的页面\n在WebKit浏览器或移动端(绝大部分是WebKit内核的浏览器)的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(Webkit是私有属性)`-webkit-line-clamp`;注意：这是一个不规范属性([unsupport WebKit property](https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html))，它没有出现在CSS规范草案中。\n`-webkit-line-clamp`用来限制在一个块元素显示文本的行数。为了实现该效果，它需要组合其他的Webkit属性。\n常见结合属性：\n1、`display:-webkit-box`必须结合的属性，将对象作为弹性伸缩盒子模型显示。\n2、`-webkit-box-orient`必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。\n3、`text-overflow:ellipsis`，可以用来多行文本的情况下，用省略号“...”隐藏超出范围的文本\n\n```css\n  overflow : hidden;\n  text-overflow: ellipsis;\n  display: -webkit-box;\n  -webkit-line-clamp: 2;\n  -webkit-box-orient: vertical;\n```\n\n遇到 `autoprefixer` 之后 `-webkit-box-orient` 消失的情况，可以使用: \n\n```css\n/*! autoprefixer: off */\n-webkit-box-orient: vertical;\n/* autoprefixer: on */\n```\n\n这个属性比较合适WebKit浏览器或移动端(绝大部分是WebKit内核的)。\n\n具体例子可以查看[http://www.css88.com/webkit/-webkit-line-clamp/](http://www.css88.com/webkit/-webkit-line-clamp/)\n### 跨浏览器兼容的方案\n\n比较靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(...)的元素模拟实现；\n\n例如：\n```css\np {\n  position:relative;\n  line-height:1.4em;\n  /* 3 times the line-height to show 3 lines */\n  height:4.2em;\n  overflow:hidden;\n}\np::after {\n  content:\"...\";\n  font-weight:bold;\n  position:absolute;\n  bottom:0;\n  right:0;\n  padding:0 20px 1px 45px;\n  background:url(http://css88.b0.upaiyun.com/css88/2014/09/ellipsis_bg.png) repeat-y;\n}    \n```\n\n看demo：\n<iframe height='265' scrolling='no' src='//codepen.io/JakeLaoyu/embed/bebPam/?height=265&theme-id=dark&default-tab=html,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/JakeLaoyu/pen/bebPam/'>多行文本溢出省略号demo</a> by Jake (<a href='http://codepen.io/JakeLaoyu'>@JakeLaoyu</a>) on <a href='http://codepen.io'>CodePen</a>.\n</iframe>\n\n这里注意几点：\n\n1、height 高度正好是`line-height`的3倍；\n\n2、结束的省略号用了半透明的png做了减淡的效果，或者设置背景颜色\n\n3、IE6-7不显示`content`内容，所以要兼容IE6-7可以是在内容中加入一个标签，比如用`<span class=\"line-clamp\">...</span>`去模拟；\n\n4、要支持IE8，需要将`::after`替换成`:after`\n\n\n\n### JavaScript方案\n\n用js也可以根据上面的思路气模拟，实现也很简单，推荐几个做类似工作的成熟小工具：\n\n#### Clamp.js\n\n下载及文档地址：[Clamp.js](https://github.com/josephschmitt/Clamp.js)\n\n使用也非常简单：\n```js\nvar module = document.getElementById(\"clamp-this-module\");\n$clamp(module, {clamp: 3});\n```\n\nDEMO:\n<iframe height='265' scrolling='no' src='//codepen.io/JakeLaoyu/embed/OXLeEo/?height=265&theme-id=dark&default-tab=js,result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='http://codepen.io/JakeLaoyu/pen/OXLeEo/'>多行文本溢出省略号demo-1</a> by Jake (<a href='http://codepen.io/JakeLaoyu'>@JakeLaoyu</a>) on <a href='http://codepen.io'>CodePen</a>.\n</iframe>\n\n#### jQuery插件-jQuery.dotdotdot\n\n这个使用起来也很方便：\n```js\n    $(document).ready(function() {\n    \t$(\"#wrapper\").dotdotdot({\n    \t\t//\tconfiguration goes here\n    \t});\n    });\n```\n\n下载及详细文档地址：\n\n1. [jQuery.dotdotdot](https://github.com/BeSite/jQuery.dotdotdot)\n2. [dotdotdot](http://dotdotdot.frebsite.nl/)\n\n### 参考：\n* [line-clamp_for_non_webkit-based_browsers](http://www.cssmojo.com/line-clamp_for_non_webkit-based_browsers/#what-can-we-do-across-browsers)\n* [line-clampin](http://css-tricks.com/line-clampin/)\n\n","tags":["JS","HTML","CSS"],"categories":["前端"]},{"title":"一些常用时间处理方法","url":"/2016/05/24/一些常用时间处理方法/","content":"常用时间处理方法\n<!--more-->\n\nvar date = new Date();  //获取当前时间\n\n## 关于当前日期的一些操作\n\n```js\ndate.getMonth() + 1; //月份\ndate.getDate(); //日\ndate.getHours(); //小时\ndate.getMinutes(); //分\ndate.getSeconds();//秒\nMath.floor((date.getMonth() + 3) / 3); //季度\ndate.getMilliseconds(); //毫秒\ndate.getFullYear();    //获取完整的年份(4位,1970-????)\ndate.getDay();      //获取当前星期(0-6,0代表星期天)\ndate.toLocaleDateString();      //获取当前日期   (y/M/d)\ndate.toLocaleString();     //获取日期与时间\n```\n\n## 时间戳转换\n\n### 将时间戳转换成日期\n\n```js\nvar date = new Date(时间戳); //获取一个时间对象\n```\n\n### 将日期转换为时间戳\n\n```js\nvar time = '2018-07-13 18:14:44:123';\nvar date = new Date(time);\n\n// 精确到毫秒\nvar timeParse = +date;\n// 精确到毫秒\nvar timeParse = date.getTime();\n// 精确到毫秒\nvar timeParse = date.valueOf();\n// 精确到秒\nvar timeParse = Date.parse(date);\n```\n\n![](//blogimg.jakeyu.top/一些常用时间处理方法/Jietu20180930-141616.png)\n\n## 若要显示:当前日期加时间(如:2009-06-12 12:00)\n\n```js\nfunction CurentTime() {\n    var now = new Date();   //获取当前时间\n    var year = now.getFullYear();       //年\n    var month = now.getMonth() + 1;     //月\n    var day = now.getDate();            //日\n    var hh = now.getHours();            //时\n    var mm = now.getMinutes();          //分\n\n    var clock = year + \"-\";\n\n    if(month < 10)\n        clock += \"0\";\n\n    clock += month + \"-\";\n\n    if(day < 10)\n        clock += \"0\";\n\n    clock += day + \" \";\n\n    if(hh < 10)\n        clock += \"0\";\n\n    clock += hh + \":\";\n    if (mm < 10) clock += '0';\n    clock += mm;\n    return(clock);\n}\n```\n\n## 一个通用转换时间格式的函数\n\n```js\nfunction dateConvert(date, format) {\n    date = parseInt(date);\n    var Udate = new Date(date);\n    var Y = Udate.getFullYear(),\n        M = (Udate.getMonth() + 1) < 10 ? \"0\" + (Udate.getMonth() + 1) : (Udate.getMonth() + 1),\n        D = Udate.getDate() < 10 ? \"0\" + Udate.getDate() : Udate.getDate(),\n        h = Udate.getHours(),\n        m = Udate.getMinutes(),\n        s = Udate.getSeconds();\n\n    if (!format) {\n        format = \"Y/M/D h:m:s\";\n    }\n\n    if (format.indexOf(\"Y\") >= 0) {\n        format = format.replace(\"Y\", Y);\n    }\n    if (format.indexOf(\"M\") >= 0) {\n        format = format.replace(\"M\", M);\n    }\n    if (format.indexOf(\"D\") >= 0) {\n        format = format.replace(\"D\", D);\n    }\n    if (format.indexOf(\"h\") >= 0) {\n        format = format.replace(\"h\", h);\n    }\n    if (format.indexOf(\"m\") >= 0) {\n        format = format.replace(\"m\", m);\n    }\n    if (format.indexOf(\"s\") >= 0) {\n        format = format.replace(\"s\", s);\n    }\n\n    return format;\n};\n```\n","tags":["JS"],"categories":["前端"]},{"title":"css实现三角形","url":"/2016/05/19/css实现三角形/","content":"css实现三角形\n<!--more-->\n##### 创建一个`<div>`标签\n~~~html\n    <div class=\"triangle\"></div>\n    //把div的width，height都设置为0，然后使用border属性\n~~~\n##### 下面是针对这个div创建的css\n###### 向上的箭头\n~~~css\n    .triangle{\n    \twidth: 0;\n    \theight: 0;\n    \tborder-left: 50px solid transparent;\n    \tborder-right: 50px solid transparent;\n    \tborder-bottom: 100px solid red;\n    }\n~~~\n\n\n###### 向下的箭头\n~~~css\n    .triangle{\n    \twidth: 0;\n    \theight: 0;\n    \tborder-left: 50px solid transparent;\n    \tborder-right: 50px solid transparent;\n    \tborder-top: 100px solid red;\n    }\n~~~\n\n\n###### 向左的箭头\n~~~css\n    .triangle{\n    \twidth: 0;\n    \theight: 0;\n    \tborder-top: 50px solid transparent;\n    \tborder-bottom: 50px solid transparent;\n    \tborder-right: 100px solid red;\n    }\n~~~\n\n\n\n###### 向右的箭头    \n~~~css\n    .triangle{\n    \twidth: 0;\n    \theight: 0;\n    \tborder-top: 50px solid transparent;\n    \tborder-bottom: 50px solid transparent;\n    \tborder-left: 100px solid red;\n    }\n~~~\n\n\n###### 平分一个正方形\n~~~css\n    .triangle{\n    \twidth: 0;\n    \theight: 0;\n    \tborder-right: 50px solid blue;\n    \tborder-left: 50px solid yellow;\n    \tborder-top: 50px solid green;\n    \tborder-bottom: 50px solid red;\n    }\n~~~\n","tags":["CSS"],"categories":["前端"]},{"title":"JavaScript产生随机数","url":"/2016/05/18/JavaScript产生随机数/","content":"JS产生随机数\n<!--more-->\n~~~js\n    1.Math.random(); 结果为0-1间的一个随机数(包括0,不包括1)\n    2.Math.floor(num); 参数num为一个数值，函数结果为num的整数部分。\n    3.Math.round(num); 参数num为一个数值，函数结果为num四舍五入后的整数。\n\n    Math：数学对象，提供对数据的数学计算。\n    Math.random(); 返回0和1间(包括0,不包括1)的一个随机数。\n\n    Math.ceil(n); 返回大于等于n的最小整数。\n    用Math.ceil(Math.random()*10);时，主要获取1到10的随机整数，取0的几率极小。\n\n    Math.round(n); 返回n四舍五入后整数的值。\n    用Math.round(Math.random());可均衡获取0到1的随机整数。\n    用Math.round(Math.random()*10);时，可基本均衡获取0到10的随机整数，其中获取最小值0和最大值10 的几率少一半。\n\n    Math.floor(n); 返回小于等于n的最大整数。\n    用Math.floor(Math.random()*10);时，可均衡获取0到9的随机整数。\n~~~\n### 示例：\n~~~js\n    function GetRandomNum(Min,Max)\n\t{   \n\t\tvar Range = Max - Min;   \n\t\tvar Rand = Math.random();   \n\t\treturn(Min + Math.round(Rand * Range));   \n\t}   \n\tvar num = GetRandomNum(10,100);   \n\talert(num);\n~~~\n","tags":["JS"],"categories":["前端"]},{"title":"设置居中的几种方式","url":"/2016/05/18/设置居中的几种方式/","content":"\n设置居中的几种方式\n\n<!--more-->\n\n\n### 普通水平居中\n~~~css\ndiv{\n    width:200px;\n    margin:0 auto;\n }\n~~~\n\n### 使用尾类垂直居中\n\n```html\n<div class=\"wrap\">\n    <div class=\"content\">\n        \n    </div>\n</div>\n```\n\n```css\n.wrap {\n    height: 500px;\n    background: red;\n}\n    \n.content {\n    width: 100px;\n    height: 100px;\n    background: blue;\n    display: inline-block;\n    vertical-align: middle;\n}\n    \n.wrap:after {\n    content: '';\n    display: inline-block;\n    height: 100%;\n    vertical-align: middle;\n}\n```\n\n### 使用translate居中\n\n这种方式父元素一定要有宽度和高度，`top`继承自父元素。\n\n如果只想设置水平居中或者垂直居中，可以单独设置`translateX`/`translateY`。\n\n~~~css\ndiv{\n\twidth: 100px;\n\theight: 100px;\n\tbackground: red;\t//方便查看效果\n\t\n\tposition: relateive;\n\ttop: 50%;\n\tleft: 50%;\n\ttransform: translate(-50%,-50%);\n}\n~~~\n\n### 浮动元素居中\n\n 确定容器的宽高 宽500 高 300 的层\n\n 设置层的外边距\n\n~~~css\n .div {\n      width:500px ; height:300px;//高度可以不设\n      margin: -150px 0 0 -250px;\n      position:relative;         //相对定位\n      background-color:pink;     //方便看效果\n      left:50%;\n      top:50%;\n }\n~~~\n\n### 绝对定位div居中\n~~~css\ndiv{\n  position: absolute;\n  width: 100px;\n  height: 100px;\n  margin: auto;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  \n  background: red;\n}\n~~~\n\n### 字体图标在div中居中\n\n~~~html\n<div>\n\t<i class=\"fa fa-plus fa-5x\" aria-hidden=\"true\"></i>\n</div>\n~~~\n\n```css\ndiv{\n\twidth:200px;\n\theight:200px;\n\tline-height:200px;\n\ttext-align:center;\n}\n\ni{\n\tvertical-align: middle;\n}\n```","tags":["CSS"],"categories":["前端"]},{"title":"微信页面监听摇一摇事件，并伴有音效","url":"/2016/05/07/微信页面监听摇一摇事件，并伴有音效/","content":"最近要写一个微信网页，需要监听手机摇动事件，并且伴随有声音\n\n在HTML5，devicemotion事件deviceorientation特性的运动传感器的封装时间装置，你可以通过改变运动时间获取设备的状态，加速和其他数据（有另一个角度deviceorientation事件提供设备，定位等信息）。\n\n<!--more-->\n\n而通过DeviceMotion对设备运动状态的判断，则可以帮助我们在网页上就实现“摇一摇”的交互效果。\n\n把监听事件绑定给 deviceMotionHandler\n~~~js\n    if (window.DeviceMotionEvent) {\n        window.addEventListener('devicemotion', deviceMotionHandler, false);\n    } else {\n        alert('本设备不支持devicemotion事件');\n    }\n    获取设备加速度信息 accelerationIncludingGravity\n\n    function deviceMotionHandler(eventData) {\n        var acceleration = eventData.accelerationIncludingGravity,\n        x, y, z;\n        x = acceleration.x;\n        y = acceleration.y;\n        z = acceleration.z;\n        document.getElementById(\"status\").innerHTML = \"x:\"+x+\"<br />y:\"+y+\"<br />z:\"+z;\n    }\n~~~\n“摇一摇”的动作既“一定时间内设备了一定距离”，因此通过监听上一步获取到的x, y, z 值在一定时间范围内  的变化率，即可进行设备是否有进行晃动的判断。而为了防止正常移动的误判，需要给该变化率设置一个合适的临界 值。\n~~~js\n    var SHAKE_THRESHOLD = 800;\n    var last_update = 0;\n    var x = y = z = last_x = last_y = last_z = 0;\n\n    if (window.DeviceMotionEvent) {\n        window.addEventListener('devicemotion', deviceMotionHandler, false);\n    } else {\n    alert('本设备不支持devicemotion事件');\n    }\n\n    function deviceMotionHandler(eventData) {\n        var acceleration = eventData.accelerationIncludingGravity;\n        var curTime = new Date().getTime();\n\n        if ((curTime - last_update) > 100) {\n            var diffTime = curTime - last_update;\n            last_update = curTime;\n            x = acceleration.x;\n            y = acceleration.y;\n            z = acceleration.z;\n            var speed = Math.abs(x + y + z - last_x - last_y - last_z) / diffTime * 10000;\n            var status = document.getElementById(\"status\");\n\n            if (speed > SHAKE_THRESHOLD) {\n                doResult();\n            }\n            last_x = x;\n            last_y = y;\n            last_z = z;\n        }\n    }\n~~~\n100毫秒进行一次位置判断，若前后x, y, z间的差值的绝对值和时间比率超过了预设的阈值，则判断设备进行   了摇晃操作。\n\n## 下面是我改写的代码\n~~~html\n    <audio style=\"display: none;\" src=\"http://xunlei.sc.chinaz.com/files/download/sound1/201410/5018.mp3\" id=\"musicBox\" preload=\"preload\"  controls></audio>\n~~~\n~~~js\n    <script>\n        var SHAKE_THRESHOLD = 3000;    \n        var last_update = 0;    \n        var x=y=z=last_x=last_y=last_z=0;   \n\t   var  media;\n\t   media= document.getElementById(\"musicBox\");\n\t   function init(){\n\t      \tlast_update=new Date().getTime();\n\t       \tif (window.DeviceMotionEvent) {\n\t       \t\twindow.addEventListener('devicemotion',deviceMotionHandler, false);  \n\t       \t} else{\n\t\t  alert('not support mobile event');\n\t\t  }\n\t   }\n        function deviceMotionHandler(eventData) {    \n\t       var acceleration =eventData.accelerationIncludingGravity;\n\t       var curTime = new Date().getTime();\n\t       if ((curTime - last_update)> 100) {  \n\t       \t\tvar diffTime = curTime -last_update;    \n\t       \t\tlast_update = curTime;        \n\t       \t\tx = acceleration.x;\n\t       \t\ty = acceleration.y;   \n\t       \t\tz = acceleration.z;   \n\t       \t\tvar speed = Math.abs(x +y + z - last_x - last_y - last_z) /\n\t       diffTime * 10000; \t\n\t       \t\tif (speed > SHAKE_THRESHOLD) {    \n\t       \t\t\tmedia.play();\n\t       \t\t}    \n\t       \t\tlast_x = x;    \n\t       \t\tlast_y = y;    \n\t       \t\tlast_z = z;    \n\t       \t}\n        }\n        window.onload = function(){\n  \t     \tinit();\n        }\n    </script>\n~~~\n","tags":["移动端"],"categories":["前端"]},{"title":"jQuery中animate动画效果","url":"/2016/05/06/jQuery中animate动画效果/","content":"参考:[http://www.w3school.com.cn/jquery/effect_animate.asp](http://www.w3school.com.cn/jquery/effect_animate.asp)\n\n<!--more-->\n\n## 定义和用法\n\nanimate() 方法执行 CSS 属性集的自定义动画。\n\n该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。\n\n只有数字值可创建动画（比如 \"margin:30px\"）。字符串值无法创建动画（比如 \"background-color:red\"）。\n\n注释：使用 \"+=\" 或 \"-=\" 来创建相对动画（relative animations）。\n\n### 语法 1\n\n> $(selector).animate(styles,speed,easing,callback)\n\n### 参数\t描述\n#### styles\n\n必需。规定产生动画效果的 CSS 样式和值。\n\n#### 可能的 CSS 样式值（提供实例）：\n\n~~~html\n    backgroundPosition\n    borderWidth\n    borderBottomWidth\n    borderLeftWidth\n    borderRightWidth\n    borderTopWidth\n    borderSpacing\n    margin\n    marginBottom\n    marginLeft\n    marginRight\n    marginTop\n    outlineWidth\n    padding\n    paddingBottom\n    paddingLeft\n    paddingRight\n    paddingTop\n    height\n    width\n    maxHeight\n    maxWidth\n    minHeight\n    minWidth\n    font\n    fontSize\n    bottom\n    left\n    right\n    top\n    letterSpacing\n    wordSpacing\n    lineHeight\n    textIndent\n    注释：CSS 样式使用 DOM 名称（比如 \"fontSize\"）来设置，而非 CSS 名称（比如 \"font-size\"）。\n~~~\n\n#### speed\n\n~~~html\n可选。规定动画的速度。默认是 \"normal\"。\n可能的值：\n毫秒 （比如 1500）\n\"slow\"\n\"normal\"\n\"fast\"\n~~~\n\n#### easing\n\n\n~~~html\n可选。规定在不同的动画点中设置动画速度的 easing 函数。\n内置的 easing 函数：\nswing\nlinear\n扩展插件中提供更多 easing 函数。\n~~~\n\n#### callback\n\n~~~html\n可选。animate 函数执行完之后，要执行的函数。\n如需学习更多有关 callback 的内容，请访问我们的 jQuery Callback 这一章。\n~~~\n\n### 语法 2\n\n~~~js\n$(selector).animate(styles,options)\n~~~\n\n### 参数\t描述\n#### styles\t必需。规定产生动画效果的 CSS 样式和值（同上）。\n#### options\n\n可选。规定动画的额外选项。\n可能的值：\n\n~~~html\nspeed - 设置动画的速度\neasing - 规定要使用的 easing 函数\ncallback - 规定动画完成之后要执行的函数\nstep - 规定动画的每一步完成之后要执行的函数\nqueue - 布尔值。指示是否在效果队列中放置动画。如果为 false，则动画将立即开始\nspecialEasing - 来自 styles 参数的一个或多个 CSS 属性的映射，以及它们的对应 easing 函数\n~~~\n\n## 示例：\n\n~~~html\n    <html>\n    <head>\n        <script type=\"text/javascript\" src=\"/jquery/jquery.js\"></script>\n        <script type=\"text/javascript\">\n        $(document).ready(function(){\n          $(\".btn1\").click(function(){\n          $(\"p\").animate({top:\"100px\"});\n          });\n          $(\".btn2\").click(function(){\n          $(\"p\").animate({top:\"0px\"});\n          });\n        });\n        </script>\n    </head>\n    <body>\n        <button class=\"btn1\">Animate</button>\n        <button class=\"btn2\">Reset</button>\n        <div style=\"position:relative\">\n        <p style=\"background-color:yellow;width:100px;position:absolute\">This is a  paragraph.</p>\n        </div>\n    </body>\n    </html>\n~~~\n","tags":["JS"],"categories":["前端"]},{"title":"分别使用text-stroke和text-shadow为文本描边","url":"/2016/04/26/分别使用text-stroke和text-shadow为文本描边/","content":"文本描边\n<!--more-->\n## 使用text-stroke属性\n目前text-stroke仅支持webkit内核的浏览器，所以格式为\n~~~css\n    -webkit-text-stroke:1px black; //描边宽度 描边颜色\n    -webkit-text-fill-color:white;    //为文本填充颜色\n~~~\n代码：\n~~~html    \n    <h1>测试text-stroke属性</h1>\n    <style type=\"text/css\">\n     h1{\n      -webkit-text-stroke: 1px black;\n      -webkit-text-fill-color: white;\n     }\n    </style>\n~~~\n\n结果\n\n## 使用text-shadow属性\n代码：\n~~~html   \n    <h1>测试text-stroke属性</h1>\n    <style type=\"text/css\">\n     h1{\n      color:white;\n      text-shadow:-2px -2px 1px black,  \n                  2px -2px 1px black,\n                  -2px  2px 1px black,\n                  2px  2px 1px black;\n     }\n    </style>\n~~~\n","tags":["CSS"],"categories":["前端"]},{"title":"所有浏览器都适用的创建XMLHttpRequest对象的方法","url":"/2016/04/18/所有浏览器都适用的创建XMLHttpRequest对象的方法/","content":"由于IE7之前的版本不支持使用var xhr ＝ XMLHttpRequest();方法创建ajax对象，所以如果需要支持所有浏览器需要使用下面的方法\n<!--more-->\n~~~js\n    function createXHR(){\n\t\tif(typeof XMLHttpRequest != \"undefined\"){\n\t\t\treturn new XMLHttpRequest();\n\t\t}else if(typeof ActiveXObject != \"undefined\"){\n\t\t\tif(typeof arguments.callee.activeXString != \"string\"){\n\t\t\t\tvar versions = [\"MSXML2.XMLHttp.6.0\",\"MSXML2.XMLHttp.                       3.0\",\"MSXML2.XMLHttp\"],i,len;\n\t\t\t\tfor(i = 0,len=versions.length;i<len;i++){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tnew ActiveXObject(versions[i]);\n\t\t\t\t\t\targuments.callee.activeXString = versions[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}catch(ex){\n\t\t\t\t\t\t//跳过\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new ActiveXObject(arguments.callee.activeXString);\n\t\t}else{\n\t\t\tthrow new Error(\"No XHR object available.\");\n\t\t}\n\t}\n\tvar xhr = createXHR();\n~~~\n##### 请求ajax\n~~~js\n\tvar xhr = createXHR();\n\txhr.open(\"post\",\"check.php\",true);\n\txhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n\txhr.send(null);\n\txhr.onreadystatechange = function(){\n\t\tif(xhr.readyState == 4){\n\t\t\tif((xhr.status>=200 && xhr.status<300) || xhr.status== 304){\n\t\t\t\talert(xhr.responseText);\n\t\t\t}else{\n\t\t\t\talert(\"Request was unsuccessful: \" + xhr.status);\n\t\t\t}\n\t\t}\n\t}\n~~~\n##### xhr.readyState的五种状态\n~~~html\n    0 － （未初始化）还没有调用open()方法 \n    1 － （服务器连接已经建立）已调用open()方法，正在发送请求 \n    2 － （请求已接收）send()方法执行完成，已经接收到全部响应内容 \n    3 － （请求处理中）正在解析响应内容 \n    4 － （请求已完成）响应内容解析完成，可以在客户端调用了\n~~~","tags":["JS"],"categories":["前端"]},{"title":"如何让页面适配各种机型","url":"/2016/04/18/如何让页面适配各种机型/","content":"大杀器rem\n\n<!--more-->\n\n我们可以知道，页面主体中规中矩，分为两部分：上半部分是介绍页面，下半部分是主体界面，有一个点击按钮来负责全部用户交互，为了适配iphone4到6plus以及众多安卓，我们对整个页面的架构可以有如下几种方案：\n\n### 高度百分比\n\n高度百分比方案——整个屏幕的主要高度高度都用百分比定位，比如介绍部分占高度的百分之30，点击抢红包部分占剩下的百分之70。\n\n> 优点——易于理解好上手\n缺点——由于行内样式，行间样式和它们的父子元素具有复杂的宽高关系，因此内部，比如介绍部分的内部的诸多元素想必还要用到px，em等定位方式，因此不那么和谐和有保障，容易小屏溢出或者大屏留白。在这个页面表现为倒计时文字部分和帮谁谁谁砍价的部分难以控制。 \n\n### flex按列布局\nflex布局是一个很不错的方式：对于这个页面，我们可以有如下构想：对于介绍部分，用px或者em定位和布局，而对于剩下的部分则用flex让他填充好下边的空间，再用绝对定位让砍价按钮水平垂直都居中，简直丝滑。\n\n> 优点——丝滑。\n缺点——要硬说有什么缺点的话，那么下端宽度不好控制算一个吧，试想这样构建出来的页面可能会在iphone4中下端一个按钮几乎占满，而在6普拉斯中则会有大量留白。 \n\n### 大杀器rem\n我们知道在rem出来之前，em有着定位根为父元素的天然缺陷，比如在这样的页面中。\n`html>body>div.parent>div.son`\n有这样的css:\n~~~css\n    .html{\n        font-size:10px;\n        .parent{\n            font-size:2em;\n            .son{\n                font-size:1em;\n            }\n        }\n    }\n~~~\n注意以上css写法用了sass。html也简写了。\n\n然后你猜son的字体是多少px？是20，没错。因为他的参照元素是.parent元素，而不是根，这样的话嵌套多了谁敢用em。\n\n幸好rem的横空出现解决了这种问题：rem的参照物就是根元素的font-size，这让我们对于不同的页面有了设置全局标准的可能，大屏幕，我可以设置大的字体单位，小屏幕设置小的。一举解决了百分比定位和flex布局的遗留问题。\n\n怎样确定字体单位呢？有两种方法，第一种比较优雅：媒体查询，我们可以用媒体查询看看浏览设备的宽高，然后设置一个合适的字体单位，另一种方法比较精确，那就是用js去算。\n\n    body宽度document.body.clientWidth\n    body高度document.body.clientHeight\n    document.documentElement.clientWidth ==> 可见区域宽度\n    document.documentElement.clientHeight ==> 可见区域高度\n\n计算方法是这样的，对于这个页面来说:\n\n> 假设：设计稿高度1500px，设计稿中介绍部分高度300px，倒计时字体大小40px，屏幕高度1000px。\n\n> 第一步：计算单位：html的font-size = 屏幕高度 / 100  -->10px;\n\n> 第二步：介绍部分设置成高度30rem。\n\n> 第三步：字体大小设置成4rem。\n\n啊哈，发现他的优点了嘛，没错，全局等比放大的适应。这就意味着，你在6plus里面能看的页面，在iphone4里面同样能看，而且不会因为屏幕小而发生元素交叠的情况，也不会因为屏幕大而出现留白的情况，是我目前最喜欢的一种表达方式。\n\n> 优点：做到了完美适配。\n\n> 缺点：只是等比放大，小屏下字体小，大屏下字体大（不过从经验来讲，字体的大小并不明显，因为屏幕在那呢，看着也舒服）。\n\n> 缺点反驳：我觉得只有一套设计稿，大小屏幕都兼顾完美是不可能的，因为你不知道什么时候该让一个字占用绝对20像素还是绝对是屏幕宽度的百分之五。如果要做到兼顾，也是可以的：用多套设计稿+css媒体查询为不同宽度的页面写好不同的css样式。\n\n#### 对于多屏页面。\n\n##### 1.\n\n在reset.css页面加入媒体查询来根据不同的宽度定好字体单位。\n\n##### 2.\n\n大杀器rem\n\n使用方法同上，不过上面是根据高度来确定字体单位，这里可以用宽度来确定字体单位。\n~~~js\n    \n    var html = document.getElementsByTagName(\"html\");\n    html[0].style.fontSize = document.documentElement.clientWidth/10+\"px\";\n~~~\n让页面在都完美显示算是我实习期间的研究之一，经过了比较，我还是用大杀器rem觉得比较方便一些，当然还有诸多方法值得尝试，比如rem+flex等等，如果有不当之处，还请各位前辈抨击，批评，丢石头给我，感谢前辈和同行的指点！\n~~~js\n    document.body.clientWidth ==> BODY对象宽度\n    document.body.clientHeight ==> BODY对象高度\n    document.documentElement.clientWidth ==> 可见区域宽度\n    document.documentElement.clientHeight ==> 可见区域高度\n\n    网页可见区域宽： document.body.clientWidth\n    网页可见区域高： document.body.clientHeight\n    网页可见区域宽： document.body.offsetWidth (包括边线的宽)\n    网页可见区域高： document.body.offsetHeight (包括边线的高)\n    网页正文全文宽： document.body.scrollWidth\n    网页正文全文高： document.body.scrollHeight\n    网页被卷去的高： document.body.scrollTop\n    网页被卷去的左： document.body.scrollLeft\n    网页正文部分上： window.screenTop\n    网页正文部分左： window.screenLeft\n    屏幕分辨率的高： window.screen.height\n    屏幕分辨率的宽： window.screen.width\n    屏幕可用工作区高度： window.screen.availHeight\n    屏幕可用工作区宽度： window.screen.availWidth\n    \n    // 部分jQuery函数\n    $(window).height() 　//浏览器时下窗口可视区域高度 \n    $(document).height()　　　　//浏览器时下窗口文档的高度 \n    $(document.body).height()　　　　　　//浏览器时下窗口文档body的高度 \n    $(document.body).outerHeight(true)　//浏览器时下窗口文档body的总高度 包括                                   border padding margin \n    $(window).width() 　//浏览器时下窗口可视区域宽度 \n    $(document).width()//浏览器时下窗口文档对于象宽度 \n    $(document.body).width()　　　　　　//浏览器时下窗口文档body的高度 \n    $(document.body).outerWidth(true)　//浏览器时下窗口文档body的总宽度 包括    border padding\n\n    HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth \n    scrollHeight: 获取对象的滚动高度。 \n    scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 \n    scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 \n    scrollWidth:获取对象的滚动宽度 \n    offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 \n    offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 \n    offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 \n    event.clientX 相对文档的水平座标 \n    event.clientY 相对文档的垂直座标 \n    event.offsetX 相对容器的水平坐标 \n    event.offsetY 相对容器的垂直坐标 \n    document.documentElement.scrollTop 垂直方向滚动的值 \n    event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方      向滚动的量\n~~~","tags":["移动端"],"categories":["前端"]}]